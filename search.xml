<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>整除分块</title>
      <link href="/2022/11/12/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/"/>
      <url>/2022/11/12/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1>整除分块</h1><p>整除分块可以快速计算含有下取整除法的和式，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>结论：</p><p>对于常数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，使得式子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mi>n</mi><mi>i</mi></mfrac><mo stretchy="false">⌋</mo><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mi>n</mi><mi>j</mi></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \frac{n}{i} \rfloor = \lfloor \frac{n}{j} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2311079999999999em;vertical-align:-0.481108em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>成立的最大的满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i \leq j \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的值为</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mi>n</mi><mrow><mo stretchy="false">⌊</mo><mfrac><mi>n</mi><mi>i</mi></mfrac><mo stretchy="false">⌋</mo></mrow></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.13856em;vertical-align:-1.0310000000000001em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0310000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span></span></p><p>证明略，有时间的话再补一下吧。。</p><p>即对于左端点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，满足值等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>n</mi><mi>l</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的最大右端点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>的值为上式</p><p>数论分块的过程：</p><p>对于和式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">⌊</mo><mfrac><mi>n</mi><mi>i</mi></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\sum_{i = 1}^{n}f(i)\lfloor \frac{n}{i} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.149292em;vertical-align:-0.345em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span></p><p>先计算出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>的前缀和，然后每次进行分块，将分块求出的结果累加。</p><p>代码实现：</p><pre><code>int H(int n){int res = 0;int l = 1, r = 0;while(l &lt;= n){r = n / (n / l);res += (r - l + 1) * 1ll * (n / l);l = r + 1;}return res;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>每日两题2022-11-7</title>
      <link href="/2022/11/07/%E6%AF%8F%E6%97%A5%E4%B8%A4%E9%A2%982022-11-7/"/>
      <url>/2022/11/07/%E6%AF%8F%E6%97%A5%E4%B8%A4%E9%A2%982022-11-7/</url>
      
        <content type="html"><![CDATA[<h1>每日两题2022-11-6</h1><h2 id="abc130d-enough-array">ABC130D -<strong>Enough Array</strong></h2><p>给出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个数，求这些数中有多少个<strong>连续子序列</strong>的和大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></p><p>数据范围：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq a_i \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq n \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq k \leq 10^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></p><details>    <summary> <font face="Comic Sans MS" size="4" color="pink">思路</font></summary>前缀和+双指针<p>首先可以发现一个结论：对于一个连续子序列，如果其和大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，那么在其加入其他任意非负整数时也一定满足大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></p><p>如果我们用双指针枚举左端点，考虑右端点的位置在何处大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，设该位置为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，则在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>之前的所有连续子序列都不满足大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，而在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>之后的所有连续子序列都一定满足大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，这个子序列的个数可以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>地计算出来，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>之后的元素个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - r + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>在遍历完所有的左端点后，上面的答案累加起来即为最终的答案</p></details><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e5 + 10;int a[N];int s[N];int res;signed main(){int n, k;cin &gt;&gt; n &gt;&gt; k;for(int i = 1; i &lt;= n; i ++){cin &gt;&gt; a[i];s[i] = s[i - 1] + a[i];}int l = 0, r = 0;while(r &lt;= n){if(s[r] - s[l] &lt; k)r ++;else{res += (n - r + 1);l ++;}}cout &lt;&lt; res &lt;&lt; endl;return 0;}</code></pre></details><h2 id="abc130e-common-subsequence">ABC130E - Common Subsequence</h2><p>给出两个长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>的整数序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>，求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>的公共子序列的个数对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>e</mi><mn>9</mn><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">1e9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>取模的结果。</p><p>数据范围：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq S_i,T_i \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">1 \leq n,m, \leq 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p><details>    <summary> <font face="Comic Sans MS" size="4" color="pink">思路</font></summary>线性$DP$，设$dp[i][j]$表示从$S$的前$i$个数中选，$T$的前$j$个数中选的公共子序列的个数<p>考虑当前的状态如何转移而来：</p><p>显然<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的状态应该由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i - 1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>转移而来</p><p>然后考虑当前位是否相同，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i] \neq t[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，说明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i - 1][j] + dp[i][j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>之后会有计算重复的部分(因为当前位不对答案有贡献)。因此要减去重复累加的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i - 1][j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><p>即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i] \neq t[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>−</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = dp[i - 1][j]+dp[i][j - 1]-dp[i - 1][j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><p>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i] = t[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>则当前位对答案具有贡献(因为产生了新的公共子序列)，因此不需要减去重复的部分，另外再加上当前位单独产生的子序列</p><p>即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s[i] = t[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>答案即为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[n][m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span>，注意取模即可。</p></details><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2010, mod = 1e9 + 7;int dp[N][N];int a[N], b[N];int n, m;signed main(){cin &gt;&gt; n &gt;&gt; m;for(int i = 1; i &lt;= n; i ++)cin &gt;&gt; a[i];for(int i = 1; i &lt;= m; i ++)cin &gt;&gt; b[i];for(int i = 1; i &lt;= n; i ++){for(int j = 1; j &lt;= m; j ++){if(a[i] != b[j])dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + mod) % mod;elsedp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + 1) % mod;}}cout &lt;&lt; (dp[n][m] + 1) % mod &lt;&lt; endl;return 0;}</code></pre></details>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>每日一题2022-11-3</title>
      <link href="/2022/11/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982022-11-3/"/>
      <url>/2022/11/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982022-11-3/</url>
      
        <content type="html"><![CDATA[<h1>每日两题2022-11-3</h1><h2 id="abc129c-typical-stairs">ABC129C - Typical Stairs</h2><p>有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>级台阶，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>级台阶不能走，分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">a_1,...a_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>级台阶。</p><p>现在你要从第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>级台阶出发，每次可以向上一格或两格，求走到第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>级台阶的方案数，答案对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>取模。</p><p>数据范围：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq n \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \leq m \leq n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>a</mi><mn>2</mn></msub><mo>≤</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>≤</mo><msub><mi>a</mi><mi>m</mi></msub><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \leq a_1 \leq a_2 \leq ... \leq a_m \leq n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><details>    <summary> <font face="Comic Sans MS" size="4" color="pink">思路</font></summary>显然线性$DP$，考虑当前第$i$级台阶的答案由那些情况递推出来<p>本题中每次可以走一格或两格，因此第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>级台阶可以由第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>级台阶或者第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i - 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>级台阶走上来。</p><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示从走到第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>级台阶的方案数，则状态转移方程：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1] + dp[i - 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></p><p>之后考虑不能走的台阶，如果当前枚举到的台阶不能走，跳过即可，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i - 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>级台阶不能走，我们无需额外考虑（因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span>值为0）</p><p>最后注意边界：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的值不能直接初始化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，要考虑到该台阶不能走的情况。</p></details><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e5 + 10, mod = 1e9 + 7;int dp[N], v[N];int n, k;signed main(){    cin &gt;&gt; n &gt;&gt; k;    for(int i = 1; i &lt;= k; i ++)    {        int x;        cin &gt;&gt; x;        v[x] = 1;    }    //dp[i] = dp[i - 1] + dp[i - 2];    dp[0] = 1, dp[1] = (v[1] == 1 ? 0 : 1);    for(int i = 2; i &lt;= n; i ++)    {        if(!v[i])   dp[i] = (dp[i - 1] + dp[i - 2]) % mod;    }    cout &lt;&lt; dp[n] % mod &lt;&lt; endl;    return 0;}</code></pre></details><h2 id="abc129e-sum-equals-xor">ABC129E -Sum Equals Xor</h2><p>以二进制形式给出一个整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>，问有多少个非负整数对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>满足：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>a</mi><mo>⊕</mo><mi>b</mi><mo>≤</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">a + b = a \oplus b \leq L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></p><p>答案对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9 + 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>取模</p><details>    <summary> <font face="Comic Sans MS" size="4" color="pink">思路</font></summary>显然线性$DP$，考虑当前第$i$级台阶的答案由那些情况递推出来数位$DP$，题目中给定的已经是二进制形式，显然按照二进制形式的每一位进行讨论。<p>观察可知<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>a</mi><mo>⊕</mo><mi>b</mi><mo>≤</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">a + b = a \oplus b \leq L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>等价于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>的二进制表示上同一位上不能同时为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \oplus b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>位小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>的前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>为的方案数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \oplus b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>位等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>的前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>位的方案数。</p><p>考虑状态如何递推而来：</p><p>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>位为1，符合等于条件的情况有：上一位等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>且这一位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a = 1,b = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a = 0,b = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，符合小于条件的情况有：上一位小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>，且这一位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a = 0,b = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a = 1,b = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a = 0,b = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，上一位等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a = 0,b = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><p>即：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>∗</mo><mn>3</mn><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][0] = dp[i - 1][0] * 3 + dp[i - 1][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">dp[i][1] = dp[i - 1][1] * 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p><p>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>位为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，符合等于条件的情况有：上一位等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a = 0,b = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，符合小于条件的情况有：上一位小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a = 0,b = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a = 0,b = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a = 1,b = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><p>即：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>∗</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][0] = (dp[i - 1][0] * 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][1] = dp[i - 1][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><p>答案即为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[n][0] + dp[n][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p></details><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1e5 + 10, mod = 1e9 + 7;char s[N];int dp[N][2];signed main(){cin &gt;&gt; (s + 1);int n = strlen(s + 1);dp[0][1] = 1;for(int i = 1; i &lt;= n; i ++){dp[i][0] = (dp[i - 1][0] * 3) % mod;if(s[i] == '1'){dp[i][0] = (dp[i][0] + dp[i - 1][1]) % mod;dp[i][1] = (dp[i - 1][1] * 2) % mod;}elsedp[i][1] = dp[i - 1][1];}cout &lt;&lt; (dp[n][1] + dp[n][0]) % mod;return 0; }</code></pre></details>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ACM算法模板</title>
      <link href="/2022/10/18/ACM%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/10/18/ACM%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1>1. 基础算法</h1><h4 id="1-1求逆序对数量">1.1求逆序对数量</h4><pre><code class="language-cpp">long long m_sort(int l,int r){    if(l&gt;=r) return 0;    int mid=l+r&gt;&gt;1;    int i=l,j=mid+1;    long long res=m_sort(l,mid)+m_sort(mid+1,r);    int k=0;    while(i&lt;=mid&amp;&amp;j&lt;=r)    {        if(q[i]&lt;=q[j]) temp[k++]=q[i++];        else {            temp[k++]=q[j++];            res+=mid-i+1;        }    }    while(i&lt;=mid)    {        temp[k++]=q[i++];    }    while(j&lt;=r) temp[k++]=q[j++];    for(int i=l,j=0;i&lt;=r;i++,j++)    q[i]=temp[j];    return res;}</code></pre><h4 id="1-2-二分">1.2 二分</h4><pre><code class="language-cpp">while(l&lt;r)        {            int mid=l+r&gt;&gt;1;            if(q[mid]&gt;=k) r=mid;        //二分，若右区间被替换，则mid为l+r&gt;&gt;1            else l=mid+1;        }while(l&lt;r)            {                int mid=l+r+1 &gt;&gt; 1;                if(q[mid]&lt;=k)   l=mid;      //若左区间被替换，则mid为l+r+1&gt;&gt;1                else r=mid-1;            }</code></pre><h4 id="1-3-二维前缀和与差分与二维差分">1.3 二维前缀和与差分与二维差分</h4><pre><code class="language-cpp">/二维前缀和  for(int i=1;i&lt;=n;i++)        for(int j=0;j&lt;=m;j++)            S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j];//一维差分void insert(int l,int r,int c){    b[l]+=c;    b[r+1]-=c;} for(int i=1;i&lt;=n;i++)    insert(i,i,a[i]);    while (m -- ){        int l,r,c;        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;        insert(l,r,c);    }    for(int i=1;i&lt;=n;i++)    b[i]+=b[i-1];//二维差分void insert(int x1,int y1,int x2,int y2,int c){    b[x1][y1]+=c;    b[x2+1][y1]-=c;    b[x1][y2+1]-=c;    b[x2+1][y2+1]+=c;}for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=m;j++)            insert(i,j,i,j,a[i][j]);    while (q -- ){        int x1,y1,x2,y2,c;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;        insert(x1,y1,x2,y2,c);    }    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=m;j++)            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];</code></pre><h4 id="1-4-双指针典例">1.4 双指针典例</h4><h5 id="1-4-1-最长连续不重复子序列">1.4.1 最长连续不重复子序列</h5><pre><code class="language-cpp">int res=0;    for(int i=0,j=0;i&lt;n;i++)    {        s[a[i]]++;        while(s[a[i]]&gt;1)        {            s[a[j]]--;            j++;        }        res=max(res,i-j+1);    }</code></pre><h5 id="1-4-2-判断a是否为b的子序列-1e5">1.4.2 判断a是否为b的子序列（1e5）</h5><pre><code class="language-cpp">    int i=0,j=0;    while( i&lt;n &amp;&amp;j &lt; m)    {        if(a[i]==b[j])  i++;;        j++;    }</code></pre><h4 id="1-5-需要保序的离散化">1.5 需要保序的离散化</h4><pre><code class="language-cpp">typedef pair&lt;int, int&gt; PII;         //每一次操作都是一个二元组，这里用pairint n,m;int a[N],s[N];vector &lt;int&gt; alls;          //alls数组内存的是所有需要进行离散化的数以及进行完离散化之后的数组vector&lt;PII&gt; add,query;          //add数组内存的是每次对数的操作，query数组内存的是每次询问的左右区间int find (int x)            //查找离散化后数组的下标{    int l = 0, r = alls.size()-1;           while(l &lt; r)    {        int mid = (l+r) &gt;&gt; 1;        if(alls[mid] &gt;= x)  r = mid;        //当该下标对应的值为待查找值（离散化前的大数）时，返回下标+1（为了从1开始便于求前缀和）        else l = mid + 1;    }    return r + 1;}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i &lt; n ; i++)    {        int x , c;        scanf(&quot;%d%d&quot;,&amp;x, &amp;c);        add.push_back({x,c});   //把对原数组的操作存放进去,即把x加上c        alls.push_back(x);      //将需要进行离散化的数存到alls里    }    for(int i = 0; i &lt; m; i++)            {                int l, r;                scanf(&quot;%d%d&quot;,&amp;l, &amp;r);                query.push_back({l, r});        //把每次询问存放进去，即存放需要求和的左右区间                alls.push_back(l);          //由于l,r也可能是大数，因此我们也需要将l和r进行离散化                alls.push_back(r);            }    //此处是离散化的核心，即进行离散化的过程    sort(alls.begin(), alls.end());             //将需要离散化的数组进行排序    alls.erase(unique(alls.begin(), alls.end()),alls.end());    //去重，目的是将数组中的存放的数量减少，节省内存空间    for(auto it : add)              {        int x = find(it.first);         //寻找被加的数进行离散化之后的下标        a[x] += it.second;              //求离散化后的数组a    }    for(int i=1;i&lt;=alls.size(); i++)    s[i] = s[i-1] + a[i];               //求离散化后数组的前缀和    for(auto it : query) {                  //处理每次询问        int l = find(it.first);                 //寻找左区间进行离散化之后的下标        int r = find(it.second);                //寻找右区间进行离散化之后的下标        printf(&quot;%d\n&quot; ,s[r]-s[l-1]);             //求区间和    }    return 0;}</code></pre><h4 id="1-6-不需要保序的离散化">1.6 不需要保序的离散化</h4><pre><code class="language-cpp">//待补充</code></pre><h4 id="1-7-区间合并">1.7 区间合并</h4><pre><code class="language-cpp">vector&lt;PII&gt; segs;void merge(vector&lt;PII&gt; &amp;segs){    vector&lt;PII&gt; res;    sort(segs.begin(), segs.end());    int st = -2e9, ed = -2e9;    for(auto seg : segs)    {        if(ed &lt; seg.first)        {            if(st != -2e9)                res.push_back({st , ed});            st = seg.first;            ed = seg.second;        }           else        ed=max(ed , seg.second);    }            if(st != -2e9)  res.push_back({st , ed});        segs=res;}int main(){    int n;    cin&gt;&gt;n;    for(int i = 0;i &lt; n; i++ )    {        int l , r;        cin&gt;&gt;l&gt;&gt;r;        segs.push_back({l,r});    }    merge(segs);    cout&lt;&lt;segs.size()&lt;&lt;endl;    return 0;}</code></pre><h4 id="1-8-区间最值问题-rmq">1.8 区间最值问题（RMQ）</h4><pre><code class="language-cpp">int w[N];int f[N][M];int n, m;void init(){    for(int j = 0; j &lt; M; j ++)     //先枚举区间长度    {        for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++)      //枚举区间左端点        {            if(!j)  f[i][j] = w[i];            else    f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; j - 1)][j - 1]);        }    }}int query(int l, int r){    int len = r - l + 1;    int k = log(len) / log(2);    return max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);        //这两个区间一定覆盖查询区间}int main(){    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i ++)        cin &gt;&gt; w[i];    init();    cin &gt;&gt; m;    while (m -- )    {        int l, r;        cin &gt;&gt; l &gt;&gt; r;        cout &lt;&lt; query(l, r) &lt;&lt; endl;    }    return 0;}</code></pre><h4 id="1-9-manacher算法">1.9 manacher算法</h4><pre><code class="language-cpp">int n;char a[N], b[N];int p[N];int res;void init(){    int k = 0;    b[k ++] = '$';    b[k ++] = '#';    for(int i = 0; i &lt; n; i ++)    {        b[k ++] = a[i];        b[k ++] = '#';    }    b[k ++] = '^';    n = k;}void manacher(){    int mr = 0, mid;    for(int i = 1; i &lt; n; i ++)    {        if(i &lt; mr)            p[i] = min(p[mid * 2 - i], mr - i);        else p[i] = 1;        while(b[i - p[i]] == b[i + p[i]])   p[i] ++;        if(i + p[i] &gt; mr)        {            mr = i + p[i];            mid = i;        }    }}int main(){    scanf(&quot;%s&quot;, a);    n = strlen(a);    init();    manacher();    for(int i = 0; i &lt; n; i ++)        res = max(res, p[i]);    cout &lt;&lt; res - 1 &lt;&lt; endl;    return 0;}</code></pre><h4 id="1-10-最小表示法">1.10 最小表示法</h4><pre><code class="language-cpp">//用于求字符串的最小表示，可以用来判断两个环形字符串是否是同一个字符串int get_min(char s[]){    int i = 0, j = 1;    while(i &lt; n &amp;&amp; j &lt; n)    {        int k = 0;        while(k &lt; n &amp;&amp; s[i + k] == s[j + k])    k ++;        if(k == n)  break;        if(s[i + k] &gt; s[j + k]) i += k + 1;        else j += k + 1;        if(i == j)  j ++;    }    int k = min(i, j);    s[k + n] = 0;    return k;}int main(){    cin &gt;&gt; a &gt;&gt; b;    n = strlen(a);    memcpy(a + n, a, n);    memcpy(b + n, b, n);    int x = get_min(a);    int y = get_min(b);    if(strcmp(a + x, b + y))    cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;    else    {        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;        cout &lt;&lt; a + x &lt;&lt; endl;    }    return 0;}</code></pre><h4 id="1-11-对顶堆维护动态中位数">1.11 对顶堆维护动态中位数</h4><pre><code class="language-cpp">/*对顶堆，维护一个大根堆和一个小根堆，对于每个元素，如果大根堆为空或小于大根堆顶，则插入大根堆，否则插到小根堆，这两个堆需要时刻满足：序列中从小到大排名为1 ~ M / 2 + 1的整数在大根堆中序列中从小到大排名为M / 2 + 2 ~ M的整数存储在小根堆中如果不满足，就把多出来的数放到另一个堆，由此序列的中位数一定是大根堆的堆顶*/int main(){    int T;    cin &gt;&gt; T;    while(T --)    {        priority_queue&lt;int&gt; b_heap;        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; s_heap;        int n, m;        cin &gt;&gt; n &gt;&gt; m;        cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; (m + 1 &gt;&gt; 1) &lt;&lt; endl;        int cnt = 0;        for(int i = 0; i &lt; m; i ++)        {            int x;            cin &gt;&gt; x;            if(b_heap.empty() || x &lt;= b_heap.top()) //大根堆为空或x小于大根堆顶，插入大根堆                b_heap.push(x);            else    s_heap.push(x);     //否则插入小根堆            if(b_heap.size() &gt; s_heap.size() + 1)            {                s_heap.push(b_heap.top());                b_heap.pop();            }            if(s_heap.size() &gt; b_heap.size())            {                b_heap.push(s_heap.top());                s_heap.pop();            }            if(i % 2 == 0)            {                cout &lt;&lt; b_heap.top() &lt;&lt; &quot; &quot;;                if(++ cnt % 10 == 0)    cout &lt;&lt; endl;            }        }        if(cnt % 10)    cout &lt;&lt; endl;    }    return 0;}</code></pre><h4 id="1-12-二进制状态压缩求最短hamilton路径">1.12 二进制状态压缩求最短Hamilton路径</h4><pre><code class="language-cpp">int n;int w[N][N];                            //用w来存储整个图int f[M][N];                            //f[i][j]表示从0走到j，走过的点为i的所有路径长度，i是一个20位二进制数，如果第k位为1，表示这个点已经走过了int main(){    cin &gt;&gt; n;                           //n个点    for(int i = 0; i &lt; n; i ++)             {        for(int j = 0; j &lt; n; j ++)            cin &gt;&gt; w[i][j];             //输入n个点    }    memset(f, 0x3f, sizeof f);          //初始化路径长度为无穷大    f[1][0] = 0;                        //初始化0号点的路径长度为0    for(int i = 0; i &lt; 1 &lt;&lt; n; i ++)    //枚举所有的状态        for(int j = 0; j &lt; n; j ++)            if(i &gt;&gt; j &amp; 1)              //从0走到j时，i中一定要包含j，即i的第j位一定为1                for(int k = 0; k &lt; n; k ++)             //枚举j点从哪一个点转移过来                    if((i - (1 &lt;&lt; j)) &gt;&gt; k &amp; 1)         //如果i除去第j个点之后包含第k个点                        f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j]);   //那么当前的状态就是从0走到k加上k走到j的所有路径取最小值    cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;             //输出走完所有的点，并且走到n-1号点时的距离    return 0;}</code></pre><h1>2. 数据结构</h1><h4 id="2-1-单调栈">2.1 单调栈</h4><pre><code class="language-cpp">//用于寻找一个数左边最近的比它大（小）的数int stk[N],tt;int main(){    int n;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)    {        int x;        cin&gt;&gt;x;        while(tt &amp;&amp; stk[tt]&gt;=x) tt--;        if(tt)      cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;;        else        cout&lt;&lt;&quot;-1&quot;&lt;&lt;&quot; &quot;;        stk[++tt] = x;    }    return 0;}</code></pre><h4 id="2-2-单调队列-滑动窗口">2.2 单调队列（滑动窗口）</h4><pre><code class="language-cpp">//维护区间内最大值和最小值int n,k;int a[N],q[N];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    for(int i=0;i&lt;n;i++)    scanf(&quot;%d&quot;,&amp;a[i]);    int hh=0,tt=-1;    for(int i=0;i&lt;n;i++)    {        //首先判断队头是否滑出滑动窗口        if(hh &lt;=tt   &amp;&amp; i - k + 1 &gt; q[hh])  hh++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;        q[++tt] = i;        if(i &gt;= k-1)        printf(&quot;%d &quot;,a[q[hh]]);    }    puts(&quot;&quot;);    hh = 0, tt = -1;    for(int i=0;i&lt;n;i++)    {        //首先判断队头是否滑出滑动窗口        if(hh &lt;=tt   &amp;&amp; i - k + 1 &gt; q[hh])  hh++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;        q[++tt] = i;        if(i &gt;= k - 1)        printf(&quot;%d &quot;,a[q[hh]]);    }    puts(&quot;&quot;);    return 0;}</code></pre><h4 id="2-3-kmp算法">2.3 KMP算法</h4><pre><code class="language-cpp">/*KMP算法是一种在模式串中寻找给定模板串的一种算法，该算法的时间复杂度为O(M+N)，相较于暴力算法，该算法最大的特点是模板串指针不需要回溯即可判断两个串是否匹配该算法需要注意的几个地方1. next数组的含义：next[i]的含义为：当当前模式串与模板串的元素不匹配时，当前元素之前的模板串的元素中，前缀与后缀相同的最大串长度2. 求next数组时，next数组从下标2开始求，因为next[0]和next[1]的值均为0,3. 进行kmp匹配时，从i下标1开始，j从下标0开始4. p数组和s数组均从下标1开始存放元素*/int n,m;char p[N], s[M];int ne[N];int main(){    cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1;    //p数组和s数组均从下标1开始存放元素    //求next数组的过程    for(int i = 2 ,j = 0; i &lt;= n ; i++ )    {        while(j &amp;&amp; p[i] != p[j+1])  j=ne[j];    //前缀与后缀不同时，记录前缀与后缀相同时的长度        if(p[i] == p[j+1])  j++;        //如果前缀和后缀相同，那么ij继续右移，判断更大的前缀后缀是否相同        ne[i] = j;     //next数组的含义是:当当前模式串与模板串的元素不匹配时，当前元素之前的模板串的元素中，前缀与后缀相同的最大串长度    }    //kmp的匹配过程    for(int i = 1, j = 0; i &lt;= m; i ++)    {        while(j &amp;&amp; s[i] != p[j+1])  j = ne[j];      //当模板串与模式串不匹配时，将模板串右移ne[j]的距离        if(s[i] == p[j+1])  j++;        //如果模板串与模式串匹配，那么就将它们的下一位进行匹配        if(j == n)      //如果模板串所有的字符都被匹配了，那么匹配成功        {            printf(&quot;%d &quot;,i-n);            j=ne[j];        }    }    return 0;}</code></pre><h4 id="2-4-trie统计字符串">2.4 Trie统计字符串</h4><pre><code class="language-cpp">//son数组第一维表示n号节点，第二维表示它的第几个儿子int son[N][26],cnt[N],idx;char str[N];void insert(char str[]){    int p=0;    for(int i=0 ; str[i] ; i++)    {        int u = str[i] - 'a';           //将字母映射到下标        if(!son[p][u])      son[p][u]=++idx;        //如果该节点的儿子不存在，那么就将它加入进去        p=son[p][u];            //转到p号节点的u号儿子    }    cnt[p]++;           //出现次数+1}int query(char str[]){    int p=0;    for(int i=0;str[i];i++)    {        int u = str[i] - 'a';        if(!son[p][u])  return 0;        p = son[p][u];    }    return cnt[p];}int main(){    int n;    cin&gt;&gt;n;    while (n -- ){        char op[2];        scanf(&quot;%s%s&quot;,op,str);        if(op[0] == 'I')    insert(str);        else printf(&quot;%d\n&quot;, query(str));    }    return 0;}</code></pre><h4 id="2-5-并查集带维护集合大小">2.5 并查集带维护集合大小</h4><pre><code class="language-cpp">int find(int x)  // 并查集{    if(p[x] != x)   p[x] = find(p[x]);    return p[x];}int main(){    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)    {    p[i]=i;    siz[i]=1;    }    cin&gt;&gt;m;    while (m -- )    {        char op[5];        int a,b;        scanf(&quot;%s&quot;,op);        if(op[0] == 'C')        {             scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            if(find(a) == find(b))  continue;            siz[find(b)] += siz[find(a)];            p[find(a)] = find(b);         }        else if(op[1] == '1')        {             scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            if(find(a) == find(b))            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;            else            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        }        else if(op[1] == '2')        {             scanf(&quot;%d&quot;,&amp;a);             cout&lt;&lt;siz[find(a)]&lt;&lt;endl;        }    }    return 0;}</code></pre><h4 id="2-6-拓展域并查集-拆点">2.6 拓展域并查集（拆点）</h4><pre><code class="language-cpp">int find(int x){    if(p[x] != x)   p[x] = find(p[x]);    return p[x];}int main(){    cin &gt;&gt; n &gt;&gt; k;    int res = 0;    for(int i = 1; i &lt;= 3 * n; i ++)    p[i] = i;    while(k --)    {        int d, x, y;        cin &gt;&gt; d &gt;&gt; x &gt;&gt; y;        int xs = x, xe = x + n, xy = x + 2 * n;        int ys = y, ye = y + n, yy = y + 2 * n;        if(d == 1)        {            if(x &gt; n || y &gt; n)  res ++;            else if(find(xs) == find(yy))   res ++;            else if(find(ye) == find(xs))   res ++;            else            {                p[find(xs)] = find(ys);                p[find(xe)] = find(ye);                p[find(xy)] = find(yy);            }        }        if(d == 2)        {            if(x &gt; n || y &gt; n)  res ++;            else if(x == y) res ++;            else if(find(xs) == find(ys))   res ++;            else if(find(ye) == find(xs))   res ++;            else            {                p[find(xe)] = find(ys);                p[find(xs)] = find(yy);                p[find(xy)] = find(ye);            }        }    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><h4 id="2-7-手写堆排序">2.7 手写堆排序</h4><pre><code class="language-cpp">int h[N];int n,m;int siz;void down(int u){    int t = u;                  //t为最小值    if(u * 2 &lt;= siz &amp;&amp; h[u * 2] &lt; h[t])    t = u * 2;                  //如果左儿子存在并且左儿子的值小于父节点的值，那么最小值更新为左儿子    if(u * 2 + 1 &lt;= siz &amp;&amp; h[u * 2 + 1] &lt; h[t])  t = u * 2 + 1;        //如果右儿子存在并且右儿子的值小于父节点的值，那么最小值更新为右儿子    if(u != t)                          //如果传入的值不是最小值，那么将该值与最小值互换，然后递归将该值放入堆中    {        swap(h[u], h[t]);        down(t);    }}void up(int u){   while(u / 2 &amp;&amp; h[u / 2] &gt; h[u])   {       swap(h[u / 2], h[u]);       u /= 2;   }}int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++)    scanf(&quot;%d&quot;, &amp;h[i]);    siz = n;    for(int i = n / 2; i; i--)    down(i);    while (m -- )    {            cout &lt;&lt; h[1] &lt;&lt; &quot; &quot;;            h[1] = h[siz];            siz--;            down(1);    }    return 0;}</code></pre><h4 id="2-8-字符串哈希">2.8 字符串哈希</h4><pre><code class="language-cpp">//用于判断两个区间内的字符串是否完全相同typedef unsigned long long ULL;const int N = 1e5 + 5, P = 131;ULL h[N], p[N];ULL query(int l, int r){    return  h[r] - h[l - 1] * p[r - l + 1];}int main(){    int n, m;    cin &gt;&gt; n &gt;&gt; m;    string x;    cin &gt;&gt; x;    p[0] = 1;    h[0] = 0;    for(int i = 0; i &lt; n; i ++)    {        p[i + 1] = p[i] * P;        h[i + 1] = h[i] * P + x[i];    }    while(m --)    {        int l1, r1, l2, r2;        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;        if(query(l1, r1) == query(l2, r2))            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;        else            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;    }    return 0;}</code></pre><h4 id="2-9-树状数组">2.9 树状数组</h4><h5 id="2-9-1-区间修改-单点查询">2.9.1 区间修改，单点查询</h5><pre><code class="language-cpp">LL tr[N];int a[N];int n, m;int lowbit(int x){    return x &amp; -x;}void add(int x, int c){    for(int i = x; i &lt;= n; i += lowbit(i))    tr[i] += c;}LL sum(int x){    LL res = 0;    for(int i = x; i ; i -= lowbit(i))    res += tr[i];    return res;}int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n ; i ++)    cin &gt;&gt; a[i];    for(int i = 1; i &lt;= n ;i ++)    {        add(i, a[i] - a[i - 1]);    }    while(m --)    {        char op[2];        int l;        scanf(&quot;%s%d&quot;, op, &amp;l);        if(op[0] == 'C')        {            int r, d;            cin &gt;&gt; r &gt;&gt; d;            add(l, d);            add(r + 1, -d);        }        else        cout &lt;&lt; sum(l) &lt;&lt; endl;    }    return 0;}</code></pre><h5 id="2-9-2-单点修改-区间查询">2.9.2 单点修改，区间查询</h5><pre><code class="language-cpp">int lowbit(int x){    return x &amp; -x;}void add(int x, int c){    for(int i = x; i &lt;= n; i += lowbit(i))    tr[i] += c;    }int sum(int x){    int res = 0;    for(int i = x; i; i -= lowbit(i))  res += tr[i];    return res;}</code></pre><h5 id="2-9-3-区间修改-区间查询">2.9.3 区间修改，区间查询</h5><pre><code class="language-cpp">int a[N];LL tr1[N], tr2[N];int n, m;int lowbit(int x){    return x &amp; -x;}void add(LL tr[], int x, LL c){    for(int i = x; i &lt;= n; i += lowbit(i))    tr[i] += c;}LL sum(LL tr[], int x){    LL res = 0;    for(int i = x; i; i -= lowbit(i))    res += tr[i];    return res;}LL pre_sum(int x)                       //求原数组的前缀和{    return sum(tr1, x) * (x + 1) - sum(tr2, x);}int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i ++)    cin &gt;&gt; a[i];    for(int i = 1; i &lt;= n; i ++)    {        int b = a[i] - a[i - 1];        add(tr1, i, b);        add(tr2, i, (LL)b * i);    }    while(m --)    {        char op[2];        int l ,r, d;        scanf(&quot;%s%d%d&quot;, op, &amp;l, &amp;r);        if(op[0] == 'Q')        printf(&quot;%lld\n&quot;, pre_sum(r) - pre_sum(l - 1));          //原数组的区间查询        else        {            cin &gt;&gt; d;            add(tr1, l, d), add(tr2, l, l * d);            add(tr1, r + 1, -d), add(tr2, r + 1, (r + 1) * -d);        }    }    return 0;}</code></pre><h4 id="2-10-线段树">2.10 线段树</h4><h5 id="2-10-1-单点修改-区间查询">2.10.1  单点修改，区间查询</h5><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10; struct info{int minv, cnt_min;}; struct Node{info val;}tr[N * 4];int n, q;int a[N]; info operator + (const info &amp;l, const info &amp;r){info a;a.minv = min(l.minv, r.minv);if(l.minv == r.minv)a.cnt_min = l.cnt_min + r.cnt_min;else if(l.minv &lt; r.minv)a.cnt_min = l.cnt_min;else a.cnt_min = r.cnt_min;return a;} void pushup(int u){tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val;} void build(int u, int l, int r){if(l == r)tr[u].val = {a[l], 1};else{int mid = l + r &gt;&gt; 1;build(u &lt;&lt; 1, l, mid);build(u &lt;&lt; 1 | 1, mid + 1, r);pushup(u);}} void change(int u, int l, int r, int pos, int val){if(l == r)tr[u].val = {val, 1};else{int mid = l + r &gt;&gt; 1;if(pos &lt;= mid)change(u &lt;&lt; 1, l, mid, pos, val);elsechange(u &lt;&lt; 1 | 1, mid + 1, r, pos, val);pushup(u);}} info query(int u, int l, int r, int ql, int qr){if(l == ql &amp;&amp; r == qr)return tr[u].val;int mid = l + r &gt;&gt; 1;if(qr &lt;= mid)return query(u &lt;&lt; 1, l, mid, ql, qr);else if(ql &gt; mid)return query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr);else{return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr);}} int main(){scanf(&quot;%d%d&quot;, &amp;n, &amp;q);for(int i = 1; i &lt;= n; i ++)scanf(&quot;%d&quot;, &amp;a[i]);build(1, 1, n);while(q --){int a, b, c;scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);if(a == 1){change(1, 1, n, b, c);}else{auto a = query(1, 1, n, b, c);printf(&quot;%d %d\n&quot;, a.minv, a.cnt_min);}}}</code></pre><h5 id="2-10-2-区间最大公约数-区间修改-区间查询">2.10.2 区间最大公约数（区间修改，区间查询）</h5><pre><code class="language-cpp">struct Node{    int l, r;    LL sum, d;}tr[N * 4];LL a[N];LL gcd(LL a, LL b){    return b ? gcd(b, a % b) : a;}void build(int u, int l, int r){    if(l == r)    {        LL b = a[r] - a[r - 1];        tr[u] = {l, l, b, b};    }    else    {        tr[u] = {l ,r};        int mid = l + r &gt;&gt; 1;        build(u &lt;&lt; 1, l, mid);        build(u &lt;&lt; 1 | 1, mid + 1, r);        tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;        tr[u].d = gcd(tr[u &lt;&lt; 1].d, tr[u &lt;&lt; 1 | 1].d);    }}Node query(int u, int l, int r){    if(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)    return tr[u];    else    {        int mid = tr[u].l + tr[u].r &gt;&gt; 1;        if(r &lt;= mid)    return  query(u &lt;&lt; 1, l, r);        if(l &gt; mid)    return query(u &lt;&lt; 1 | 1, l, r);        else        {            auto left = query(u &lt;&lt; 1, l, r);            auto right = query(u &lt;&lt; 1 | 1, l, r);            Node res;            res.sum = left.sum + right.sum;            res.d = gcd(left.d, right.d);            return res;        }    }}void modify(int u, int x, LL c){    if(tr[u].l == x &amp;&amp;  tr[u].r == x)    {        LL b = tr[u].sum + c;        tr[u] = {x, x, b, b};    }    else    {        int mid = tr[u].l +tr[u].r &gt;&gt; 1;        if(x &lt;= mid)    modify(u &lt;&lt; 1, x, c);        else    modify(u &lt;&lt; 1 | 1, x, c);        tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;        tr[u].d = gcd(tr[u &lt;&lt; 1].d, tr[u &lt;&lt; 1 | 1].d);    }}int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i ++)        cin &gt;&gt; a[i];    build(1, 1, n);    char op[2];    while(m --)    {        int l, r;        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;        if(op[0] == 'C')        {            LL d;            cin &gt;&gt; d;            modify(1, l, d);            if(r + 1 &lt;= n)                modify(1, r + 1, -d);        }        else        {            auto left = query(1, 1, l);            Node right({0, 0, 0, 0});            if(l + 1 &lt;= r)    right = query(1, l + 1, r);            cout &lt;&lt; abs(gcd(left.sum, right.d)) &lt;&lt; endl;        }    }    return 0;}</code></pre><h5 id="2-10-3-带懒标记的区间修改-区间查询">2.10.3 带懒标记的区间修改，区间查询</h5><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;typedef long long ll;ll n, q;ll a[N]; struct info{ll maxv;}; struct tag{ll add;}; info operator + (const info &amp;l, const info &amp;r){return {max(l.maxv, r.maxv)};} info operator + (const info &amp;v, const tag &amp;t){return {v.maxv + t.add};} tag operator + (const tag &amp;t1, const tag &amp;t2){return {t1.add + t2.add};} struct node{tag t;info val;}tr[N * 4]; void pushup(int u){tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val;} void settag(int u, tag t){tr[u].val = tr[u].val + t;tr[u].t = tr[u].t + t;} void pushdown(int u){if(tr[u].t.add != 0){settag(u &lt;&lt; 1, tr[u].t);settag(u &lt;&lt; 1 | 1, tr[u].t);tr[u].t.add = 0;}} void build(int u, int l, int r){if(l == r)tr[u].val = {a[l]};else{ll mid = l + r &gt;&gt; 1;build(u &lt;&lt; 1, l, mid);build(u &lt;&lt; 1 | 1, mid + 1, r);pushup(u);}} void modify(int u, int l, int r, int ql, int qr, tag t){if(l == ql &amp;&amp; r == qr){settag(u, t);return ;}ll mid = l + r &gt;&gt; 1;pushdown(u);if(qr &lt;= mid)modify(u &lt;&lt; 1, l, mid, ql, qr, t);else if(ql &gt; mid)modify(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr, t);else{modify(u &lt;&lt; 1, l, mid, ql, mid, t);modify(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr, t);}pushup(u);} info query(int u, int l, int r, int ql, int qr){if(l == ql &amp;&amp; r == qr)return tr[u].val;ll mid = l + r &gt;&gt; 1;pushdown(u);if(qr &lt;= mid)query(u &lt;&lt; 1, l, mid, ql, qr);else if(ql &gt; mid)query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr);else{return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr);}} int main(){scanf(&quot;%d%d&quot;, &amp;n, &amp;q);for(int i = 1; i &lt;= n; i ++)scanf(&quot;%d&quot;, &amp;a[i]);build(1, 1, n);while(q --){int op;scanf(&quot;%d&quot;, &amp;op);if(op == 1){int l, r, d;scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d);modify(1, 1, n, l, r, (tag){d});}else{int l, r;scanf(&quot;%d%d&quot;, &amp;l, &amp;r);auto a = query(1, 1, n, l, r);printf(&quot;%lld\n&quot;, a.maxv);}}return 0;}</code></pre><h5 id="2-10-4-扫描线求矩形的面积并">2.10.4 扫描线求矩形的面积并</h5><pre><code class="language-cpp">struct Segment{    double x, y1, y2;    int k;    bool operator&lt; (const Segment &amp;t)const    {        return x &lt; t.x;    }}seg[N * 2];struct Node{    int l, r;    int cnt;    double len;}tr[N * 8];vector&lt;double&gt; ys;int find(double y){    return lower_bound(ys.begin(), ys.end(), y) - ys.begin();}void pushup(int u){    if (tr[u].cnt) tr[u].len = ys[tr[u].r + 1] - ys[tr[u].l];    else if (tr[u].l != tr[u].r)    {        tr[u].len = tr[u &lt;&lt; 1].len + tr[u &lt;&lt; 1 | 1].len;    }    else tr[u].len = 0;}void build(int u, int l, int r){    tr[u] = {l, r, 0, 0};    if (l != r)    {        int mid = l + r &gt;&gt; 1;        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);    }}void modify(int u, int l, int r, int k){    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)    {        tr[u].cnt += k;        pushup(u);    }    else    {        int mid = tr[u].l + tr[u].r &gt;&gt; 1;        if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, k);        if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, k);        pushup(u);    }}int main(){    int T = 1;    while (scanf(&quot;%d&quot;, &amp;n), n)    {        ys.clear();        for (int i = 0, j = 0; i &lt; n; i ++ )        {            double x1, y1, x2, y2;            scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);            seg[j ++ ] = {x1, y1, y2, 1};            seg[j ++ ] = {x2, y1, y2, -1};            ys.push_back(y1), ys.push_back(y2);        }        sort(ys.begin(), ys.end());        ys.erase(unique(ys.begin(), ys.end()), ys.end());        build(1, 0, ys.size() - 2);        sort(seg, seg + n * 2);        double res = 0;        for (int i = 0; i &lt; n * 2; i ++ )        {            if (i &gt; 0) res += tr[1].len * (seg[i].x - seg[i - 1].x);            modify(1, find(seg[i].y1), find(seg[i].y2) - 1, seg[i].k);        }        printf(&quot;Test case #%d\n&quot;, T ++ );        printf(&quot;Total explored area: %.2lf\n\n&quot;, res);    }    return 0;}</code></pre><h5 id="2-10-5-动态开点与权值线段树">2.10.5 动态开点与权值线段树</h5><pre><code class="language-cpp">//待补充</code></pre><h4 id="2-11-可持久化数据结构">2.11 可持久化数据结构</h4><h5 id="2-11-1-可持久化trie">2.11.1 可持久化Trie</h5><pre><code class="language-cpp">//支持两种操作：末尾添加一个数，求一个位置p，使得p在l-r之间，且a[p] xor ... xor a[n] xor x的值最大int tr[M][2], max_id[M];int root[N];int n, m, idx;int s[N];void insert(int i, int k, int p, int q) //i为前缀和下标，k为当前第几位，p为上一个版本，q为当前版本{    if(k &lt; 0)    {        max_id[q] = i;        return ;    }    int v = s[i] &gt;&gt; k &amp; 1;    if(p)   tr[q][v ^ 1] = tr[p][v ^ 1];    tr[q][v] =  ++ idx;    insert(i, k - 1, tr[p][v], tr[q][v]);    max_id[q] = max(max_id[tr[q][0]], max_id[tr[q][1]]);}int query(int root, int c, int l){    int p = root;    for(int i = 23; i &gt;= 0; i --)    {        int v = c &gt;&gt; i &amp; 1;        if(max_id[tr[p][v ^ 1]] &gt;= l)   p = tr[p][v ^ 1];        else    p = tr[p][v];    }    return c ^ s[max_id[p]];}int main(){    cin &gt;&gt; n &gt;&gt; m;    max_id[0] = -1;    root[0] = ++ idx;    insert(0, 23, 0, root[0]);    for(int i = 1; i &lt;= n; i ++)    {        int x;        cin &gt;&gt; x;        s[i] = s[i - 1] ^ x;        root[i] = ++ idx;        insert(i, 23, root[i - 1], root[i]);    }    char op[2];    int l, r, x;    while(m --)    {        cin &gt;&gt; op;        if(op[0] == 'A')        {            cin &gt;&gt; x;            n ++;            s[n] = s[n - 1] ^ x;            root[n] = ++ idx;            insert(n, 23, root[n - 1], root[n]);        }        else        {            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;            cout &lt;&lt; query(root[r - 1], s[n] ^ x, l - 1) &lt;&lt; endl;        }    }    return 0;}</code></pre><h5 id="2-11-2-可持久化线段树-主席树">2.11.2 可持久化线段树(主席树)</h5><pre><code class="language-cpp">//求区间内第k小数int n, m;int a[N];vector&lt;int&gt; nums;struct Node{    int l, r;    int cnt;}tr[N * 4 + N * 17];int root[N], idx;int build(int l, int r) //l,r表示左右儿子{    int p = ++ idx;    if(l == r)  return p;    int mid = l + r &gt;&gt; 1;    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);    return p;}int insert(int p, int l, int r, int x){    int q = ++ idx;    tr[q] = tr[p];    if(l == r)    {        tr[q].cnt ++;          return q;    }    int mid = l + r &gt;&gt; 1;    if(x &lt;= mid)    tr[q].l = insert(tr[p].l, l, mid, x);    else    tr[q].r = insert(tr[p].r, mid + 1, r, x);    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;    return q;}int find(int x){    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();}int query(int q, int p, int l, int r, int k){    if(l == r)  return r;    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;    int mid = l + r &gt;&gt; 1;    if(k &lt;= cnt)    return query(tr[q].l, tr[p].l, l, mid, k);    else    return query(tr[q].r, tr[p].r, mid + 1, r, k - cnt);}int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i ++)    {        cin &gt;&gt; a[i];        nums.push_back(a[i]);    }    sort(nums.begin(), nums.end());    nums.erase(unique(nums.begin(), nums.end()), nums.end());    root[0] = build(0, nums.size() - 1);    for(int i = 1; i &lt;= n; i ++)        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]));    while(m --)    {        int l, r, k;        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;        cout &lt;&lt; nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &lt;&lt; endl;    }}</code></pre><h4 id="2-12-平衡树">2.12 平衡树</h4><h5 id="2-12-1-普通平衡树-treap">2.12.1 普通平衡树（Treap）</h5><pre><code class="language-cpp">/*支持的操作：1. 插入数值 x。2. 删除数值 x(若有多个相同的数，应只删除一个)。3. 查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。4. 查询排名为 x 的数值。5. 求数值 x 的前驱(前驱定义为小于 x 的最大的数)。6. 求数值 x 的后继(后继定义为大于 x 的最小的数)。*/struct Node{    int l, r;    int key, val;    int cnt, size;  //cnt表示某个数出现的次数，size表示子树中有多少个数}tr[N];int root, idx;  //idx表示当前分配到第几个节点void pushup(int p){    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;}int get_node(int key)   //创建节点{    tr[++ idx].key = key;    tr[idx].val = rand();    tr[idx].cnt = tr[idx].size = 1; //初始化cnt和size    return idx;}void zig(int &amp;p)    //右旋，传引用{    int q = tr[p].l;    tr[p].l = tr[q].r, tr[q].r = p, p = q;    pushup(tr[p].r), pushup(p);}void zag(int &amp;p){    int q = tr[p].r;    tr[p].r = tr[q].l, tr[q].l = p, p = q;    pushup(tr[p].l), pushup(p);}void build(){    get_node(-INF), get_node(INF);  //插入正无穷和无负穷哨兵    root = 1, tr[1].r = 2;  //根节点是一号点，右儿子是二号点    pushup(root);    if(tr[1].val &lt;tr[2].val) zag(root);}void insert(int &amp;p, int key){    if(!p)  p = get_node(key);    else if(tr[p].key == key)   tr[p].cnt ++;    else if(tr[p].key &gt; key)    {        insert(tr[p].l, key);        if(tr[tr[p].l].val &gt; tr[p].val) zig(p);    }    else    {        insert(tr[p].r, key);        if(tr[tr[p].r].val &gt; tr[p].val) zag(p);    }    pushup(p);}void remove(int &amp;p, int key){    if(!p)  return ;    if(tr[p].key == key)    {        if(tr[p].cnt &gt; 1)   tr[p].cnt --;        else if(tr[p].l || tr[p].r)        {            if(!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)            {                zig(p);                remove(tr[p].r, key);            }            else            {                zag(p);                remove(tr[p].l, key);            }        }        else p = 0;    }    else if(tr[p].key &gt; key)    remove(tr[p].l, key);    else remove(tr[p].r, key);    pushup(p);}int get_rank_by_key(int &amp;p, int key)    //通过排名找数值{    if(!p)  return 0;    if(tr[p].key == key)    return tr[tr[p].l].size + 1;    if(tr[p].key &gt; key) return get_rank_by_key(tr[p].l, key);    return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r, key);}int get_key_by_rank(int &amp;p, int rank)   //通过数值找排名{    if(!p)  return INF;    if(tr[tr[p].l].size &gt;= rank)    return get_key_by_rank(tr[p].l, rank);    if(tr[tr[p].l].size + tr[p].cnt &gt;= rank)    return tr[p].key;    return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);}int get_prev(int &amp;p, int key)   //找到严格小于key的最大数{    if(!p)  return -INF;    if(tr[p].key &gt;= key)    return get_prev(tr[p].l, key);    return max(tr[p].key, get_prev(tr[p].r, key));}int get_next(int &amp;p, int key)   //找到严格大于key的最小数{    if(!p)  return INF;    if(tr[p].key &lt;= key)    return get_next(tr[p].r, key);    return min(tr[p].key, get_next(tr[p].l, key));}int main(){    build();    cin &gt;&gt; n;    while(n --)    {        int op, x;        cin &gt;&gt; op &gt;&gt; x;        if(op == 1) insert(root, x);        else if(op == 2)    remove(root, x);        else if(op == 3)    cout &lt;&lt; get_rank_by_key(root, x) - 1 &lt;&lt; endl;        else if(op == 4)    cout &lt;&lt; get_key_by_rank(root, x + 1) &lt;&lt; endl;        else if(op == 5)    cout &lt;&lt; get_prev(root, x) &lt;&lt; endl;        else if(op == 6)    cout &lt;&lt; get_next(root, x) &lt;&lt; endl;    }    return 0;}</code></pre><h5 id="2-12-2-splay-伸展树">2.12.2 Splay(伸展树)</h5><pre><code class="language-cpp">/*m 次操作，每次操作选定一个子序列 [l,r]，并将该子序列中的所有数字进行翻转*/int n, m;struct Node{    int s[2], p, v;    int size, flag;    void init(int _v, int _p)    {        v = _v, p = _p;        size = 1;    }}tr[N];int root, idx;void pushup(int x){    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;}void pushdown(int x){    if (tr[x].flag)    {        swap(tr[x].s[0], tr[x].s[1]);        tr[tr[x].s[0]].flag ^= 1;        tr[tr[x].s[1]].flag ^= 1;        tr[x].flag = 0;    }}void rotate(int x){    int y = tr[x].p, z = tr[y].p;    int k = tr[y].s[1] == x;  // k=0表示x是y的左儿子；k=1表示x是y的右儿子    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;    tr[x].s[k ^ 1] = y, tr[y].p = x;    pushup(y), pushup(x);}void splay(int x, int k){    while (tr[x].p != k)    {        int y = tr[x].p, z = tr[y].p;        if (z != k)            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);            else rotate(y);        rotate(x);    }    if (!k) root = x;}void insert(int v){    int u = root, p = 0;    while (u) p = u, u = tr[u].s[v &gt; tr[u].v];    u = ++ idx;    if (p) tr[p].s[v &gt; tr[p].v] = u;    tr[u].init(v, p);    splay(u, 0);}int get_k(int k){    int u = root;    while (true)    {        pushdown(u);        if (tr[tr[u].s[0]].size &gt;= k) u = tr[u].s[0];        else if (tr[tr[u].s[0]].size + 1 == k) return u;        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];    }    return -1;}void output(int u){    pushdown(u);    if (tr[u].s[0]) output(tr[u].s[0]);    if (tr[u].v &gt;= 1 &amp;&amp; tr[u].v &lt;= n) printf(&quot;%d &quot;, tr[u].v);    if (tr[u].s[1]) output(tr[u].s[1]);}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 0; i &lt;= n + 1; i ++ ) insert(i);    while (m -- )    {        int l, r;        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);        l = get_k(l), r = get_k(r + 2);        splay(l, 0), splay(r, l);        tr[tr[r].s[0]].flag ^= 1;    }    output(root);    return 0;}</code></pre><h4 id="2-13-ac自动机">2.13  AC自动机</h4><pre><code class="language-cpp">/给定n个单词，长度为m的文章，求有多少个单词在文章中出现了int n;int tr[N * S][26], cnt[N * S], idx;char str[M];int q[N * S], ne[N * S];void insert(){    int p = 0;    for (int i = 0; str[i]; i ++ )    {        int t = str[i] - 'a';        if (!tr[p][t]) tr[p][t] = ++ idx;        p = tr[p][t];    }    cnt[p] ++ ;}void build(){    int hh = 0, tt = -1;    for (int i = 0; i &lt; 26; i ++ )        if (tr[0][i])            q[ ++ tt] = tr[0][i];    while (hh &lt;= tt)    {        int t = q[hh ++ ];        for (int i = 0; i &lt; 26; i ++ )        {            int p = tr[t][i];            if (!p) tr[t][i] = tr[ne[t]][i];            else            {                ne[p] = tr[ne[t]][i];                q[ ++ tt] = p;            }        }    }}int main(){    int T;    scanf(&quot;%d&quot;, &amp;T);    while (T -- )    {        memset(tr, 0, sizeof tr);        memset(cnt, 0, sizeof cnt);        memset(ne, 0, sizeof ne);        idx = 0;        scanf(&quot;%d&quot;, &amp;n);        for (int i = 0; i &lt; n; i ++ )        {            scanf(&quot;%s&quot;, str);            insert();        }        build();        scanf(&quot;%s&quot;, str);        int res = 0;        for (int i = 0, j = 0; str[i]; i ++ )        {            int t = str[i] - 'a';            j = tr[j][t];            int p = j;            while (p)            {                res += cnt[p];                cnt[p] = 0;                p = ne[p];            }        }        printf(&quot;%d\n&quot;, res);    }    return 0;}</code></pre><h4 id="2-14-分块与莫队">2.14 分块与莫队</h4><h5 id="2-14-1-分块解决区间修改-区间查询">2.14.1 分块解决区间修改，区间查询</h5><pre><code class="language-cpp">LL a[N], sum[N], add[N];int L[N], R[N];int pos[N];int n, m, t;void modify(int l, int r, LL d){    int p = pos[l], q = pos[r];    if(p == q)    {        for(int i = l; i &lt;= r; i ++)            a[i] += d;        sum[p] += d * (r - l + 1);    }    else    {        for(int i = p + 1; i &lt;= q - 1; i ++)            add[i] += d;        for(int i = l; i &lt;= R[p]; i ++)            a[i] += d;        sum[p] += d * (R[p] - l + 1);        for(int i = L[q]; i &lt;= r; i ++)            a[i] += d;        sum[q] += d * (r - L[q] + 1);    }}LL query(int l, int r){    int p = pos[l], q = pos[r];    LL ans = 0;    if(p == q)    {        for(int i = l; i &lt;= r; i ++)            ans += a[i];        ans += add[p] * (r - l + 1);    }    else    {        for(int i = p + 1; i &lt;= q - 1; i ++)            ans += sum[i] + add[i] * (R[i] - L[i] + 1);        for(int i = l; i &lt;= R[p]; i ++)            ans += a[i];        ans += add[p] * (R[p] - l + 1);        for(int i = L[q]; i &lt;= r; i ++)            ans += a[i];        ans += add[q] * (r - L[q] + 1);    }    return ans;}int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i ++)        cin &gt;&gt; a[i];    //分块    t = sqrt(n);    for(int i = 1; i &lt;= t; i ++)    {        L[i] = (i - 1) * sqrt(n) + 1;        R[i] = i * sqrt(n);    }    if(R[t] &lt; n)    {        t ++;        L[t] = R[t - 1] + 1;        R[t] = n;    }    for(int i = 1; i &lt;= t; i ++)    {        for(int j = L[i]; j &lt;= R[i]; j ++)        {            pos[j] = i;            sum[i] += a[j];        }    }    while(m --)    {        char op[3];        int l, r, d;        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;        if(op[0] == 'C')        {            cin &gt;&gt; d;            modify(l, r, d);        }        else    cout &lt;&lt; query(l, r) &lt;&lt; endl;    }    return 0;}</code></pre><h5 id="2-14-2-分块-块状链表">2.14.2 分块-块状链表</h5><pre><code class="language-cpp">//待补充</code></pre><h5 id="2-14-3-基础莫队">2.14.3 基础莫队</h5><pre><code class="language-cpp">//求一段区间内有多少个不同的数int n, m, len;int w[N], ans[M];struct Query{    int id, l, r;}q[M];int cnt[S];int get(int x)      //求块的编号{    return x / len;}bool cmp(const Query&amp; a, const Query&amp; b){    int i = get(a.l), j = get(b.l);    if(i != j)  return i &lt; j;    return a.r &lt; b.r;}void add(int x, int&amp; res){    if(!cnt[x]) res ++;    cnt[x] ++;}void del(int x, int &amp; res){    cnt[x] --;    if(!cnt[x]) res --;}int main(){    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i ++)        cin &gt;&gt; w[i];    cin &gt;&gt; m;    len = max(1, (int)sqrt((double)n * n / m));    for(int i = 0; i &lt; m; i ++)    {        int l, r;        cin &gt;&gt; l &gt;&gt; r;        q[i] = {i, l, r};    }    sort(q, q + m, cmp);    for(int k = 0, i = 0, j = 1, res = 0; k &lt; m; k ++)  //处理所有询问    {        int id = q[k].id, l = q[k].l, r = q[k].r;   //区间的编号，区间左右端点        while(i &lt; r)    add(w[ ++ i], res);     //当前区间加一个数        while(i &gt; r)    del(w[i --], res);        while(j &lt; l)    del(w[j ++], res);        while(j &gt; l)    add(w[-- j], res);        ans[id] = res;    }    for(int i = 0; i &lt; m; i ++)        cout &lt;&lt; ans[i] &lt;&lt; endl;    return 0;}</code></pre><h4 id="2-15-点分治">2.15 点分治</h4><pre><code class="language-cpp">//求树上边权长度不超过K的路径有多少条int n, m;int h[N], e[M], w[M], ne[M], idx;bool st[N];     //表示点是否被删掉int p[N], q[N];void add(int a, int b, int c){    e[idx] = b;    w[idx] = c;    ne[idx] = h[a];    h[a] = idx ++;}int get_size(int u, int fa)     //求子树大小{    if(st[u])   return 0;    int res = 1;    for(int i = h[u]; ~i; i = ne[i])    {        int j = e[i];        if(j != fa)            res += get_size(j, u);    }    return res;}int get_wc(int u, int fa, int tot, int&amp; wc) //求树的重心{    if(st[u])   return 0;    int sum = 1, ms = 0;    for(int i = h[u]; ~i; i = ne[i])    {        int j = e[i];        if(j == fa) continue;        int t = get_wc(j, u, tot, wc);        ms = max(ms, t);        sum += t;    }    ms = max(ms, tot - sum);    if(ms &lt;= tot / 2)   wc = u;    return sum;}void get_dist(int u, int fa, int dist, int&amp; qt){    if(st[u])   return ;    q[qt ++] = dist;    for(int i = h[u]; ~i; i = ne[i])        if(e[i] != fa)            get_dist(e[i], u, dist + w[i], qt);}int get(int a[], int k){    sort(a, a + k);    int res = 0;    for(int i = k - 1, j = -1; i &gt;= 0; i --)    {        while(j + 1 &lt; i &amp;&amp; a[j + 1] + a[i] &lt;= m)    j ++;        j = min(j, i - 1);        res += j + 1;    }    return res;}int calc(int u){    if(st[u])   return 0;    int res = 0;    get_wc(u, -1, get_size(u, -1), u);    st[u] = true;    int pt = 0;    for(int i = h[u]; ~i; i = ne[i])    {        int j = e[i], qt = 0;        get_dist(j, -1, w[i], qt);        res -= get(q, qt);        for(int k = 0; k &lt; qt; k ++)        {            if(q[k] &lt;= m)   res ++;            p[pt ++] = q[k];        }    }    res += get(p, pt);    for(int i = h[u]; ~i; i = ne[i])    {        res += calc(e[i]);    }    return res;}int main(){    while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n, m)    {        memset(st, 0, sizeof st);        idx = 0;        memset(h, -1, sizeof h);        for(int i = 0; i &lt; n - 1; i ++)        {            int a, b, c;            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;            add(a, b, c);            add(b, a, c);        }        cout &lt;&lt; calc(0) &lt;&lt; endl;    }    return 0;}</code></pre><h4 id="2-16-树套树-线段树套平衡树">2.16 树套树(线段树套平衡树)</h4><pre><code class="language-cpp">/*树套树用于维护一个长度为n的数列，支持以下操作1. `1 l r x`，查询整数 x 在区间 [l,r] 内的排名。2. `2 l r k`，查询区间 [l,r] 内排名为 k 的值。3. `3 pos x`，将 pos 位置的数修改为 x。4. `4 l r x`，查询整数 x 在区间 [l,r] 内的前驱(前驱定义为小于 x，且最大的数)。5. `5 l r x`，查询整数 x 在区间 [l,r] 内的后继(后继定义为大于 x，且最小的数)。的数)。*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2000010, INF = 1e9;int n, m;struct Node{    int s[2], p, v;    int size;    void init(int _v, int _p)    {        v = _v, p = _p;        size = 1;    }}tr[N];int L[N], R[N], T[N], idx;int w[N];void pushup(int x){    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;}void rotate(int x){    int y = tr[x].p, z = tr[y].p;    int k = tr[y].s[1] == x;    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;    tr[x].s[k ^ 1] = y, tr[y].p = x;    pushup(y), pushup(x);}void splay(int&amp; root, int x, int k){    while (tr[x].p != k)    {        int y = tr[x].p, z = tr[y].p;        if (z != k)            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);            else rotate(y);        rotate(x);    }    if (!k) root = x;}void insert(int&amp; root, int v){    int u = root, p = 0;    while (u) p = u, u = tr[u].s[v &gt; tr[u].v];    u = ++ idx;    if (p) tr[p].s[v &gt; tr[p].v] = u;    tr[u].init(v, p);    splay(root, u, 0);}int get_k(int root, int v){    int u = root, res = 0;    while (u)    {        if (tr[u].v &lt; v) res += tr[tr[u].s[0]].size + 1, u = tr[u].s[1];        else u = tr[u].s[0];    }    return res;}void update(int&amp; root, int x, int y){    int u = root;    while (u)    {        if (tr[u].v == x) break;        if (tr[u].v &lt; x) u = tr[u].s[1];        else u = tr[u].s[0];    }    splay(root, u, 0);    int l = tr[u].s[0], r = tr[u].s[1];    while (tr[l].s[1]) l = tr[l].s[1];    while (tr[r].s[0]) r = tr[r].s[0];    splay(root, l, 0), splay(root, r, l);    tr[r].s[0] = 0;    pushup(r), pushup(l);    insert(root, y);}void build(int u, int l, int r){    L[u] = l, R[u] = r;    insert(T[u], -INF), insert(T[u], INF);    for (int i = l; i &lt;= r; i ++ ) insert(T[u], w[i]);    if (l == r) return;    int mid = l + r &gt;&gt; 1;    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);}int query(int u, int a, int b, int x){    if (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) return get_k(T[u], x) - 1;    int mid = L[u] + R[u] &gt;&gt; 1, res = 0;    if (a &lt;= mid) res += query(u &lt;&lt; 1, a, b, x);    if (b &gt; mid) res += query(u &lt;&lt; 1 | 1, a, b, x);    return res;}void change(int u, int p, int x){    update(T[u], w[p], x);    if (L[u] == R[u]) return;    int mid = L[u] + R[u] &gt;&gt; 1;    if (p &lt;= mid) change(u &lt;&lt; 1, p, x);    else change(u &lt;&lt; 1 | 1, p, x);}int get_pre(int root, int v){    int u = root, res = -INF;    while (u)    {        if (tr[u].v &lt; v) res = max(res, tr[u].v), u = tr[u].s[1];        else u = tr[u].s[0];    }    return res;}int get_suc(int root, int v){    int u = root, res = INF;    while (u)    {        if (tr[u].v &gt; v) res = min(res, tr[u].v), u = tr[u].s[0];        else u = tr[u].s[1];    }    return res;}int query_pre(int u, int a, int b, int x){    if (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) return get_pre(T[u], x);    int mid = L[u] + R[u] &gt;&gt; 1, res = -INF;    if (a &lt;= mid) res = max(res, query_pre(u &lt;&lt; 1, a, b, x));    if (b &gt; mid) res = max(res, query_pre(u &lt;&lt; 1 | 1, a, b, x));    return res;}int query_suc(int u, int a, int b, int x){    if (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) return get_suc(T[u], x);    int mid = L[u] + R[u] &gt;&gt; 1, res = INF;    if (a &lt;= mid) res = min(res, query_suc(u &lt;&lt; 1, a, b, x));    if (b &gt; mid) res = min(res, query_suc(u &lt;&lt; 1 | 1, a, b, x));    return res;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);    build(1, 1, n);    while (m -- )    {        int op, a, b, x;        scanf(&quot;%d&quot;, &amp;op);        if (op == 1)        {            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x);            printf(&quot;%d\n&quot;, query(1, a, b, x) + 1);        }        else if (op == 2)        {            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x);            int l = 0, r = 1e8;            while (l &lt; r)            {                int mid = l + r + 1 &gt;&gt; 1;                if (query(1, a, b, mid) + 1 &lt;= x) l = mid;                else r = mid - 1;            }            printf(&quot;%d\n&quot;, r);        }        else if (op == 3)        {            scanf(&quot;%d%d&quot;, &amp;a, &amp;x);            change(1, a, x);            w[a] = x;        }        else if (op == 4)        {            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x);            printf(&quot;%d\n&quot;, query_pre(1, a, b, x));        }        else        {            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x);            printf(&quot;%d\n&quot;, query_suc(1, a, b, x));        }    }    return 0;}</code></pre><h6 id="树套树动态维护区间第k大数">树套树动态维护区间第k大数</h6><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 50010, P = N * 17 * 17, M = N * 4;int n, m;struct Tree{    int l, r, sum, add;}tr[P];int L[M], R[M], T[M], idx;struct Query{    int op, a, b, c;}q[N];vector&lt;int&gt; nums;int get(int x){    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();}void build(int u, int l, int r){    L[u] = l, R[u] = r, T[u] = ++ idx;    if (l == r) return;    int mid = l + r &gt;&gt; 1;    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);}int intersection(int a, int b, int c, int d){    return min(b, d) - max(a, c) + 1;}void update(int u, int l, int r, int pl, int pr){    tr[u].sum += intersection(l, r, pl, pr);    if (l &gt;= pl &amp;&amp; r &lt;= pr)    {        tr[u].add ++ ;        return;    }    int mid = l + r &gt;&gt; 1;    if (pl &lt;= mid)    {        if (!tr[u].l) tr[u].l = ++ idx;        update(tr[u].l, l, mid, pl, pr);    }    if (pr &gt; mid)    {        if (!tr[u].r) tr[u].r = ++ idx;        update(tr[u].r, mid + 1, r, pl, pr);    }}void change(int u, int a, int b, int c){    update(T[u], 1, n, a, b);    if (L[u] == R[u]) return;    int mid = L[u] + R[u] &gt;&gt; 1;    if (c &lt;= mid) change(u &lt;&lt; 1, a, b, c);    else change(u &lt;&lt; 1 | 1, a, b, c);}int get_sum(int u, int l, int r, int pl, int pr, int add){    if (l &gt;= pl &amp;&amp; r &lt;= pr) return tr[u].sum + (r - l + 1) * add;    int mid = l + r &gt;&gt; 1, res = 0;    add += tr[u].add;    if (pl &lt;= mid)    {        if (tr[u].l) res += get_sum(tr[u].l, l, mid, pl, pr, add);        else res += intersection(l, mid, pl, pr) * add;    }    if (pr &gt; mid)    {        if (tr[u].r) res += get_sum(tr[u].r, mid + 1, r, pl, pr, add);        else res += intersection(mid + 1, r, pl, pr) * add;    }    return res;}int query(int u, int a, int b, int c){    if (L[u] == R[u]) return R[u];    int mid = L[u] + R[u] &gt;&gt; 1;    int k = get_sum(T[u &lt;&lt; 1 | 1], 1, n, a, b, 0);    if (k &gt;= c) return query(u &lt;&lt; 1 | 1, a, b, c);    return query(u &lt;&lt; 1, a, b, c - k);}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 0; i &lt; m; i ++ )    {        scanf(&quot;%d%d%d%d&quot;, &amp;q[i].op, &amp;q[i].a, &amp;q[i].b, &amp;q[i].c);        if (q[i].op == 1) nums.push_back(q[i].c);    }    sort(nums.begin(), nums.end());    nums.erase(unique(nums.begin(), nums.end()), nums.end());    build(1, 0, nums.size() - 1);    for (int i = 0; i &lt; m; i ++ )    {        int op = q[i].op, a = q[i].a, b = q[i].b, c = q[i].c;        if (op == 1) change(1, a, b, get(c));        else printf(&quot;%d\n&quot;, nums[query(1, a, b, c)]);    }    return 0;}</code></pre><h4 id="2-17-树链剖分-树上差分plus">2.17 树链剖分(树上差分plus)</h4><pre><code class="language-cpp">/*维护一棵树，支持以下操作：- `1 u v k`，修改路径上节点权值，将节点 u 和节点 v 之间路径上的所有节点（包括这两个节点）的权值增加 k。- `2 u k`，修改子树上节点权值，将以节点 u 为根的子树上的所有节点的权值增加 k。- `3 u v`，询问路径，询问节点 u 和节点 v 之间路径上的所有节点（包括这两个节点）的权值和。- `4 u`，询问子树，询问以节点 u 为根的子树上的所有节点的权值和。*/#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 100010, M = N * 2;int n, m;int w[N], h[N], e[M], ne[M], idx;int id[N], nw[N], cnt;int dep[N], sz[N], top[N], fa[N], son[N];struct Tree{    int l, r;    LL add, sum;}tr[N * 4];void add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}void dfs1(int u, int father, int depth){    dep[u] = depth, fa[u] = father, sz[u] = 1;    for (int i = h[u]; ~i; i = ne[i])    {        int j = e[i];        if (j == father) continue;        dfs1(j, u, depth + 1);        sz[u] += sz[j];        if (sz[son[u]] &lt; sz[j]) son[u] = j;    }}void dfs2(int u, int t){    id[u] = ++ cnt, nw[cnt] = w[u], top[u] = t;    if (!son[u]) return;    dfs2(son[u], t);    for (int i = h[u]; ~i; i = ne[i])    {        int j = e[i];        if (j == fa[u] || j == son[u]) continue;        dfs2(j, j);    }}void pushup(int u){    tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;}void pushdown(int u){    auto &amp;root = tr[u], &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1];    if (root.add)    {        left.add += root.add, left.sum += root.add * (left.r - left.l + 1);        right.add += root.add, right.sum += root.add * (right.r - right.l + 1);        root.add = 0;    }}void build(int u, int l, int r){    tr[u] = {l, r, 0, nw[r]};    if (l == r) return;    int mid = l + r &gt;&gt; 1;    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);    pushup(u);}void update(int u, int l, int r, int k){    if (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)    {        tr[u].add += k;        tr[u].sum += k * (tr[u].r - tr[u].l + 1);        return;    }    pushdown(u);    int mid = tr[u].l + tr[u].r &gt;&gt; 1;    if (l &lt;= mid) update(u &lt;&lt; 1, l, r, k);    if (r &gt; mid) update(u &lt;&lt; 1 | 1, l, r, k);    pushup(u);}LL query(int u, int l, int r){    if (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) return tr[u].sum;    pushdown(u);    int mid = tr[u].l + tr[u].r &gt;&gt; 1;    LL res = 0;    if (l &lt;= mid) res += query(u &lt;&lt; 1, l, r);    if (r &gt; mid) res += query(u &lt;&lt; 1 | 1, l, r);    return res;}void update_path(int u, int v, int k){    while (top[u] != top[v])    {        if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);        update(1, id[top[u]], id[u], k);        u = fa[top[u]];    }    if (dep[u] &lt; dep[v]) swap(u, v);    update(1, id[v], id[u], k);}LL query_path(int u, int v){    LL res = 0;    while (top[u] != top[v])    {        if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);        res += query(1, id[top[u]], id[u]);        u = fa[top[u]];    }    if (dep[u] &lt; dep[v]) swap(u, v);    res += query(1, id[v], id[u]);    return res;}void update_tree(int u, int k){    update(1, id[u], id[u] + sz[u] - 1, k);}LL query_tree(int u){    return query(1, id[u], id[u] + sz[u] - 1);}int main(){    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);    memset(h, -1, sizeof h);    for (int i = 0; i &lt; n - 1; i ++ )    {        int a, b;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        add(a, b), add(b, a);    }    dfs1(1, -1, 1);    dfs2(1, 1);    build(1, 1, n);    scanf(&quot;%d&quot;, &amp;m);    while (m -- )    {        int t, u, v, k;        scanf(&quot;%d%d&quot;, &amp;t, &amp;u);        if (t == 1)        {            scanf(&quot;%d%d&quot;, &amp;v, &amp;k);            update_path(u, v, k);        }        else if (t == 2)        {            scanf(&quot;%d&quot;, &amp;k);            update_tree(u, k);        }        else if (t == 3)        {            scanf(&quot;%d&quot;, &amp;v);            printf(&quot;%lld\n&quot;, query_path(u, v));        }        else printf(&quot;%lld\n&quot;, query_tree(u));    }    return 0;}</code></pre><h4 id="2-18-动态树">2.18 动态树</h4><pre><code class="language-cpp">/*维护一棵树，支持以下操作：- `0 x y`，表示询问点 x 到点 y 之间的路径上的所有点（包括两端点）的权值的异或和。保证 x 和 y 之间存在连通路径。- `1 x y`，表示在点 x 和点 y 之间增加一条边 (x,y)。注意：**如果两点已经处于连通状态，则无视该操作**。- `2 x y`，表示删除边 (x,y)。注意：**如果该边不存在，则无视该操作**。- `3 x w`，表示将点 x 的权值修改为 w。*/#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;struct Node{    int s[2], p, v;    int sum, rev;}tr[N];int stk[N];void pushrev(int x){    swap(tr[x].s[0], tr[x].s[1]);    tr[x].rev ^= 1;}void pushup(int x){    tr[x].sum = tr[tr[x].s[0]].sum ^ tr[x].v ^ tr[tr[x].s[1]].sum;}void pushdown(int x){    if (tr[x].rev)    {        pushrev(tr[x].s[0]), pushrev(tr[x].s[1]);        tr[x].rev = 0;    }}bool isroot(int x){    return tr[tr[x].p].s[0] != x &amp;&amp; tr[tr[x].p].s[1] != x;}void rotate(int x){    int y = tr[x].p, z = tr[y].p;    int k = tr[y].s[1] == x;    if (!isroot(y)) tr[z].s[tr[z].s[1] == y] = x;    tr[x].p = z;    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;    tr[x].s[k ^ 1] = y, tr[y].p = x;    pushup(y), pushup(x);}void splay(int x){    int top = 0, r = x;    stk[ ++ top] = r;    while (!isroot(r)) stk[ ++ top] = r = tr[r].p;    while (top) pushdown(stk[top -- ]);    while (!isroot(x))    {        int y = tr[x].p, z = tr[y].p;        if (!isroot(y))            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);            else rotate(y);        rotate(x);    }}void access(int x)  // 建立一条从根到x的路径，同时将x变成splay的根节点{    int z = x;    for (int y = 0; x; y = x, x = tr[x].p)    {        splay(x);        tr[x].s[1] = y, pushup(x);    }    splay(z);}void makeroot(int x)  // 将x变成原树的根节点{    access(x);    pushrev(x);}int findroot(int x)  // 找到x所在原树的根节点, 再将原树的根节点旋转到splay的根节点{    access(x);    while (tr[x].s[0]) pushdown(x), x = tr[x].s[0];    splay(x);    return x;}void split(int x, int y)  // 给x和y之间的路径建立一个splay，其根节点是y{    makeroot(x);    access(y);}void link(int x, int y)  // 如果x和y不连通，则加入一条x和y之间的边{    makeroot(x);    if (findroot(y) != x) tr[x].p = y;}void cut(int x, int y)  // 如果x和y之间存在边，则删除该边{    makeroot(x);    if (findroot(y) == x &amp;&amp; tr[y].p == x &amp;&amp; !tr[y].s[0])    {        tr[x].s[1] = tr[y].p = 0;        pushup(x);    }}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;tr[i].v);    while (m -- )    {        int t, x, y;        scanf(&quot;%d%d%d&quot;, &amp;t, &amp;x, &amp;y);        if (t == 0)        {            split(x, y);            printf(&quot;%d\n&quot;, tr[y].sum);        }        else if (t == 1) link(x, y);        else if (t == 2) cut(x, y);        else        {            splay(x);            tr[x].v = y;            pushup(x);        }    }    return 0;}</code></pre><h4 id="2-19-dancing-links-dlx">2.19 Dancing Links(DLX)</h4><h6 id="2-19-1-精确覆盖问题">2.19.1 精确覆盖问题</h6><pre><code>给定一个01矩阵A，找到一个行的集合，使得这些行中，每一列有且仅有一个数字1</code></pre><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5510;int n, m;int l[N], r[N], u[N], d[N], s[N], row[N], col[N], idx;int ans[N], top;void init(){    for (int i = 0; i &lt;= m; i ++ )    {        l[i] = i - 1, r[i] = i + 1;        u[i] = d[i] = i;    }    l[0] = m, r[m] = 0;    idx = m + 1;}void add(int&amp; hh, int&amp; tt, int x, int y){    row[idx] = x, col[idx] = y, s[y] ++ ;    u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx;    r[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh;    tt = idx ++ ;}void remove(int p){    r[l[p]] = r[p], l[r[p]] = l[p];    for (int i = d[p]; i != p; i = d[i])        for (int j = r[i]; j != i; j = r[j])        {            s[col[j]] -- ;            u[d[j]] = u[j], d[u[j]] = d[j];        }}void resume(int p){    for (int i = u[p]; i != p; i = u[i])        for (int j = l[i]; j != i; j = l[j])        {            u[d[j]] = j, d[u[j]] = j;            s[col[j]] ++ ;        }    r[l[p]] = p, l[r[p]] = p;}bool dfs(){    if (!r[0]) return true;    int p = r[0];    for (int i = r[0]; i; i = r[i])        if (s[i] &lt; s[p])            p = i;    remove(p);    for (int i = d[p]; i != p; i = d[i])    {        ans[ ++ top] = row[i];        for (int j = r[i]; j != i; j = r[j]) remove(col[j]);        if (dfs()) return true;        for (int j = l[i]; j != i; j = l[j]) resume(col[j]);        top -- ;    }    resume(p);    return false;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    init();    for (int i = 1; i &lt;= n; i ++ )    {        int hh = idx, tt = idx;        for (int j = 1; j &lt;= m; j ++ )        {            int x;            scanf(&quot;%d&quot;, &amp;x);            if (x) add(hh, tt, i, j);        }    }    if (dfs())    {        for (int i = 1; i &lt;= top; i ++ ) printf(&quot;%d &quot;, ans[i]);        puts(&quot;&quot;);    }    else puts(&quot;No Solution!&quot;);    return 0;}</code></pre><p>填写16*16的数独</p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 20000;int m = 16 * 16 * 4;int u[N], d[N], l[N], r[N], s[N], col[N], row[N], idx;int ans[N], top;struct Op{    int x, y;    char z;}op[N];char g[20][20];void init(){    for (int i = 0; i &lt;= m; i ++ )    {        l[i] = i - 1, r[i] = i + 1;        s[i] = 0;        d[i] = u[i] = i;    }    l[0] = m, r[m] = 0;    idx = m + 1;}void add(int&amp; hh, int&amp; tt, int x, int y){    row[idx] = x, col[idx] = y, s[y] ++ ;    u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx;    r[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh;    tt = idx ++ ;}void remove(int p){    r[l[p]] = r[p], l[r[p]] = l[p];    for (int i = d[p]; i != p; i = d[i])        for (int j = r[i]; j != i; j = r[j])        {            s[col[j]] -- ;            u[d[j]] = u[j], d[u[j]] = d[j];        }}void resume(int p){    for (int i = u[p]; i != p; i = u[i])        for (int j = l[i]; j != i; j = l[j])        {            u[d[j]] = j, d[u[j]] = j;            s[col[j]] ++ ;        }    r[l[p]] = p, l[r[p]] = p;}bool dfs(){    if (!r[0]) return true;    int p = r[0];    for (int i = r[0]; i; i = r[i])        if (s[i] &lt; s[p])            p = i;    remove(p);    for (int i = d[p]; i != p; i = d[i])    {        ans[ ++ top] = row[i];        for (int j = r[i]; j != i; j = r[j]) remove(col[j]);        if (dfs()) return true;        for (int j = l[i]; j != i; j = l[j]) resume(col[j]);        top -- ;    }    resume(p);    return false;}int main(){    while (~scanf(&quot;%s&quot;, g[0]))    {        for (int i = 1; i &lt; 16; i ++ ) scanf(&quot;%s&quot;, g[i]);        init();        for (int i = 0, n = 1; i &lt; 16; i ++ )            for (int j = 0; j &lt; 16; j ++ )            {                int a = 0, b = 15;                if (g[i][j] != '-') a = b = g[i][j] - 'A';                for (int k = a; k &lt;= b; k ++, n ++ )                {                    int hh = idx, tt = idx;                    op[n] = {i, j, k + 'A'};                    add(hh, tt, n, i * 16 + j + 1);                    add(hh, tt, n, 256 + i * 16 + k + 1);                    add(hh, tt, n, 256 * 2 + j * 16 + k + 1);                    add(hh, tt, n, 256 * 3 + (i / 4 * 4 + j / 4) * 16 + k + 1);                }            }        dfs();        for (int i = 1; i &lt;= top; i ++ )        {            auto t = op[ans[i]];            g[t.x][t.y] = t.z;        }        for (int i = 0; i &lt; 16; i ++ ) puts(g[i]);        puts(&quot;&quot;);    }    return 0;}</code></pre><h6 id="2-19-2-重复覆盖问题">2.19.2 重复覆盖问题</h6><p>给定一个01矩阵A，找到一个行的集合，使得这些行中，每一列都包含数字1，且集合中包含的行数尽可能少。</p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int n, m;int l[N], r[N], u[N], d[N], col[N], row[N], s[N], idx;int ans[N];bool st[110];void init(){    for (int i = 0; i &lt;= m; i ++ )    {        l[i] = i - 1, r[i] = i + 1;        col[i] = u[i] = d[i] = i;        s[i] = 0;    }    l[0] = m, r[m] = 0;    idx = m + 1;}void add(int&amp; hh, int&amp; tt, int x, int y){    row[idx] = x, col[idx] = y, s[y] ++ ;    u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx;    r[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh;    tt = idx ++ ;}int h(){    int cnt = 0;    memset(st, 0, sizeof st);    for (int i = r[0]; i; i = r[i])    {        if (st[col[i]]) continue;        cnt ++ ;        st[col[i]] = true;        for (int j = d[i]; j != i; j = d[j])            for (int k = r[j]; k != j; k = r[k])                st[col[k]] = true;    }    return cnt;}void remove(int p){    for (int i = d[p]; i != p; i = d[i])    {        r[l[i]] = r[i];        l[r[i]] = l[i];    }}void resume(int p){    for (int i = u[p]; i != p; i = u[i])    {        r[l[i]] = i;        l[r[i]] = i;    }}bool dfs(int k, int depth){    if (k + h() &gt; depth) return false;    if (!r[0]) return true;    int p = r[0];    for (int i = r[0]; i; i = r[i])        if (s[p] &gt; s[i])            p = i;    for (int i = d[p]; i != p; i = d[i])    {        ans[k] = row[i];        remove(i);        for (int j = r[i]; j != i; j = r[j]) remove(j);        if (dfs(k + 1, depth)) return true;        for (int j = l[i]; j != i; j = l[j]) resume(j);        resume(i);    }    return false;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    init();    for (int i = 1; i &lt;= n; i ++ )    {        int hh = idx, tt = idx;        for (int j = 1; j &lt;= m; j ++ )        {            int x;            scanf(&quot;%d&quot;, &amp;x);            if (x) add(hh, tt, i, j);        }    }    int depth = 0;    while (!dfs(0, depth)) depth ++ ;    printf(&quot;%d\n&quot;, depth);    for (int i = 0; i &lt; depth; i ++ ) printf(&quot;%d &quot;, ans[i]);    return 0;}</code></pre><h4 id="2-20-左偏树">2.20 左偏树</h4><pre><code class="language-cpp">/*维护一个小根堆，支持以下操作：1. `1 a`，在集合中插入一个新堆，堆中只包含一个数 a。2. `2 x y`，将第 x 个插入的数和第 y 个插入的数所在的小根堆合并。数据保证两个数均未被删除。若两数已在同一堆中，则忽略此操作。3. `3 x`，输出第 x 个插入的数所在小根堆的最小值。数据保证该数未被删除。4. `4 x`，删除第 x 个插入的数所在小根堆的最小值（若最小值不唯一，则优先删除先插入的数）。数据保证该数未被删除。*/#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200010;int n;int v[N], dist[N], l[N], r[N], idx;int p[N];bool cmp(int x, int y){    if (v[x] != v[y]) return v[x] &lt; v[y];    return x &lt; y;}int find(int x){    if (p[x] != x) p[x] = find(p[x]);    return p[x];}int merge(int x, int y){    if (!x || !y) return x + y;    if (cmp(y, x)) swap(x, y);    r[x] = merge(r[x], y);    if (dist[r[x]] &gt; dist[l[x]]) swap(l[x], r[x]);    dist[x] = dist[r[x]] + 1;    return x;}int main(){    scanf(&quot;%d&quot;, &amp;n);    v[0] = 2e9;    while (n -- )    {        int t, x, y;        scanf(&quot;%d%d&quot;, &amp;t, &amp;x);        if (t == 1)        {            v[ ++ idx] = x;            dist[idx] = 1;            p[idx] = idx;        }        else if (t == 2)        {            scanf(&quot;%d&quot;, &amp;y);            x = find(x), y = find(y);            if (x != y)            {                if (cmp(y, x)) swap(x, y);                p[y] = x;                merge(x, y);            }        }        else if (t == 3)        {            printf(&quot;%d\n&quot;, v[find(x)]);        }        else        {            x = find(x);            if (cmp(r[x], l[x])) swap(l[x], r[x]);            p[x] = l[x], p[l[x]] = l[x];            merge(l[x], r[x]);        }    }    return 0;}</code></pre><h6 id="给定一个整数序列a-求一个递增序列b-使得a-i-和b-i-的各项之差的绝对值之和最小">给定一个整数序列a，求一个递增序列b，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的各项之差的绝对值之和最小</h6><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1000010;int n;int v[N], dist[N], l[N], r[N];struct Segment{    int end, root, size;}stk[N];int ans[N];int merge(int x, int y){    if (!x || !y) return x + y;    if (v[x] &lt; v[y]) swap(x, y);    r[x] = merge(r[x], y);    if (dist[r[x]] &gt; dist[l[x]]) swap(r[x], l[x]);    dist[x] = dist[r[x]] + 1;    return x;}int pop(int x){    return merge(l[x], r[x]);}int main(){    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i ++ )    {        scanf(&quot;%d&quot;, &amp;v[i]);        v[i] -= i;    }    int tt = 0;    for (int i = 1; i &lt;= n; i ++ )    {        auto cur = Segment({i, i, 1});        dist[i] = 1;        while (tt &amp;&amp; v[cur.root] &lt; v[stk[tt].root])        {            cur.root = merge(cur.root, stk[tt].root);            if (cur.size % 2 &amp;&amp; stk[tt].size % 2)                cur.root = pop(cur.root);            cur.size += stk[tt].size;            tt -- ;        }        stk[ ++ tt] = cur;    }    for (int i = 1, j = 1; i &lt;= tt; i ++ )    {        while (j &lt;= stk[i].end)            ans[j ++ ] = v[stk[i].root];    }    LL res = 0;    for (int i = 1; i &lt;= n; i ++ ) res += abs(v[i] - ans[i]);    printf(&quot;%lld\n&quot;, res);    for (int i = 1; i &lt;= n; i ++ )        printf(&quot;%d &quot;, ans[i] + i);    return 0;}</code></pre><h4 id="2-21-后缀数组">2.21 后缀数组</h4><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000010;int n, m;char s[N];int sa[N], x[N], y[N], c[N], rk[N], height[N];void get_sa(){    for (int i = 1; i &lt;= n; i ++ ) c[x[i] = s[i]] ++ ;    for (int i = 2; i &lt;= m; i ++ ) c[i] += c[i - 1];    for (int i = n; i; i -- ) sa[c[x[i]] -- ] = i;    for (int k = 1; k &lt;= n; k &lt;&lt;= 1)    {        int num = 0;        for (int i = n - k + 1; i &lt;= n; i ++ ) y[ ++ num] = i;        for (int i = 1; i &lt;= n; i ++ )            if (sa[i] &gt; k)                y[ ++ num] = sa[i] - k;        for (int i = 1; i &lt;= m; i ++ ) c[i] = 0;        for (int i = 1; i &lt;= n; i ++ ) c[x[i]] ++ ;        for (int i = 2; i &lt;= m; i ++ ) c[i] += c[i - 1];        for (int i = n; i; i -- ) sa[c[x[y[i]]] -- ] = y[i], y[i] = 0;        swap(x, y);        x[sa[1]] = 1, num = 1;        for (int i = 2; i &lt;= n; i ++ )            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++ num;        if (num == n) break;        m = num;    }}void get_height(){    for (int i = 1; i &lt;= n; i ++ ) rk[sa[i]] = i;    for (int i = 1, k = 0; i &lt;= n; i ++ )    {        if (rk[i] == 1) continue;        if (k) k -- ;        int j = sa[rk[i] - 1];        while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) k ++ ;        height[rk[i]] = k;    }}int main(){    scanf(&quot;%s&quot;, s + 1);    n = strlen(s + 1), m = 122;    get_sa();    get_height();    for (int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, sa[i]);    puts(&quot;&quot;);    for (int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, height[i]);    puts(&quot;&quot;);    return 0;}</code></pre><h4 id="2-22-后缀自动机">2.22 后缀自动机</h4><h6 id="给定一个长度为n的小写字母字符串s-对于所有s的出现次数不为1的子串-设value的值为子串出现的次数-子串的长度-求value的最大值">给定一个长度为n的小写字母字符串S，对于所有S的出现次数不为1的子串，设value的值为子串出现的次数×子串的长度，求value的最大值</h6><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 2000010;int tot = 1, last = 1;struct Node{    int len, fa;    int ch[26];}node[N];char str[N];LL f[N], ans;int h[N], e[N], ne[N], idx;void extend(int c){    int p = last, np = last = ++ tot;    f[tot] = 1;    node[np].len = node[p].len + 1;    for (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np;    if (!p) node[np].fa = 1;    else    {        int q = node[p].ch[c];        if (node[q].len == node[p].len + 1) node[np].fa = q;        else        {            int nq = ++ tot;            node[nq] = node[q], node[nq].len = node[p].len + 1;            node[q].fa = node[np].fa = nq;            for (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq;        }    }}void add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}void dfs(int u){    for (int i = h[u]; ~i; i = ne[i])    {        dfs(e[i]);        f[u] += f[e[i]];    }    if (f[u] &gt; 1) ans = max(ans, f[u] * node[u].len);}int main(){    scanf(&quot;%s&quot;, str);    for (int i = 0; str[i]; i ++ ) extend(str[i] - 'a');    memset(h, -1, sizeof h);    for (int i = 2; i &lt;= tot; i ++ ) add(node[i].fa, i);    dfs(1);    printf(&quot;%lld\n&quot;, ans);    return 0;}</code></pre><h6 id="后缀自动机求最长公共子串">后缀自动机求最长公共子串</h6><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 20010;int n;int tot = 1, last = 1;char str[N];struct Node{    int len, fa;    int ch[26];}node[N];int ans[N], now[N];int h[N], e[N], ne[N], idx;void extend(int c){    int p = last, np = last = ++ tot;    node[np].len = node[p].len + 1;    for (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np;    if (!p) node[np].fa = 1;    else    {        int q = node[p].ch[c];        if (node[q].len == node[p].len + 1) node[np].fa = q;        else        {            int nq = ++ tot;            node[nq] = node[q], node[nq].len = node[p].len + 1;            node[q].fa = node[np].fa = nq;            for (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq;        }    }}void add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}void dfs(int u){    for (int i = h[u]; ~i; i = ne[i])    {        dfs(e[i]);        now[u] = max(now[u], now[e[i]]);    }}int main(){    scanf(&quot;%d&quot;, &amp;n);    scanf(&quot;%s&quot;, str);    for (int i = 0; str[i]; i ++ ) extend(str[i] - 'a');    for (int i = 1; i &lt;= tot; i ++ ) ans[i] = node[i].len;    memset(h, -1, sizeof h);    for (int i = 2; i &lt;= tot; i ++ ) add(node[i].fa, i);    for (int i = 0; i &lt; n - 1; i ++ )    {        scanf(&quot;%s&quot;, str);        memset(now, 0, sizeof now);        int p = 1, t = 0;        for (int j = 0; str[j]; j ++ )        {            int c = str[j] - 'a';            while (p &gt; 1 &amp;&amp; !node[p].ch[c]) p = node[p].fa, t = node[p].len;            if (node[p].ch[c]) p = node[p].ch[c], t ++ ;            now[p] = max(now[p], t);        }        dfs(1);        for (int j = 1; j &lt;= tot; j ++ ) ans[j] = min(ans[j], now[j]);    }    int res = 0;    for (int i = 1; i &lt;= tot; i ++ ) res = max(res, ans[i]);    printf(&quot;%d\n&quot;, res);    return 0;}</code></pre><h4 id="2-23-点分树">2.23 点分树</h4><pre><code>//待补充</code></pre><h4 id="2-24-cdq分治">2.24 CDQ分治</h4><pre><code>//待补充</code></pre><h6 id="cdq分治求动态逆序对">CDQ分治求动态逆序对</h6><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 100010;int n, m;struct Data{    int a, t, res;}q[N], w[N];int tr[N], pos[N];LL ans[N];int lowbit(int x){    return x &amp; -x;}void add(int x, int v){    for (int i = x; i &lt; N; i += lowbit(i)) tr[i] += v;}int query(int x){    int res = 0;    for (int i = x; i; i -= lowbit(i)) res += tr[i];    return res;}void merge_sort(int l, int r){    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(l, mid), merge_sort(mid + 1, r);    int i = mid, j = r;    while (i &gt;= l &amp;&amp; j &gt; mid)        if (q[i].a &gt; q[j].a) add(q[i].t, 1), i -- ;        else q[j].res += query(q[j].t - 1), j -- ;    while (j &gt; mid) q[j].res += query(q[j].t - 1), j -- ;    for (int k = i + 1; k &lt;= mid; k ++ ) add(q[k].t, -1);    j = l, i = mid + 1;    while (j &lt;= mid &amp;&amp; i &lt;= r)        if (q[i].a &lt; q[j].a) add(q[i].t, 1), i ++ ;        else q[j].res += query(q[j].t - 1), j ++ ;    while (j &lt;= mid) q[j].res += query(q[j].t - 1), j ++ ;    for (int k = mid + 1; k &lt; i; k ++ ) add(q[k].t, -1);    i = l, j = mid + 1;    int k = 0;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i].a &lt;= q[j].a) w[k ++ ] = q[i ++ ];        else w[k ++ ] = q[j ++ ];    while (i &lt;= mid) w[k ++ ] = q[i ++ ];    while (j &lt;= r) w[k ++ ] = q[j ++ ];    for (i = l, j = 0; j &lt; k; i ++, j ++ ) q[i] = w[j];}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 0; i &lt; n; i ++ )    {        scanf(&quot;%d&quot;, &amp;q[i].a);        pos[q[i].a] = i;    }    for (int i = 0, j = n; i &lt; m; i ++ )    {        int a;        scanf(&quot;%d&quot;, &amp;a);        q[pos[a]].t = j -- ;        pos[a] = -1;    }    for (int i = 1, j = n - m; i &lt;= n; i ++ )        if (pos[i] != -1)            q[pos[i]].t = j -- ;    merge_sort(0, n - 1);    for (int i = 0; i &lt; n; i ++ ) ans[q[i].t] = q[i].res;    for (int i = 2; i &lt;= n; i ++ ) ans[i] += ans[i - 1];    for (int i = 0, j = n; i &lt; m; i ++, j -- ) printf(&quot;%lld\n&quot;, ans[j]);    return 0;}</code></pre><h4 id="2-25-笛卡尔树">2.25 笛卡尔树</h4><pre><code class="language-cpp">//求区间最值#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e6 + 10;int a[N];int l[N], r[N];int n;int ans[N], tot;void dfs(int u){ans[u] = ++ tot;if(l[u])dfs(l[u]);if(r[u])dfs(r[u]);}void build(){stack&lt;int&gt; st;int root = 0;for(int i = 1; i &lt;= n; i ++){int last = 0;while(!st.empty() &amp;&amp; a[st.top()] &gt; a[i]){last = st.top();st.pop();}if(!st.empty())r[st.top()] = i;elseroot = i;l[i] = last;st.push(i);}dfs(root);}int main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);cin &gt;&gt; n;for(int i = 1; i &lt;= n; i ++)cin &gt;&gt; a[i];build();for(int i = 1; i &lt;= n; i ++)cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;}</code></pre><h1>3. 数学</h1><h4 id="3-1-分解质因数">3.1 分解质因数</h4><pre><code class="language-cpp">#include&lt;iostream&gt;using  namespace std;void device(int a){    for(int i = 2; i &lt;= a / i; i ++)    {        if(a % i == 0)              //如果该语句成立，那么i一定是质数            int s = 0;            while(a % i == 0)            {                a /= i;                s ++;            }             printf(&quot;%d %d\n&quot;, i, s);        }    }    if(a &gt; 1)   cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt;endl;    cout  &lt;&lt; endl;}int main(){    int n;    cin &gt;&gt; n;    while (n -- )    {        int a;        cin &gt;&gt; a;        device(a);    }    return 0;}</code></pre><h4 id="3-2-筛质数">3.2 筛质数</h4><pre><code class="language-cpp">#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int prime[N],cnt;int st[N];void getprime(int n){    for(int i = 2; i &lt;= n; i ++)    {      if(!st[i])    prime[cnt ++] = i;              //如果i是一个质数，那么就把i加入到质数表里      for(int j = 0; prime[j] &lt;= n / i; j ++)       //枚举质数表中小于n/i的质因子      {          st[prime[j] * i] = true;                  //将所有最小质因子为prime[j]的合数筛掉          if(i % prime[j] == 0) break;              //如果i%prime[j]成立，那么prime[j]是i的最小质因子，并且也是prime[j] * i的最小质因子          //如果不成立，那么prime[j]也是prime[j] * i的最小质因子      }    }}int main(){    int n;    cin &gt;&gt; n;    getprime(n);    cout &lt;&lt; cnt ;    return 0;}</code></pre><h4 id="3-3-试除法求约数">3.3 试除法求约数</h4><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void ddd(int a){    vector&lt;int&gt; res;    for(int i = 1; i &lt;= a / i; i ++)    {        if(a % i == 0)        {            res.push_back(i);            if(i != a / i)  res.push_back(a / i);        }    }    sort(res.begin(), res.end());    for(auto t : res)    cout &lt;&lt; t  &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;}int main(){    int n;    cin &gt;&gt; n;    while(n --)    {        int a;        cin &gt;&gt; a;        ddd(a);    }    return 0;}</code></pre><h4 id="3-4-求n个数乘积的约数个数">3.4 求n个数乘积的约数个数</h4><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;unordered_map&gt;typedef long long LL;using namespace std;const int mod = 1e9 + 7;int main(){    int n;    cin &gt;&gt; n;    unordered_map&lt;int, int&gt; primes;    while(n --)    {        int x;        cin &gt;&gt; x;        for(int i = 2; i &lt;= x / i; i ++)        {            while(x % i == 0)            {                x /= i;                primes[i] ++;            }        }        if(x &gt; 1)   primes[x] ++;    }    LL res = 1;    for(auto prime : primes)        res = res * (prime.second + 1) % mod;    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><h4 id="3-5-求n个数乘积的约数之和">3.5 求n个数乘积的约数之和</h4><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;unordered_map&gt;typedef long long LL;using namespace std;const int mod = 1e9 + 7;int main(){    int n;    cin &gt;&gt; n;    unordered_map&lt;int, int&gt; primes;    while(n --)    {        int x;        cin &gt;&gt; x;        for(int i = 2; i &lt;= x / i; i ++)        {            while(x % i == 0)            {                x /= i;                primes[i] ++;            }        }        if(x &gt; 1)   primes[x] ++;    }    LL res = 1;    for(auto prime : primes)    {        int p = prime.first, a = prime.second;        LL t = 1;        while(a --)            t = (t * p + 1) % mod;        res = res * t % mod;    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><h4 id="3-6-线性筛求欧拉函数">3.6 线性筛求欧拉函数</h4><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1e6 + 10;int primes[N], cnt;int phi[N];bool st[N];LL get_eulers(int n){    phi[1] = 1;    for(int i = 2; i &lt;= n; i ++)    {        if(!st[i])        {            primes[cnt ++] = i;            phi[i] = i - 1;        }        for(int j = 0; primes[j] * i &lt;= n; j ++)        {            st[primes[j] * i] = true;            if(i % primes[j] == 0)            {                phi[primes[j] * i] = primes[j] * phi[i];                break;            }            phi[primes[j] * i] = phi[i] * (primes[j] - 1);        }    }    LL res = 0;    for(int i = 1; i &lt;= n; i ++)        res += phi[i];    return res;}int main(){    int n;    cin &gt;&gt; n;    cout &lt;&lt; get_eulers(n) &lt;&lt; endl;    return 0;}</code></pre><h4 id="3-7-快速幂">3.7 快速幂</h4><pre><code class="language-cpp">int qmi(int a, int b, int p){    int res = 1 % p;    for(; b; b &gt;&gt;= 1)    {        if(b &amp; 1)    res = (long long)res * a % p;        a = (long long)a * a % p;    }    return res;}</code></pre><h4 id="3-8-扩展欧几里得算法-exgcd">3.8 扩展欧几里得算法(EXGCD)</h4><p>给定 n 对正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，对于每对数，求出一组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，使其满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=gcd(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)。</p><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int exgcd(int a, int b, int &amp;x, int &amp;y){    if(!b)    {        x = 1, y = 0;        return a;    }    int d = exgcd(b, a % b, y, x);    y -= a / b * x;    return d;}int main(){    int n;    cin &gt;&gt; n;    while(n --)    {        int a, b, x, y;        cin &gt;&gt; a &gt;&gt; b;        exgcd(a, b, x, y);        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;    }    return 0;}</code></pre><h6 id="求解线性同余方程组">求解线性同余方程组</h6><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;typedef long long LL;using namespace std;int exgcd(int a, int b, int &amp;x, int &amp;y){    if(!b)    {        x = 1, y = 0;        return a;    }    int d = exgcd(b, a % b, y, x);    y -= a / b * x;    return d;}int main(){    int n;    cin &gt;&gt; n;    while(n --)    {        int a, b, m;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; m;        int x, y;        int d = exgcd(a, m, x ,y);        if(b % d)   cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;        else        cout &lt;&lt; (LL)x * (b / d) % m &lt;&lt; endl;    }    return 0;}</code></pre><h4 id="3-9-高斯消元求解线性方程组">3.9 高斯消元求解线性方程组</h4><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 110;const double eps = 1e-6;int n;double a[N][N];int gauss(){    int c, r;    for(c = 0, r = 0; c &lt; n; c ++)    {        int t = r;        for(int i = r; i &lt; n; i ++)            if(fabs(a[i][c] &gt; fabs(a[t][c])))                t = i;        if(fabs(a[t][c]) &lt; eps)   continue;        for(int i = c; i &lt;= n; i ++)            swap(a[t][i], a[r][i]);        for(int i = n; i &gt;= c; i --)            a[r][i] /= a[r][c];        for(int i = r + 1; i &lt; n; i ++)            if(fabs(a[i][c]) &gt; eps)                for(int j = n; j &gt;= c; j --)                    a[i][j] -= a[r][j] * a[i][c];        r ++;    }    if(r &lt; n)    {        for(int i = r; i &lt; n; i ++)            if(fabs(a[i][n]) &gt; eps)                return 2;        return 1;    }    for(int i = n - 1; i &gt;= 0; i --)        for(int j = i + 1; j &lt; n; j ++)            a[i][n] -= a[i][j] * a[j][n];    return 0;}int main(){    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i ++)        for(int j = 0; j &lt; n + 1; j ++)            cin &gt;&gt; a[i][j];    int t = gauss();    if(t == 0)    {        for(int i = 0; i &lt; n; i ++)        {            if (fabs(a[i][n]) &lt; eps) a[i][n] = 0;            printf(&quot;%.2lf\n&quot;, a[i][n]);        }    }    else if(t == 1) cout &lt;&lt; &quot;Infinite group solutions&quot; &lt;&lt; endl;    else puts(&quot;No solution&quot;);    return 0;}</code></pre><h4 id="3-10-组合数大全">3.10 组合数大全</h4><h6 id="3-10-1-求c-a-b-其中1-b-a-2000">3.10.1 求C(a, b)，其中1 ≤ b ≤ a ≤ 2000</h6><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2010, mod = 1e9 + 7;int c[N][N];void init(){    for(int i = 0; i &lt; N; i ++)        for(int j = 0; j &lt;= i; j ++)            if(!j)  c[i][j] = 1;            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;}int main(){    init();    int n;    cin &gt;&gt; n;    while(n --)    {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; c[a][b] &lt;&lt; endl;    }    return 0;}</code></pre><h6 id="3-10-2-求c-a-b-其中1-b-a-100000">3.10.2 求C(a, b)，其中1 ≤ b ≤ a ≤ 100000</h6><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 100010, mod = 1e9 + 7;int fact[N], infact[N];int qmi(int a, int k, int p){    int res = 1;    for(; k; k &gt;&gt;= 1)    {        if(k &amp; 1)   res = (LL)res * a % p;        a = (LL)a * a % p;    }    return res;}int main(){    fact[0] = infact[0] = 1;    for(int i = 1; i &lt; N; i ++)    {        fact[i] = (LL)fact[i - 1] * i % mod;        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;    }    int n;    cin &gt;&gt; n;    while(n --)    {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; (LL)fact[a] * infact[b] % mod * infact[a - b] % mod &lt;&lt; endl;    }}</code></pre><h6 id="3-10-3-求c-a-b-mod-p-其中-1-b-a-10-18-且p为质数">3.10.3 求C(a, b) mod p，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>b</mi><mo>≤</mo><mi>a</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">1 ≤ b ≤ a ≤ 10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>，且p为质数</h6><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;int p;int qmi(int a, int k){    int res = 1;    for(; k; k &gt;&gt;= 1)    {        if(k &amp; 1)   res = (LL)res * a % p;        a = (LL)a * a % p;    }    return res;}int C(LL a, LL b){    int res = 1;    for(int i = 1, j = a; i &lt;= b; i ++, j --)    {        res = (LL)res * j % p;        res = (LL)res * qmi(i ,p - 2) % p;    }    return res;}LL lucas(LL a, LL b){    if(a &lt; p &amp; b &lt; p)   return C(a, b);    return C(a % p, b % p) * lucas(a / p, b / p) % p;}int main(){    int n;    cin &gt;&gt; n;    while(n --)    {        LL a, b;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;        cout &lt;&lt; lucas(a, b) &lt;&lt; endl;    }    return 0;}</code></pre><h6 id="3-10-4-求c-a-b-其中1-b-a-5000-高精度不取模">3.10.4 求C(a, b)，其中1 ≤ b ≤ a ≤ 5000 (高精度不取模)</h6><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int N = 5010;int primes[N], cnt;bool st[N];int sum[N];void init(int n){    for(int i = 2; i &lt;= n; i ++)    {        if(!st[i])  primes[cnt ++] = i;        for(int j = 0; primes[j] * i &lt;= n; j ++)        {            st[primes[j] * i] = true;            if(i % primes[j] == 0)  break;        }    }}int get(int n, int p)  //*n的阶乘里包含的p的个数{    int res = 0;    while(n)    {        res += n / p;        n /= p;    }    return res;}vector&lt;int&gt; mul(vector&lt;int&gt; a, int b){    vector&lt;int&gt; c;    int t = 0;    for(int i = 0; i &lt; a.size(); i ++)    {        t += a[i] * b;        c.push_back(t % 10);        t /= 10;    }    while(t)    {        c.push_back(t % 10);        t /= 10;    }    return c;}int main(){    int a, b;    cin &gt;&gt; a &gt;&gt; b;    init(a);    for(int i = 0; i &lt; cnt; i ++)    {        int p = primes[i];        sum[i] = get(a, p) - get(b, p) - get(a - b, p);    }    vector&lt;int&gt; res;    res.push_back(1);    for(int i = 0; i &lt; cnt; i ++)        for(int j = 0; j &lt; sum[i]; j ++)            res = mul(res, primes[i]);    for(int i = res.size() - 1; i &gt;= 0; i --)        cout &lt;&lt; res[i] ;    cout &lt;&lt; endl;    return 0;}</code></pre><h6 id="3-10-5-卡特兰数">3.10.5 卡特兰数</h6><pre><code>给定01序列，求任意前缀序列中0的个数不少于1的个数的序列有多少个</code></pre><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;typedef long long LL;using namespace std;const int mod = 1e9 + 7;int qmi(int a, int k, int p){    int res = 1;    for(; k; k &gt;&gt;= 1)    {        if(k &amp; 1)   res = (LL)res * a % p;        a=  (LL)a * a % p;    }    return res;}int main(){    int n;    cin &gt;&gt; n;    int a = 2 * n, b = n;    int res = 1;    for(int i = a; i &gt; a - b; i --)        res = (LL)res * i % mod;    for(int i = 1; i &lt;= b; i ++)        res = (LL)res * qmi(i, mod - 2, mod) % mod;    res = (LL)res * qmi(n + 1, mod - 2, mod) % mod;    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><h4 id="3-11-容斥原理">3.11 容斥原理</h4><h6 id="给定n和m个不同的质数p-求1-n中能被p中至少一个数整除的整数有多少个">给定n和m个不同的质数p，求1-n中能被p中至少一个数整除的整数有多少个</h6><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 20;typedef long long LL;int n, m;int p[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 0; i &lt; m; i ++)        cin &gt;&gt; p[i];    int res = 0;    for(int i = 1; i &lt; 1 &lt;&lt; m; i ++)    {        int t = 1, cnt = 0;        for(int j = 0; j &lt; m; j ++)            if(i &gt;&gt; j &amp; 1)            {                cnt ++;                if((LL)t * p[j] &gt; n)                {                    t = -1;                    break;                }                t *= p[j];            }        if(t != -1)        {            if(cnt % 2) res += n / t;            else res -= n / t;        }    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><h6 id="n个盒子放a-i枝花-同一个盒子内的花的颜色相同-不同盒子内的画的颜色不同-选出m枝花共有多少种方案">n个盒子放<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>枝花，同一个盒子内的花的颜色相同，不同盒子内的画的颜色不同，选出M枝花共有多少种方案</h6><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 20, mod = 1e9 + 7;int A[N];int down = 1;int qmi(int a, int b, int k){    int res = 1;    for(; b; b &gt;&gt;= 1)    {        if(b &amp; 1)   res = (long long)res * a % k;        a = (long long)a * a % k;    }    return res;}int C(int a, int b){    if(a &lt; b)   return 0;    int up = 1;    for(int i = a; i &gt; a - b; i --)        up = i % mod * up % mod;    return (up * down) % mod;}signed main(){    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);    int n, m;    int res = 0;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 0; i &lt; n; i ++) cin &gt;&gt; A[i];    for(int j = 1; j &lt;= n - 1; j ++)        down = j * down % mod;    down = qmi(down, mod - 2, mod);    for(int i = 0; i &lt; 1 &lt;&lt; n; i ++)    {        int a = m + n - 1, b = n - 1;        int p = 1;        for(int j = 0; j &lt; n; j ++)            if(i &gt;&gt; j &amp; 1)            {                p *= -1;                a -= A[j] + 1;            }        res = (res + C(a, b) * p) % mod;    }    cout &lt;&lt; (res + mod) % mod &lt;&lt; endl;    return 0;}</code></pre><h4 id="3-12-博弈论">3.12 博弈论</h4><h6 id="3-12-1-nim博弈">3.12.1 NIM博弈</h6><p>给定 n 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。</p><p>问如果两人都采用最优策略，先手是否必胜。</p><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int main(){    int n;    int res = 0;    cin &gt;&gt; n;    while(n --)    {        int x;        cin &gt;&gt; x;        res ^= x;    }    if(res) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;    else    cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;}</code></pre><h6 id="3-12-2-台阶-nim游戏">3.12.2 台阶-NIM游戏</h6><p>有一个 n 级台阶的楼梯，每级台阶上都有若干个石子，其中第 i 级台阶上有 ai 个石子(i≥1)。</p><p>两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。</p><p>已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。</p><p>问如果两人都采用最优策略，先手是否必胜。</p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int main(){    int n;    scanf(&quot;%d&quot;, &amp;n);    int res = 0;    for (int i = 1; i &lt;= n; i ++ )    {        int x;        scanf(&quot;%d&quot;, &amp;x);        if (i &amp; 1) res ^= x;    }    if (res) puts(&quot;Yes&quot;);    else puts(&quot;No&quot;);    return 0;}</code></pre><h6 id="3-12-3-集合-nim游戏">3.12.3 集合-NIM游戏</h6><p>给定 n 堆石子以及一个由 k 个不同正整数构成的数字集合 S。</p><p>现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合 S，最后无法进行操作的人视为失败。</p><p>问如果两人都采用最优策略，先手是否必胜。</p><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;unordered_set&gt;using namespace std;const int N = 110, M = 10010;int n, m;int s[N], f[M];int sg(int x){    if(f[x] != -1)  return f[x];    unordered_set&lt;int&gt; S;    for(int i = 0; i &lt; m; i ++)    {        int sum = s[i];        if(x &gt;= sum)    S.insert(sg(x - sum));    }    for(int i = 0; ; i ++)    {        if(!S.count(i))            return f[x] = i;    }}int main(){    cin &gt;&gt; m;    for(int i = 0; i &lt; m; i ++)        cin &gt;&gt; s[i];    cin &gt;&gt; n;    memset(f, -1, sizeof f);    int res = 0;    for(int i = 0; i &lt; n; i ++)    {        int x;        cin &gt;&gt; x;        res ^= sg(x);    }    if(res) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;    else    cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;    return 0;}</code></pre><h6 id="3-12-4-拆分-nim游戏">3.12.4 拆分-NIM游戏</h6><p>给定 n 堆石子，两位玩家轮流操作，每次操作可以取走其中的一堆石子，然后放入两堆<strong>规模更小</strong>的石子（新堆规模可以为 0，且两个新堆的石子总数可以大于取走的那堆石子数），最后无法进行操作的人视为失败。</p><p>问如果两人都采用最优策略，先手是否必胜。</p><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_set&gt;using namespace std;const int N = 110;int n;int f[N];int sg(int x){    if (f[x] != -1) return f[x];    unordered_set&lt;int&gt; S;    for (int i = 0; i &lt; x; i ++ )        for (int j = 0; j &lt;= i; j ++ )            S.insert(sg(i) ^ sg(j));    for (int i = 0;; i ++ )        if (!S.count(i))            return f[x] = i;}int main(){    cin &gt;&gt; n;    memset(f, -1, sizeof f);    int res = 0;    while (n -- )    {        int x;        cin &gt;&gt; x;        res ^= sg(x);    }    if (res) puts(&quot;Yes&quot;);    else puts(&quot;No&quot;);    return 0;}</code></pre><h4 id="3-13-矩阵乘法">3.13 矩阵乘法</h4><h6 id="求斐波那契数列的前n项和">求斐波那契数列的前n项和</h6><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 3;typedef long long LL;int n, m;void mul(int c[], int a[], int b[][N]){    int temp[N] = {0};    for(int i = 0; i &lt; N; i ++)        for(int j = 0; j &lt; N; j ++)            temp[i] = (temp[i] + (LL)a[j] * b[j][i]) % m;    memcpy(c, temp, sizeof temp);}void mul(int c[][N], int a[][N], int b[][N]){    int temp[N][N] = {0};    for(int i = 0; i &lt; N; i ++)        for(int j = 0; j &lt; N; j ++)            for(int k = 0; k &lt; N; k ++)                temp[i][j] = (temp[i][j] + (LL)a[i][k] * b[k][j]) % m;    memcpy(c, temp, sizeof temp);}int main(){    cin &gt;&gt; n &gt;&gt; m;    int f1[N] = {1, 1, 1};    int a[N][N] = {        {0, 1, 0},        {1, 1, 1},        {0, 0, 1}    };    n --;    for(; n; n &gt;&gt;= 1)    {        if(n &amp; 1)   mul(f1, f1, a);        mul(a, a, a);    }    cout &lt;&lt; f1[2] &lt;&lt; endl;    return 0;}</code></pre><p>用 T(n)=(F1+2F2+3F3+…+nFn)modm 表示 Fibonacci 数列前 n 项变形后的和 mod m 的值，求出 T(n) 的值。</p><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 4;int n, m;void mul(int c[][N], int a[][N], int b[][N])    //*c = a * b{    static int t[N][N];    memset(t, 0, sizeof t);    for(int i = 0; i &lt; N; i ++)        for(int j = 0; j &lt; N; j ++)            for(int k = 0; k &lt; N; k ++)                t[i][j] = (t[i][j] + (LL)a[i][k] * b[k][j]) % m;    memcpy(c, t, sizeof t);}int main(){    cin &gt;&gt; n &gt;&gt; m;    int f1[N][N] = {1, 1, 1, 0};    int a[N][N] = {        {0, 1, 0, 0},        {1, 1, 1, 0},        {0, 0, 1, 1},        {0, 0, 0, 1},    };    int k = n - 1;    for(; k; k &gt;&gt;= 1)    {        if(k &amp; 1)   mul(f1, f1, a);        mul(a, a, a);    }    cout &lt;&lt; (((LL)n * f1[0][2] - f1[0][3]) % m + m) % m &lt;&lt; endl;    return 0;}</code></pre><h4 id="3-14-莫比乌斯函数与莫比乌斯反演与积性函数">3.14 莫比乌斯函数与莫比乌斯反演与积性函数</h4><pre><code class="language-cpp">//待补充</code></pre><h1>4. 动态规划</h1><h2 id="数字三角形模型">数字三角形模型</h2><h3 id="4-1-一条路径点权和最大-摘花生">4.1 一条路径点权和最大(摘花生)</h3><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n, m;int w[N][N];int f[N][N];int main(){    int T;    scanf(&quot;%d&quot;, &amp;T);    while (T -- )    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= m; j ++ )                scanf(&quot;%d&quot;, &amp;w[i][j]);        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= m; j ++ )                f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j];        printf(&quot;%d\n&quot;, f[n][m]);    }    return 0;}</code></pre><h3 id="4-2-一条路径点权和最小">4.2 一条路径点权和最小</h3><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110, INF = 1e9;int n;int w[N][N];int f[N][N];int main(){    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            scanf(&quot;%d&quot;, &amp;w[i][j]);    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == 1 &amp;&amp; j == 1) f[i][j] = w[i][j];    // 特判左上角            else            {                f[i][j] = INF;                if (i &gt; 1) f[i][j] = min(f[i][j], f[i - 1][j] + w[i][j]);// 只有不在第一行的时候，才可以从上面过来                if (j &gt; 1) f[i][j] = min(f[i][j], f[i][j - 1] + w[i][j]);// 只有不在第一列的时候，才可以从左边过来            }    printf(&quot;%d\n&quot;, f[n][n]);    return 0;}</code></pre><h3 id="4-3-两条路径点权和最大">4.3 两条路径点权和最大</h3><p>该类问题满足：左上走到右下走两次，格点数被取过第二次就<strong>不会</strong>再取(坐标和相加相等即被走了两次)</p><pre><code class="language-cpp">// 两条路径都是：左上到右下#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 15;int n;int w[N][N];int f[N * 2][N][N];int main(){    scanf(&quot;%d&quot;, &amp;n);    int a, b, c;    while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c) w[a][b] = c;    for (int k = 2; k &lt;= n + n; k ++ )        for (int i1 = 1; i1 &lt;= n; i1 ++ )            for (int i2 = 1; i2 &lt;= n; i2 ++ )            {                int j1 = k - i1, j2 = k - i2;                if (j1 &gt;= 1 &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= 1 &amp;&amp; j2 &lt;= n)                {                    int t = w[i1][j1];                    if (i1 != i2) t += w[i2][j2];                    int &amp;x = f[k][i1][i2];                    x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);                    x = max(x, f[k - 1][i1 - 1][i2] + t);                    x = max(x, f[k - 1][i1][i2 - 1] + t);                    x = max(x, f[k - 1][i1][i2] + t);                }            }    printf(&quot;%d\n&quot;, f[n + n][n][n]);    return 0;}</code></pre><pre><code class="language-cpp">// 先左上到右下，再右下到左上#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int n, m;int g[55][55], f[110][55][55];int main() {cin &gt;&gt; n &gt;&gt; m;for(int i = 1;i &lt;= n;i ++)for(int j = 1;j &lt;= m;j ++)cin &gt;&gt; g[i][j];for(int k = 2; k &lt;= n + m;k ++) {for(int i1 = max(1, k - m);i1 &lt;= min(k - 1, n);i1 ++) {for(int i2 = max(1, k - m);i2 &lt;= min(k - 1, n);i2 ++) {int j1 = k - i1, j2 = k - i2;int t = g[i1][j1];if(i1 != i2) t += g[i2][j2];int &amp;x = f[k][i1][i2];x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);x = max(x, f[k - 1][i1 - 1][i2] + t);x = max(x, f[k - 1][i1][i2 - 1] + t);x = max(x, f[k - 1][i1][i2] + t);}}  }cout &lt;&lt; f[n + m][n][n] &lt;&lt; endl;return 0;}</code></pre><h2 id="最长上升子序列模型-lis">最长上升子序列模型（LIS）</h2><h3 id="4-4-基本转换模型">4.4 基本转换模型</h3><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int n, q[N], a[N];int ask(int s,int t) {q[0] = -2e9;int len = 0;    for(int i = s;i &lt; t;i ++) {        int l = 0, r = len;        while(l &lt; r) {            int mid = l + r + 1 &gt;&gt; 1;            if(q[mid] &lt; a[i]) l = mid;            else r = mid - 1;        }        len = max(len, r + 1);        q[r + 1] = a[i];    }return len;}int main() {int n;cin &gt;&gt; n;for(int i = 0;i &lt; n;i ++) cin &gt;&gt;  a[i];cout &lt;&lt; ask(0, n) &lt;&lt; endl; // 左闭右开return 0;}</code></pre><h3 id="4-5上下模型">4.5上下模型</h3><p>先上升再下降，一旦下降就不再上升，<strong>中间高两边矮</strong>的最长子序列</p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e3 + 10;int f[N][2], n, a[N];int main () {cin &gt;&gt; n;for(int i = 0;i &lt; n;i ++ ) cin &gt;&gt; a[i];for(int i = 0;i &lt; n;i ++) {f[i][1] = f[i][0] = 1;for(int k = 0;k &lt; i;k ++) {if(a[i] &gt; a[k]) f[i][0] = max(f[i][0], f[k][0] + 1);if(a[i] &lt; a[k]) f[i][1] = max(f[i][1], max(f[k][0], f[k][1]) + 1);}}int res = 0;for(int i = 0;i &lt; n;i ++) res = max(res, max(f[i][1], f[i][0]));cout &lt;&lt; res &lt;&lt; endl;return 0;}</code></pre><h3 id="4-6-最大上升子序列和">4.6 最大上升子序列和</h3><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int a[N], n, f[N];int main () {    cin &gt;&gt; n;    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];    for(int i = 1;i &lt;= n;i ++) {        f[i] = a[i];        for(int k = 1;k &lt; i;k ++) {            if(a[k] &lt; a[i]) f[i] = max(f[i], f[k] + a[i]);        }    }    int res = 0;    for(int i = 1;i &lt;= n;i ++) res = max(res, f[i]);    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><h3 id="4-7-dilworth定理-最少下降子序列数等于最长上升子序列长度">4.7 Dilworth定理（最少下降子序列数等于最长上升子序列长度）</h3><h2 id="最长公共子序列">最长公共子序列</h2><h3 id="4-8-最长公共上升子序列-lics和lcs">4.8 最长公共上升子序列（LICS和LCS）</h3><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 3010;int n, f[N][N], a[N], b[N];int main () {cin &gt;&gt; n;for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; b[i];for(int i = 1;i &lt;= n;i ++) {int res = 0;if(b[1] &lt; a[i]) res = f[i - 1][1];for(int j = 1;j &lt;= n;j ++) {if(a[i] == b[j]) f[i][j] = res + 1;else f[i][j] = f[i - 1][j];if(b[j] &lt; a[i]) res = max(res, f[i - 1][j]);}}int ans = 0;for(int i = 1;i &lt;= n;i ++) ans = max(ans, f[n][i]);cout &lt;&lt; ans &lt;&lt; endl;return 0;}</code></pre><h3 id="4-9-最长公共子序列">4.9 最长公共子序列</h3><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;char a[N], b[N];int f[N][N];int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    scanf(&quot;%s%s&quot;, a + 1, b + 1);    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= m; j ++ ) {            f[i][j] = max(f[i - 1][j], f[i][j - 1]);            if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);        }    printf(&quot;%d\n&quot;, f[n][m]);    return 0;}</code></pre><h2 id="4-10-最短编辑距离">4.10 最短编辑距离</h2><p>A到B最少操作次数</p><p>操作：</p><ol><li>删除–将字符串 A 中的某个字符删除。</li><li>插入–在字符串 A 的某个位置插入某个字符。</li><li>替换–将字符串 A 中的某个字符替换为另一个字符。</li></ol><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int n,m;char a[1010],b[1010];int f[1010][1010];int main(){    scanf(&quot;%d%s&quot;,&amp;n, a + 1);    scanf(&quot;%d%s&quot;,&amp;m, b + 1);    for(int i = 0;i &lt;= m;i ++) f[0][i] = i;    for(int i = 0;i &lt;= n;i ++) f[i][0] = i;    for(int i = 1;i &lt;= n;i ++)    {        for(int j = 1;j &lt;= m;j ++)        {            f[i][j] = min(f[i][j - 1], f[i - 1][j]) + 1;            if(a[i] != b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1);            else f[i][j] = min(f[i][j], f[i - 1][j - 1]);        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><h2 id="背包">背包</h2><h3 id="4-11-01背包问题">4.11 01背包问题</h3><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int M = 20010;int n, m;int f[M];int main(){    cin &gt;&gt; m &gt;&gt; n;    for (int i = 0; i &lt; n; i ++ )    {        int v;        cin &gt;&gt; v;        for (int j = m; j &gt;= v; j -- )            f[j] = max(f[j], f[j - v] + v);    }    cout &lt;&lt; m - f[m] &lt;&lt; endl;    return 0;}</code></pre><h4 id="01背包求方案数">01背包求方案数</h4><pre><code class="language-cpp">//数字组合方案，非最优最大价值方案数#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int n, m;int f[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    f[0] = 1;    for (int i = 0; i &lt; n; i ++ )    {        int v;        cin &gt;&gt; v;        for (int j = m; j &gt;= v; j -- )            f[j] += f[j - v];    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h3 id="4-12-完全背包问题">4.12 完全背包问题</h3><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];    for (int i = 1; i &lt;= n; i ++ )        for (int j = v[i]; j &lt;= m; j ++ )            f[j] = max(f[j], f[j - v[i]] + w[i]);    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h4 id="完全背包求方案数">完全背包求方案数</h4><pre><code class="language-cpp">//数字组合方案，非最优最大价值方案数#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long LL;const LL mod=2147483648LL;//默认数字为int类型，因此数字后要加LLint n;long long f[4005];int main() {    scanf(&quot;%d&quot;,&amp;n);    f[0]=1;    for(int i = 1;i &lt; n;i ++)        for(int j = i;j &lt;= n;j ++)            f[j] = (f[j] + f[j - i]) % mod;    printf(&quot;%d&quot;,f[n]);}</code></pre><h3 id="4-13-多重背包问题">4.13 多重背包问题</h3><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 1e5+10;int n, m;struct node {int v, w;};vector&lt;node&gt; nodes;int f[N];int main() {cin &gt;&gt; n &gt;&gt; m;for(int i = 1;i &lt;= n;i ++) {int v, w ,s;cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;for(int k = 1;k &lt;= s;k &lt;&lt;= 1) nodes.push_back({v*k, w*k}), s -= k;if(s) nodes.push_back({v*s, w*s});}for(auto t : nodes) {for(int j = m;j &gt;= t.v;j -- ) {f[j] = max(f[j], f[j - t.v] + t.w);}}cout &lt;&lt; f[m] &lt;&lt; endl;return 0;}</code></pre><p><strong>单调队列优化</strong></p><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int f[N], g[N], q[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i ++ )    {        int v, w, s;        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;        memcpy(g, f, sizeof f);        for (int j = 0; j &lt; v; j ++ )        {            int hh = 0, tt = -1;            for (int k = j; k &lt;= m; k += v)            {                if (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh ++ ;                while (hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt -- ;                q[ ++ tt] = k;                f[k] = g[q[hh]] + (k - q[hh]) / v * w;            }        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h3 id="4-14-混合背包问题">4.14 混合背包问题</h3><pre><code class="language-cpp">#include &lt;iostream&gt;using namespace std;const int N = 1010;int n, m;int f[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i ++ )    {        int v, w, s;        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;        if (!s)        {            for (int j = v; j &lt;= m; j ++ )                f[j] = max(f[j], f[j - v] + w);        }        else        {            if (s == -1) s = 1;            for (int k = 1; k &lt;= s; k *= 2)            {                for (int j = m; j &gt;= k * v; j -- )                    f[j] = max(f[j], f[j - k * v] + k * w);                s -= k;            }            if (s)            {                for (int j = m; j &gt;= s * v; j -- )                    f[j] = max(f[j], f[j - s * v] + s * w);            }        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h3 id="4-15-二维费用的背包问题">4.15 二维费用的背包问题</h3><pre><code class="language-cpp">#include &lt;iostream&gt;using namespace std;const int N = 110;int n, V, M;int f[N][N];int main(){    cin &gt;&gt; n &gt;&gt; V &gt;&gt; M;    for (int i = 0; i &lt; n; i ++ )    {        int v, m, w;        cin &gt;&gt; v &gt;&gt; m &gt;&gt; w;        for (int j = V; j &gt;= v; j -- )            for (int k = M; k &gt;= m; k -- )                f[j][k] = max(f[j][k], f[j - v][k - m] + w);    }    cout &lt;&lt; f[V][M] &lt;&lt; endl;    return 0;}</code></pre><h3 id="4-16-分组背包问题">4.16 分组背包问题</h3><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n, m;int v[N][N], w[N][N], s[N];int f[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i ++ )    {        cin &gt;&gt; s[i];        for (int j = 0; j &lt; s[i]; j ++ )            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];    }    for (int i = 1; i &lt;= n; i ++ )        for (int j = m; j &gt;= 0; j -- )            for (int k = 0; k &lt; s[i]; k ++ )                if (v[i][k] &lt;= j)                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h3 id="4-17-有依赖的背包问题">4.17 有依赖的背包问题</h3><p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n, m;int v[N], w[N];int h[N], e[N], ne[N], idx;int f[N][N];void add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}void dfs(int u){    for (int i = h[u]; ~i; i = ne[i])   // 循环物品组    {        int son = e[i];        dfs(e[i]);        // 分组背包        for (int j = m - v[u]; j &gt;= 0; j -- )  // 循环体积            for (int k = 0; k &lt;= j; k ++ )  // 循环决策                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);    }    // 将物品u加进去    for (int i = m; i &gt;= v[u]; i -- ) f[u][i] = f[u][i - v[u]] + w[u];    for (int i = 0; i &lt; v[u]; i ++ ) f[u][i] = 0;}int main(){    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);    int root;    for (int i = 1; i &lt;= n; i ++ )    {        int p;        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p;        if (p == -1) root = i;        else add(p, i);    }    dfs(root);    cout &lt;&lt; f[root][m] &lt;&lt; endl;    return 0;}/*5 72 3 -12 2 13 5 14 7 23 6 211*/</code></pre><h3 id="4-18-最优最大价值方案数">4.18 最优最大价值方案数</h3><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1010, mod = 1e9 + 7;int n, m;int f[N], g[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    memset(f, -0x3f, sizeof f);    f[0] = 0;    g[0] = 1;    for (int i = 0; i &lt; n; i ++ )    {        int v, w;        cin &gt;&gt; v &gt;&gt; w;        for (int j = m; j &gt;= v; j -- )        {            int maxv = max(f[j], f[j - v] + w);            int s = 0;            if (f[j] == maxv) s = g[j];            if (f[j - v] + w == maxv) s = (s + g[j - v]) % mod;            f[j] = maxv, g[j] = s;        }    }        int res = 0;    for (int i = 1; i &lt;= m; i ++ )        if (f[i] &gt; f[res])            res = i;        int sum = 0;    for (int i = 0; i &lt;= m; i ++ )        if (f[i] == f[res])            sum = (sum + g[i]) % mod;    cout &lt;&lt; sum &lt;&lt; endl;    return 0;}</code></pre><h3 id="4-19-背包问题求具体方案">4.19 背包问题求具体方案</h3><pre><code class="language-cpp">#include &lt;iostream&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N][N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];    for (int i = n; i &gt;= 1; i -- )        for (int j = 0; j &lt;= m; j ++ )        {            f[i][j] = f[i + 1][j];            if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);        }    int j = m;    for (int i = 1; i &lt;= n; i ++ )        if (j &gt;= v[i] &amp;&amp; f[i][j] == f[i + 1][j - v[i]] + w[i])        {            cout &lt;&lt; i &lt;&lt; ' ';            j -= v[i];        }    return 0;}</code></pre><h2 id="状态机模型">状态机模型</h2><p><strong>大盗阿福</strong></p><p>阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？</p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n;int w[N], f[N][2];int main(){    int T;    scanf(&quot;%d&quot;, &amp;T);    while (T -- )    {        scanf(&quot;%d&quot;, &amp;n);        for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);        for (int i = 1; i &lt;= n; i ++ )        {            f[i][0] = max(f[i - 1][0], f[i - 1][1]);            f[i][1] = f[i - 1][0] + w[i];        }        printf(&quot;%d\n&quot;, max(f[n][0], f[n][1]));    }    return 0;}/*231 8 2410 7 6 14824*/</code></pre><p><strong>股票买卖 IV</strong></p><p>给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i天的价格。设计一个算法来计算你所能获取的最大利润，你最多可以完成 k笔交易。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。一次买入卖出合为一笔交易。</p><pre><code class="language-cpp">// 输出一个整数，表示最大利润。#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010, M = 110, INF = 0x3f3f3f3f;int n, m;int w[N];int f[N][M][2];int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);    memset(f, -0x3f, sizeof f);    for (int i = 0; i &lt;= n; i ++ ) f[i][0][0] = 0;    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= m; j ++ )        {            f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + w[i]);            f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - w[i]);        }    int res = 0;    for (int i = 0; i &lt;= m; i ++ ) res = max(res, f[n][i][0]);    printf(&quot;%d\n&quot;, res);    return 0;}</code></pre><p><strong>股票买卖 V</strong><br>给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><pre><code class="language-cpp">// 算出最大利润#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010, INF = 0x3f3f3f3f;int n;int w[N];int f[N][3];int main(){    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);    f[0][0] = f[0][1] = -INF, f[0][2] = 0;    for (int i = 1; i &lt;= n; i ++ )    {        f[i][0] = max(f[i - 1][0], f[i - 1][2] - w[i]);        f[i][1] = f[i - 1][0] + w[i];        f[i][2] = max(f[i - 1][2], f[i - 1][1]);    }    printf(&quot;%d\n&quot;, max(f[n][1], f[n][2]));    return 0;}</code></pre><p><strong>设计密码</strong><br>你现在需要设计一个密码 S，S需要满足：</p><ul><li>S 的长度是 N；</li><li>S 只包含小写英文字母；</li><li>S 不包含子串 T；<br>例如：abc 和 abcde 是 abcde 的子串，abd 不是 abcde的子串。<br>请问共有多少种不同的密码满足要求？ 由于答案会非常大，请输出答案模 109+7的余数。</li></ul><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 55, mod = 1e9 + 7;int n, m;char str[N];int nxt[N];int f[N][N];int main(){    cin &gt;&gt; n &gt;&gt; str + 1;    m = strlen(str + 1);    for (int i = 2, j = 0; i &lt;= m; i ++ )    {        while (j &amp;&amp; str[i] != str[j + 1]) j = nxt[j];        if (str[i] == str[j + 1]) j ++ ;        nxt[i] = j;    }    f[0][0] = 1;    for (int i = 0; i &lt; n; i ++ )        for (int j = 0; j &lt; m; j ++ )            for (char k = 'a'; k &lt;= 'z'; k ++ )            {                int u = j;                while (u &amp;&amp; k != str[u + 1]) u = nxt[u];                if (k == str[u + 1]) u ++ ;                if (u &lt; m) f[i + 1][u] = (f[i + 1][u] + f[i][j]) % mod;            }    int res = 0;    for (int i = 0; i &lt; m; i ++ ) res = (res + f[n][i]) % mod;    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre><p><strong>修复DNA</strong></p><p>生物学家终于发明了修复DNA的技术，能够将包含各种遗传疾病的DNA片段进行修复。为了简单起见，DNA看作是一个由’A’, ‘G’ , ‘C’ , ‘T’构成的字符串。修复技术就是通过改变字符串中的一些字符，从而消除字符串中包含的致病片段。需注意，被修复的DNA片段中，仍然只能包含字符’A’, ‘G’ , ‘C’ , ‘T’。</p><p>请你帮助生物学家修复给定的DNA片段，并且修复过程中改变的字符数量要尽可能的少。</p><pre><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int tr[N][4], dar[N], idx;int q[N], ne[N];char str[N];int f[N][N];int get(char c){    if (c == 'A') return 0;    if (c == 'T') return 1;    if (c == 'G') return 2;    return 3;}void insert(){    int p = 0;    for (int i = 0; str[i]; i ++ )    {        int t = get(str[i]);        if (tr[p][t] == 0) tr[p][t] = ++ idx;        p = tr[p][t];    }    dar[p] = 1;}void build(){    int hh = 0, tt = -1;    for (int i = 0; i &lt; 4; i ++ )        if (tr[0][i])            q[ ++ tt] = tr[0][i];    while (hh &lt;= tt)    {        int t = q[hh ++ ];        for (int i = 0; i &lt; 4; i ++ )        {            int p = tr[t][i];            if (!p) tr[t][i] = tr[ne[t]][i];            else            {                ne[p] = tr[ne[t]][i];                q[ ++ tt] = p;                dar[p] |= dar[ne[p]];            }        }    }}int main(){    int T = 1;    while (scanf(&quot;%d&quot;, &amp;n), n)    {        memset(tr, 0, sizeof tr);        memset(dar, 0, sizeof dar);        memset(ne, 0, sizeof ne);        idx = 0;        for (int i = 0; i &lt; n; i ++ )        {            scanf(&quot;%s&quot;, str);            insert();        }        build();        scanf(&quot;%s&quot;, str + 1);        m = strlen(str + 1);        memset(f, 0x3f, sizeof f);        f[0][0] = 0;        for (int i = 0; i &lt; m; i ++ )            for (int j = 0; j &lt;= idx; j ++ )                for (int k = 0; k &lt; 4; k ++ )                {                    int t = get(str[i + 1]) != k;                    int p = tr[j][k];                    if (!dar[p]) f[i + 1][p] = min(f[i + 1][p], f[i][j] + t);                }        int res = 0x3f3f3f3f;        for (int i = 0; i &lt;= idx; i ++ ) res = min(res, f[m][i]);        if (res == 0x3f3f3f3f) res = -1;        printf(&quot;Case %d: %d\n&quot;, T ++, res);    }    return 0;}/*2AAAAAGAAAG    2ATGTGAATG4AGCTAGT0Case 1: 1Case 2: 4Case 3: -1*/</code></pre><h2 id="状态压缩dp">状态压缩DP</h2><p><strong>小国王</strong></p><pre><code class="language-cpp">// 在 n×n 的棋盘上放 k 个国王，国王可攻击相邻的 8 个格子，求使它们无法互相攻击的方案总数。#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int N = 12, M = 1 &lt;&lt; 10, K = 110;int n, m;vector&lt;int&gt; state;int cnt[M];vector&lt;int&gt; head[M];LL f[N][K][M];bool check(int state){    for (int i = 0; i &lt; n; i ++ )        if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; i + 1 &amp; 1))            return false;    return true;}int count(int state){    int res = 0;    for (int i = 0; i &lt; n; i ++ ) res += state &gt;&gt; i &amp; 1;    return res;}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )        if (check(i))        {            state.push_back(i);            cnt[i] = count(i);        }    for (int i = 0; i &lt; state.size(); i ++ )        for (int j = 0; j &lt; state.size(); j ++ )        {            int a = state[i], b = state[j];            if ((a &amp; b) == 0 &amp;&amp; check(a | b))                head[i].push_back(j);        }    f[0][0][0] = 1;    for (int i = 1; i &lt;= n + 1; i ++ )        for (int j = 0; j &lt;= m; j ++ )            for (int a = 0; a &lt; state.size(); a ++ )                for (int b : head[a])                {                    int c = cnt[state[a]];                    if (j &gt;= c)                        f[i][j][a] += f[i - 1][j - c][b];                }    cout &lt;&lt; f[n + 1][m][0] &lt;&lt; endl;    return 0;}/*3 216*/</code></pre><p><strong>玉米田</strong></p><p>农夫约翰的土地由 M×N 个小方格组成，现在他要在土地里种植玉米。非常遗憾，部分土地是不育的，无法种植。<br>而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。<br>现在给定土地的大小，请你求出共有多少种种植方法。土地上什么都不种也算一种方法。</p><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 14, M = 1 &lt;&lt; 12, mod = 1e8;int n, m;int w[N];vector&lt;int&gt; state;vector&lt;int&gt; head[M];int f[N][M];bool check(int state){    for (int i = 0; i + 1 &lt; m; i ++ )        if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; i + 1 &amp; 1))            return false;    return true;}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i ++ )        for (int j = 0; j &lt; m; j ++ )        {            int t;            cin &gt;&gt; t;            w[i] += !t * (1 &lt;&lt; j);        }    for (int i = 0; i &lt; 1 &lt;&lt; m; i ++ )        if (check(i))            state.push_back(i);    for (int i = 0; i &lt; state.size(); i ++ )        for (int j = 0; j &lt; state.size(); j ++ )        {            int a = state[i], b = state[j];            if (!(a &amp; b))                head[i].push_back(j);        }    f[0][0] = 1;    for (int i = 1; i &lt;= n + 1; i ++ )        for (int j = 0; j &lt; state.size(); j ++ )            if (!(state[j] &amp; w[i]))                for (int k : head[j])                    f[i][j] = (f[i][j] + f[i - 1][k]) % mod;    cout &lt;&lt; f[n + 1][0] &lt;&lt; endl;    return 0;}/*2 31 1 10 1 09*/</code></pre><h2 id="区间dp">区间DP</h2><p><strong>环形石子合并</strong></p><p>求：</p><ul><li>选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。</li><li>选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。</li></ul><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 410, INF = 0x3f3f3f3f;int n;int w[N], s[N];int f[N][N], g[N][N];int main(){    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ )    {        cin &gt;&gt; w[i];        w[i + n] = w[i];    }    for (int i = 1; i &lt;= n * 2; i ++ ) s[i] = s[i - 1] + w[i];    memset(f, 0x3f, sizeof f);    memset(g, -0x3f, sizeof g);    for (int len = 1; len &lt;= n; len ++ )        for (int l = 1; l + len - 1 &lt;= n * 2; l ++ )        {            int r = l + len - 1;            if (l == r) f[l][r] = g[l][r] = 0;            else            {                for (int k = l; k &lt; r; k ++ )                {                    f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);                    g[l][r] = max(g[l][r], g[l][k] + g[k + 1][r] + s[r] - s[l - 1]);                }            }        }    int minv = INF, maxv = -INF;    for (int i = 1; i &lt;= n; i ++ )    {        minv = min(minv, f[i][i + n - 1]);        maxv = max(maxv, g[i][i + n - 1]);    }    cout &lt;&lt; minv &lt;&lt; endl &lt;&lt; maxv &lt;&lt; endl;    return 0;}</code></pre><p><strong>加分二叉树</strong><br>设一个 n 个节点的二叉树 tree 的中序遍历为（1,2,3,…,n），其中数字 1,2,3,…,n 为节点编号。<br>每个节点都有一个分数（均为正整数），记第 i 个节点的分数为 di，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下：     <br>subtree的左子树的加分 × subtree的右子树的加分 ＋ subtree的根的分数 <br>若某个子树为空，规定其加分为 1。<br>叶子的加分就是叶节点本身的分数，不考虑它的空子树。<br>试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树 tree。</p><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 30;int n;int w[N];int f[N][N], g[N][N];void dfs(int l, int r){    if (l &gt; r) return;    int k = g[l][r];    cout &lt;&lt; k &lt;&lt; ' ';    dfs(l, k - 1);    dfs(k + 1, r);}int main(){    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; w[i];    for (int len = 1; len &lt;= n; len ++ )        for (int l = 1; l + len - 1 &lt;= n; l ++ )        {            int r = l + len - 1;            if (len == 1) f[l][r] = w[l], g[l][r] = l;            else            {                for (int k = l; k &lt;= r; k ++ )                {                    int left = k == l ? 1 : f[l][k - 1];                    int right = k == r ? 1 : f[k + 1][r];                    int score = left * right + w[k];                    if (f[l][r] &lt; score)                    {                        f[l][r] = score;                        g[l][r] = k;                    }                }            }        }    cout &lt;&lt; f[1][n] &lt;&lt; endl;    dfs(1, n);    return 0;}</code></pre><p><strong>凸多边形的划分</strong></p><p>给定一个具有 N 个顶点的凸多边形，将顶点从 1 至 N 标号，每个顶点的权值都是一个正整数。<br>将这个凸多边形划分成 N−2 个互不相交的三角形，对于每个三角形，其三个顶点的权值相乘都可得到一个权值乘积，试求所有三角形的顶点权值乘积之和至少为多少。</p><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 55, M = 35, INF = 1e9;int n;int w[N];LL f[N][N][M];void add(LL a[], LL b[]){    static LL c[M];    memset(c, 0, sizeof c);    for (int i = 0, t = 0; i &lt; M; i ++ )    {        t += a[i] + b[i];        c[i] = t % 10;        t /= 10;    }    memcpy(a, c, sizeof c);}void mul(LL a[], LL b){    static LL c[M];    memset(c, 0, sizeof c);    LL t = 0;    for (int i = 0; i &lt; M; i ++ )    {        t += a[i] * b;        c[i] = t % 10;        t /= 10;    }    memcpy(a, c, sizeof c);}int cmp(LL a[], LL b[]){    for (int i = M - 1; i &gt;= 0; i -- )        if (a[i] &gt; b[i]) return 1;        else if (a[i] &lt; b[i]) return -1;    return 0;}void print(LL a[]){    int k = M - 1;    while (k &amp;&amp; !a[k]) k -- ;    while (k &gt;= 0) cout &lt;&lt; a[k -- ];    cout &lt;&lt; endl;}int main(){    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; w[i];    LL temp[M];    for (int len = 3; len &lt;= n; len ++ )        for (int l = 1; l + len - 1 &lt;= n; l ++ )        {            int r = l + len - 1;            f[l][r][M - 1] = 1;            for (int k = l + 1; k &lt; r; k ++ )            {                memset(temp, 0, sizeof temp);                temp[0] = w[l];                mul(temp, w[k]);                mul(temp, w[r]);                add(temp, f[l][k]);                add(temp, f[k][r]);                if (cmp(f[l][r], temp) &gt; 0)                    memcpy(f[l][r], temp, sizeof temp);            }        }    print(f[1][n]);    return 0;}</code></pre><h2 id="数位dp">数位DP</h2><p><strong>数字游戏</strong><br>科协里最近很流行数字游戏。<br>某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。<br>现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。</p><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 15;int f[N][N];    // f[i, j]表示一共有i位，且最高位填j的数的个数void init(){    for (int i = 0; i &lt;= 9; i ++ ) f[1][i] = 1;    for (int i = 2; i &lt; N; i ++ )        for (int j = 0; j &lt;= 9; j ++ )            for (int k = j; k &lt;= 9; k ++ )                f[i][j] += f[i - 1][k];}int dp(int n){    if (!n) return 1;    vector&lt;int&gt; nums;    while (n) nums.push_back(n % 10), n /= 10;    int res = 0;    int last = 0;    for (int i = nums.size() - 1; i &gt;= 0; i -- )    {        int x = nums[i];        for (int j = last; j &lt; x; j ++ )            res += f[i + 1][j];        if (x &lt; last) break;        last = x;        if (!i) res ++ ;    }    return res;}int main(){    init();    int l, r;    while (cin &gt;&gt; l &gt;&gt; r) cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl;    return 0;}/*1 91 19918*/</code></pre><p><strong>数字游戏 II</strong><br>由于科协里最近真的很流行数字游戏。<br>某人又命名了一种取模数，这种数字必须满足各位数字之和 mod N 为 0。<br>现在大家又要玩游戏了，指定一个整数闭区间 [a.b]，问这个区间内有多少个取模数。</p><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 11, M = 110;int P;int f[N][10][M];int mod(int x, int y){    return (x % y + y) % y;}void init(){    memset(f, 0, sizeof f);    for (int i = 0; i &lt;= 9; i ++ ) f[1][i][i % P] ++ ;    for (int i = 2; i &lt; N; i ++ )        for (int j = 0; j &lt;= 9; j ++ )            for (int k = 0; k &lt; P; k ++ )                for (int x = 0; x &lt;= 9; x ++ )                    f[i][j][k] += f[i - 1][x][mod(k - j, P)];}int dp(int n){    if (!n) return 1;    vector&lt;int&gt; nums;    while (n) nums.push_back(n % 10), n /= 10;    int res = 0;    int last = 0;    for (int i = nums.size() - 1; i &gt;= 0; i -- )    {        int x = nums[i];        for (int j = 0; j &lt; x; j ++ )            res += f[i + 1][j][mod(-last, P)];        last += x;        if (!i &amp;&amp; last % P == 0) res ++ ;    }    return res;}int main(){    int l, r;    while (cin &gt;&gt; l &gt;&gt; r &gt;&gt; P)    {        init();        cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl;    }    return 0;}/*1 19 92*/</code></pre><p><strong>不要62</strong><br>不吉利的数字为所有含有 4 或 62 的号码。例如：62315,73418,88914 都属于不吉利号码。但是，61152 虽然含有 6 和 2，但不是 连号，所以不属于不吉利数字之列。<br>你的任务是，对于每次给出的一个牌照号区间 [n,m]，推断出交管局今后又要实际上给多少辆新的士车上牌照了。</p><pre><code class="language-cpp">/*每组数据包含一个整数对 n 和 m。当输入一行为“0 0”时，表示输入结束。*/#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 35;int f[N][10];void init(){    for (int i = 0; i &lt;= 9; i ++ )        if (i != 4)            f[1][i] = 1;    for (int i = 1; i &lt; N; i ++ )        for (int j = 0; j &lt;= 9; j ++ )        {            if (j == 4) continue;            for (int k = 0; k &lt;= 9; k ++ )            {                if (k == 4 || j == 6 &amp;&amp; k == 2) continue;                f[i][j] += f[i - 1][k];            }        }}int dp(int n){    if (!n) return 1;    vector&lt;int&gt; nums;    while (n) nums.push_back(n % 10), n /= 10;    int res = 0;    int last = 0;    for (int i = nums.size() - 1; i &gt;= 0; i -- )    {        int x = nums[i];        for (int j = 0; j &lt; x; j ++ )        {            if (j == 4 || last == 6 &amp;&amp; j == 2) continue;            res += f[i + 1][j];        }        if (x == 4 || last == 6 &amp;&amp; x == 2) break;        last = x;        if (!i) res ++ ;    }    return res;}int main(){    init();    int l, r;    while (cin &gt;&gt; l &gt;&gt; r, l || r)    {        cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl;    }    return 0;}/*1 1000 080*/</code></pre><h2 id="斜率优化dp">斜率优化DP</h2><p><strong>任务安排3</strong><br>有 N 个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。<br>机器会把这 N 个任务分成若干批，每一批包含连续的若干个任务。<br>从时刻 0 开始，任务被分批加工，执行第 i 个任务所需的时间是 Ti。<br>另外，在每批任务开始前，机器需要 S 的启动时间，故执行一批任务所需的时间是启动时间 S 加上每个任务所需时间之和。<br>一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。<br>也就是说，同一批任务将在同一时刻完成。<br>每个任务的费用是它的完成时刻乘以一个费用系数 Ci。<br>请为机器规划一个分组方案，使得总费用最小。</p><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 300010;int n, s;LL t[N], c[N];LL f[N];int q[N];int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;s);    for (int i = 1; i &lt;= n; i ++ )    {        scanf(&quot;%lld%lld&quot;, &amp;t[i], &amp;c[i]);        t[i] += t[i - 1];        c[i] += c[i - 1];    }    int hh = 0, tt = 0;    q[0] = 0;    for (int i = 1; i &lt;= n; i ++ )    {        int l = hh, r = tt;        while (l &lt; r)        {            int mid = l + r &gt;&gt; 1;            if (f[q[mid + 1]] - f[q[mid]] &gt; (t[i] + s) * (c[q[mid + 1]] - c[q[mid]])) r = mid;            else l = mid + 1;        }        int j = q[r];        f[i] = f[j] -   (t[i] + s) * c[j] + t[i] * c[i] + s * c[n];        while (hh &lt; tt &amp;&amp; (double)(f[q[tt]] - f[q[tt - 1]]) * (c[i] - c[q[tt - 1]]) &gt;= (double)(f[i] - f[q[tt - 1]]) * (c[q[tt]] - c[q[tt - 1]])) tt -- ;        q[ ++ tt] = i;    }    printf(&quot;%lld\n&quot;, f[n]);    return 0;}/*5 11 33 24 32 31 4153*/</code></pre><h1>5. 搜索</h1><h2 id="5-1-bfs求连通块-flood-fill">5.1 BFS求连通块(FLood Fill)</h2><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1010, M = N * N;int n, m;char g[N][N];PII q[M];bool st[N][N];void bfs(int sx, int sy){    int hh = 0, tt = 0;    q[0] = {sx, sy};    st[sx][sy] = true;    while (hh &lt;= tt)    {        PII t = q[hh ++ ];        for (int i = t.x - 1; i &lt;= t.x + 1; i ++ )            for (int j = t.y - 1; j &lt;= t.y + 1; j ++ )            {                if (i == t.x &amp;&amp; j == t.y) continue;                if (i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= m) continue;                if (g[i][j] == '.' || st[i][j]) continue;                q[ ++ tt] = {i, j};                st[i][j] = true;            }    }}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%s&quot;, g[i]);    int cnt = 0;    for (int i = 0; i &lt; n; i ++ )        for (int j = 0; j &lt; m; j ++ )            if (g[i][j] == 'W' &amp;&amp; !st[i][j])            {                bfs(i, j);                cnt ++ ;            }    printf(&quot;%d\n&quot;, cnt);    return 0;}</code></pre><h2 id="5-2-矩阵最短路模型">5.2 矩阵最短路模型</h2><p>经典迷宫问题，左上到右下找到一条最短路径(并输出)</p><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1010, M = N * N;int n;int g[N][N];PII q[M];PII pre[N][N];void bfs(int sx, int sy){    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};    int hh = 0, tt = 0;    q[0] = {sx, sy};    memset(pre, -1, sizeof pre);    pre[sx][sy] = {0, 0};    while (hh &lt;= tt)    {        PII t = q[hh ++ ];        for (int i = 0; i &lt; 4; i ++ )        {            int a = t.x + dx[i], b = t.y + dy[i];            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n) continue;            if (g[a][b]) continue;            if (pre[a][b].x != -1) continue;            q[ ++ tt] = {a, b};            pre[a][b] = t;        }    }}int main(){    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i ++ )        for (int j = 0; j &lt; n; j ++ )            scanf(&quot;%d&quot;, &amp;g[i][j]);    bfs(n - 1, n - 1);    PII end(0, 0);    while (true)    {        printf(&quot;%d %d\n&quot;, end.x, end.y);        if (end.x == n - 1 &amp;&amp; end.y == n - 1) break;        end = pre[end.x][end.y];    }    return 0;}</code></pre><p><strong>象棋马走日，象走田最短路径等</strong>只需要稍微修改一下dx，dy数组</p><h2 id="5-3-双向bfs">5.3 双向BFS</h2><p><strong>字符串变换</strong></p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;using namespace std;const int N = 6;int n;string A, B;string a[N], b[N];int extend(queue&lt;string&gt;&amp; q, unordered_map&lt;string, int&gt;&amp;da, unordered_map&lt;string, int&gt;&amp; db,     string a[N], string b[N]){    int d = da[q.front()];    while (q.size() &amp;&amp; da[q.front()] == d)    {        auto t = q.front();        q.pop();        for (int i = 0; i &lt; n; i ++ )            for (int j = 0; j &lt; t.size(); j ++ )                if (t.substr(j, a[i].size()) == a[i])                {                    string r = t.substr(0, j) + b[i] + t.substr(j + a[i].size());                    if (db.count(r)) return da[t] + db[r] + 1;                    if (da.count(r)) continue;                    da[r] = da[t] + 1;                    q.push(r);                }    }    return 11;}int bfs(){    if (A == B) return 0;    queue&lt;string&gt; qa, qb;    unordered_map&lt;string, int&gt; da, db;    qa.push(A), qb.push(B);    da[A] = db[B] = 0;    int step = 0;    while (qa.size() &amp;&amp; qb.size())    {        int t;        if (qa.size() &lt; qb.size()) t = extend(qa, da, db, a, b);        else t = extend(qb, db, da, b, a);        if (t &lt;= 10) return t;        if ( ++ step == 10) return -1;    }    return -1;}int main(){    cin &gt;&gt; A &gt;&gt; B;    while (cin &gt;&gt; a[n] &gt;&gt; b[n]) n ++ ;    int t = bfs();    if (t == -1) puts(&quot;NO ANSWER!&quot;);    else cout &lt;&lt; t &lt;&lt; endl;    return 0;}</code></pre><h2 id="5-4-双端队列广搜">5.4 双端队列广搜</h2><p>边权只有01的图适用</p><pre><code class="language-cpp">// 电路维修/*联通的边权为0，不连通的边权为0*/#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 510, M = N * N;int n, m;char g[N][N];int dist[N][N];bool st[N][N];int bfs(){    memset(dist, 0x3f, sizeof dist);    memset(st, 0, sizeof st);    dist[0][0] = 0;    deque&lt;PII&gt; q;    q.push_back({0, 0});    char cs[] = &quot;\\/\\/&quot;;    int dx[4] = {-1, -1, 1, 1}, dy[4] = {-1, 1, 1, -1};    int ix[4] = {-1, -1, 0, 0}, iy[4] = {-1, 0, 0, -1};    while (q.size())    {        PII t = q.front();        q.pop_front();        if (st[t.x][t.y]) continue;        st[t.x][t.y] = true;        for (int i = 0; i &lt; 4; i ++ )        {            int a = t.x + dx[i], b = t.y + dy[i];            if (a &lt; 0 || a &gt; n || b &lt; 0 || b &gt; m) continue;            int ca = t.x + ix[i], cb = t.y + iy[i];            int d = dist[t.x][t.y] + (g[ca][cb] != cs[i]);            if (d &lt; dist[a][b])            {                dist[a][b] = d;                if (g[ca][cb] != cs[i]) q.push_back({a, b}); // 如果边权为1则放到队尾                else q.push_front({a, b}); // 如果边权为0则放到对头            }        }    }    return dist[n][m];}int main(){    int T;    scanf(&quot;%d&quot;, &amp;T);    while (T -- )    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%s&quot;, g[i]);        int t = bfs();        if (t == 0x3f3f3f3f) puts(&quot;NO SOLUTION&quot;);        else printf(&quot;%d\n&quot;, t);    }    return 0;}</code></pre><h2 id="5-5-a">5.5 A*</h2><h3 id="第k短路">第K短路</h3><pre><code class="language-cpp">// 给定一张 N 个点（编号 1,2…N），M 条边的有向图，求从起点 S 到终点 T 的第 K 短路的长度，路径允许重复经过点或边。#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;typedef pair&lt;int, PII&gt; PIII;const int N = 1010, M = 200010;int n, m, S, T, K;int h[N], rh[N], e[M], w[M], ne[M], idx;int dist[N], cnt[N];bool st[N];void add(int h[], int a, int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;}void dijkstra(){    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push({0, T});    memset(dist, 0x3f, sizeof dist);    dist[T] = 0;    while (heap.size())    {        auto t = heap.top();        heap.pop();        int ver = t.y;        if (st[ver]) continue;        st[ver] = true;        for (int i = rh[ver]; ~i; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[ver] + w[i])            {                dist[j] = dist[ver] + w[i];                heap.push({dist[j], j});            }        }    }}int astar(){    priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt;&gt; heap;    heap.push({dist[S], {0, S}});    while (heap.size())    {        auto t = heap.top();        heap.pop();        int ver = t.y.y, distance = t.y.x;        cnt[ver] ++ ;        if (cnt[T] == K) return distance;        for (int i = h[ver]; ~i; i = ne[i])        {            int j = e[i];            if (cnt[j] &lt; K)                heap.push({distance + w[i] + dist[j], {distance + w[i], j}});        }    }    return -1;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    memset(h, -1, sizeof h);    memset(rh, -1, sizeof rh);    for (int i = 0; i &lt; m; i ++ )    {        int a, b, c;        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        add(h, a, b, c);        add(rh, b, a, c);    }    scanf(&quot;%d%d%d&quot;, &amp;S, &amp;T, &amp;K);    if (S == T) K ++ ;    dijkstra();    printf(&quot;%d\n&quot;, astar());    return 0;}</code></pre><h2 id="5-6-双向dfs">5.6 双向DFS</h2><p>达达帮翰翰给女生送礼物，翰翰一共准备了 N 个礼物，其中第 i 个礼物的重量是 G[i]。<br>达达的力气很大，他一次可以搬动重量之和不超过 W 的任意多个物品。<br>达达希望一次搬掉尽量重的一些物品，请你告诉达达在他的力气范围内一次性能搬动的最大重量是多少。</p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int N = 1 &lt;&lt; 24;int n, m, k;int g[50], weights[N];int cnt = 0;int ans;void dfs(int u, int s){    if (u == k)    {        weights[cnt ++ ] = s;        return;    }    if ((LL)s + g[u] &lt;= m) dfs(u + 1, s + g[u]);    dfs(u + 1, s);}void dfs2(int u, int s){    if (u == n)    {        int l = 0, r = cnt - 1;        while (l &lt; r)        {            int mid = l + r + 1 &gt;&gt; 1;            if (weights[mid] + (LL)s &lt;= m) l = mid;            else r = mid - 1;        }        if (weights[l] + (LL)s &lt;= m) ans = max(ans, weights[l] + s);        return;    }    if ((LL)s + g[u] &lt;= m) dfs2(u + 1, s + g[u]);    dfs2(u + 1, s);}int main(){    cin &gt;&gt; m &gt;&gt; n;    for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; g[i];    sort(g, g + n);    reverse(g, g + n);    k = n / 2;  // 防止 n = 1时，出现死循环    dfs(0, 0);    sort(weights, weights + cnt);    int t = 1;    for (int i = 1; i &lt; cnt; i ++ )        if (weights[i] != weights[i - 1])            weights[t ++ ] = weights[i];    cnt = t;    dfs2(k, 0);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}/*20 575418119*/</code></pre><h2 id="5-7-ida">5.7 IDA*</h2><h3 id="排书">排书</h3><p>给定 n 本书，编号为 1∼n。<br>在初始状态下，书是任意排列的。<br>在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。<br>我们的目标状态是把书按照 1∼n 的顺序依次排列。<br>求最少需要多少次操作。</p><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 15;int n;int q[N];int w[5][N];int f(){    int cnt = 0;    for (int i = 0; i + 1 &lt; n; i ++ )        if (q[i + 1] != q[i] + 1)            cnt ++ ;    return (cnt + 2) / 3;}bool check(){    for (int i = 0; i + 1 &lt; n; i ++ )        if (q[i + 1] != q[i] + 1)            return false;    return true;}bool dfs(int depth, int max_depth){    if (depth + f() &gt; max_depth) return false;    if (check()) return true;    for (int len = 1; len &lt;= n; len ++ )        for (int l = 0; l + len - 1 &lt; n; l ++ )        {            int r = l + len - 1;            for (int k = r + 1; k &lt; n; k ++ )            {                memcpy(w[depth], q, sizeof q);                int x, y;                for (x = r + 1, y = l; x &lt;= k; x ++, y ++ ) q[y] = w[depth][x];                for (x = l; x &lt;= r; x ++, y ++ ) q[y] = w[depth][x];                if (dfs(depth + 1, max_depth)) return true;                memcpy(q, w[depth], sizeof q);            }        }    return false;}int main(){    int T;    cin &gt;&gt; T;    while (T -- )    {        cin &gt;&gt; n;        for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; q[i];        int depth = 0;        while (depth &lt; 5 &amp;&amp; !dfs(0, depth)) depth ++ ;        if (depth &gt;= 5) puts(&quot;5 or more&quot;);        else cout &lt;&lt; depth &lt;&lt; endl;    }    return 0;}</code></pre><h1>6. 图论</h1><h2 id="6-1-存边">6.1 存边</h2><ul><li><p>邻接矩阵</p></li><li><p>邻接表</p></li></ul><pre><code class="language-cpp">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点int h[N], e[N], ne[N], idx;// 添加一条边a-&gt;bvoid add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}// 初始化idx = 0;memset(h, -1, sizeof h);</code></pre><h2 id="6-2-树与图的遍历">6.2 树与图的遍历</h2><p>时间复杂度 O(n+m)，n 表示点数，m 表示边数</p><ul><li><strong>深度优先遍历</strong></li></ul><pre><code class="language-cpp">int dfs(int u){    st[u] = true; // st[u] 表示点u已经被遍历过    for (int i = h[u]; i != -1; i = ne[i])    {        int j = e[i];        if (!st[j]) dfs(j);    }}</code></pre><ul><li><strong>宽度优先遍历</strong></li></ul><pre><code class="language-cpp">queue&lt;int&gt; q;st[1] = true; // 表示1号点已经被遍历过q.push(1);while (q.size()){    int t = q.front();    q.pop();    for (int i = h[t]; i != -1; i = ne[i])    {        int j = e[i];        if (!st[j])        {            st[j] = true; // 表示点j已经被遍历过            q.push(j);        }    }}</code></pre><h2 id="6-3-拓扑排序">6.3 拓扑排序</h2><p>时间复杂度 O(n+m)，n 表示点数，m 表示边数</p><pre><code class="language-cpp">bool topsort(){    int hh = 0, tt = -1;    // d[i] 存储点i的入度    for (int i = 1; i &lt;= n; i ++ )        if (!d[i])            q[ ++ tt] = i;    while (hh &lt;= tt)    {        int t = q[hh ++ ];        for (int i = h[t]; i != -1; i = ne[i])        {            int j = e[i];            if (-- d[j] == 0)                q[ ++ tt] = j;        }    }    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。    return tt == n - 1;}</code></pre><h2 id="6-4-图论最短路模型-dj-spfa">6.4 图论最短路模型(DJ, SPFA…)</h2><h3 id="堆优化的dijkstra">堆优化的Dijkstra</h3><p><strong>时间复杂度 O(mlogn), n 表示点数，m 表示边数</strong></p><pre><code class="language-cpp">typedef pair&lt;int, int&gt; PII;int n;      // 点的数量int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        // 存储所有点到1号点的距离bool st[N];     // 存储每个点的最短距离是否已确定// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push({0, 1});      // first存储距离，second存储节点编号    while (heap.size())    {        auto t = heap.top();        heap.pop();        int ver = t.second, distance = t.first;        if (st[ver]) continue;        st[ver] = true;        for (int i = h[ver]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; distance + w[i])            {                dist[j] = distance + w[i];                heap.push({dist[j], j});            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}</code></pre><h3 id="bellman-ford算法">Bellman-Ford算法</h3><p><strong>时间复杂度 O(nm), n 表示点数，m 表示边数</strong></p><pre><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e4 + 10;struct Edge{    int a, b, w;}edge[N];int n, m, k;int dist[N], backup[N];void bellman_ford(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for(int i = 1;i &lt;= k;i ++)    {        memcpy(backup, dist, sizeof dist);        for(int j = 0;j &lt;= m;j ++)        {            int a = edge[j].a,b = edge[j].b,w = edge[j].w;            dist[b] = min(dist[b], backup[a] + w);        }    }    if(dist[n] &gt; 0x3f3f3f3f / 2)    printf(&quot;impossible\n&quot;);    else    printf(&quot;%d\n&quot;, dist[n]);}int main(){    scanf(&quot;%d%d%d&quot;,&amp;n, &amp;m, &amp;k);    for(int i = 1;i &lt;= m;i ++)    {        Edge &amp;x = edge[i];        scanf(&quot;%d%d%d&quot;,&amp;x.a, &amp;x.b, &amp;x.w);    }    bellman_ford();    return 0;}</code></pre><h3 id="spfa算法">SPFA算法</h3><p><strong>时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数, m 表示边数</strong></p><pre><code class="language-cpp">int n;      // 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        // 存储每个点到1号点的最短距离bool st[N];     // 存储每个点是否在队列中// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    queue&lt;int&gt; q;    q.push(1);    st[1] = true;    while (q.size())    {        auto t = q.front();        q.pop();        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            {                dist[j] = dist[t] + w[i];                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入                {                    q.push(j);                    st[j] = true;                }            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}</code></pre><h3 id="spfa判断图中是否存在负环">spfa判断图中是否存在负环</h3><p><strong>时间复杂度是 O(nm), n 表示点数，m 表示边数</strong></p><pre><code class="language-cpp">int n;      // 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数bool st[N];     // 存储每个点是否在队列中// 如果存在负环，则返回true，否则返回false。bool spfa(){    // 不需要初始化dist数组    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。    queue&lt;int&gt; q;    for (int i = 1; i &lt;= n; i ++ )    {        q.push(i);        st[i] = true;    }    while (q.size())    {        auto t = q.front();        q.pop();        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            {                dist[j] = dist[t] + w[i];                cnt[j] = cnt[t] + 1;                if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环                if (!st[j])                {                    q.push(j);                    st[j] = true;                }            }        }    }    return false;}</code></pre><h3 id="floyd算法">floyd算法</h3><p><strong>时间复杂度是 O(n3), n 表示点数</strong></p><pre><code class="language-cpp">初始化：    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}</code></pre><h2 id="6-5-最小生成树">6.5 最小生成树</h2><h3 id="朴素版prim算法">朴素版prim算法</h3><p><strong>时间复杂度是 O(n^2+m), n 表示点数，m 表示边数</strong></p><pre><code class="language-cpp">int n;      // n表示点数int g[N][N];        // 邻接矩阵，存储所有边int dist[N];        // 存储其他点到当前最小生成树的距离bool st[N];     // 存储每个点是否已经在生成树中// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和int prim(){    memset(dist, 0x3f, sizeof dist);    int res = 0;    for (int i = 0; i &lt; n; i ++ )    {        int t = -1;        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        if (i &amp;&amp; dist[t] == INF) return INF;        if (i) res += dist[t];        st[t] = true;        for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);    }    return res;}</code></pre><h3 id="kruskal算法">Kruskal算法</h3><p><strong>时间复杂度是 O(mlogm), n 表示点数，m 表示边数</strong></p><pre><code class="language-cpp">int n, m;       // n是点数，m是边数int p[N];       // 并查集的父节点数组struct Edge     // 存储边{    int a, b, w;    bool operator&lt; (const Edge &amp;W)const    {        return w &lt; W.w;    }}edges[M];int find(int x)     // 并查集核心操作{    if (p[x] != x) p[x] = find(p[x]);    return p[x];}int kruskal(){    sort(edges, edges + m);    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集    int res = 0, cnt = 0;    for (int i = 0; i &lt; m; i ++ )    {        int a = edges[i].a, b = edges[i].b, w = edges[i].w;        a = find(a), b = find(b);        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并        {            p[a] = b;            res += w;            cnt ++ ;        }    }    if (cnt &lt; n - 1) return INF;    return res;}</code></pre><h2 id="6-6-染色法判别二分图">6.6 染色法判别二分图</h2><p><strong>时间复杂度是 O(n+m), n 表示点数，m 表示边数</strong></p><pre><code class="language-cpp">int n;      // n表示点数int h[N], e[M], ne[M], idx;     // 邻接表存储图int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色// 参数：u表示当前节点，c表示当前点的颜色bool dfs(int u, int c){    color[u] = c;    for (int i = h[u]; i != -1; i = ne[i])    {        int j = e[i];        if (color[j] == -1)        {            if (!dfs(j, !c)) return false;        }        else if (color[j] == c) return false;    }    return true;}bool check(){    memset(color, -1, sizeof color);    bool flag = true;    for (int i = 1; i &lt;= n; i ++ )        if (color[i] == -1)            if (!dfs(i, 0))            {                flag = false;                break;            }    return flag;}</code></pre><h2 id="6-7-二分图的最大匹配-匈牙利算法">6.7 二分图的最大匹配（匈牙利算法）</h2><p><strong>时间复杂度是 O(nm), n 表示点数，m 表示边数</strong></p><pre><code class="language-cpp">int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过bool find(int x){    for (int i = h[x]; i != -1; i = ne[i])    {        int j = e[i];        if (!st[j])        {            st[j] = true;            if (match[j] == 0 || find(match[j]))            {                match[j] = x;                return true;            }        }    }    return false;}// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点int res = 0;for (int i = 1; i &lt;= n1; i ++ ){    memset(st, false, sizeof st);    if (find(i)) res ++ ;}</code></pre><h2 id="6-8-树的直径">6.8 树的直径</h2><p>树上最长的路径</p><ul><li><strong>树形DP求树的直径</strong></li></ul><pre><code class="language-cpp">void dp(int x) {    st[x] = 1;    for(int i = h[x]; i != -1; i = ne[i]) {        int j = e[i];        if(st[j]) continue;        dp(j);        ans = max(ans, d[x] + d[j] + w[i]);        d[x] = max(d[x], d[j] + w[i]);    }}</code></pre><ul><li><strong>两次BFS求出树的直径（边权非负）</strong><br>（1）从任意一个节点出发，跑一遍BFS，找到最远的p<br>（2）再从p出发，跑一遍BFS，找到距离p最远的q<br>p, q即为两个端点。</li></ul><h2 id="6-9-欧拉回路与欧拉路径">6.9  欧拉回路与欧拉路径</h2><p>存在欧拉回路与欧拉路径的充要条件：</p><ul><li><p>无向图</p><ul><li>存在<strong>欧拉路径</strong>的充要条件 : 度数为奇数的点只能有0或2个</li><li>存在<strong>欧拉回路</strong>的充要条件 : 度数为奇数的点只能有0个</li></ul></li><li><p>有向图</p><ul><li><p>存在<strong>欧拉路径</strong>的充要条件 :</p><ul><li><p>要么所有点的出度均==入度；</p></li><li><p>要么除了两个点之外，其余所有点的出度==入度 剩余的两个点:一个满足<strong>出度-入度==1</strong>(起点) 一个满足<strong>入度-出度</strong>==1(终点)</p></li></ul></li><li><p>存在<strong>欧拉回路</strong>的充要条件 : 所有点的出度均等于入度</p></li></ul></li></ul><h2 id="6-10-最近公共祖先-lca">6.10 最近公共祖先（LCA）</h2><h3 id="祖孙询问"><strong>祖孙询问</strong></h3><pre><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 40010, M = N * 2;int n, m;int h[N], e[M], ne[M], idx;int depth[N], fa[N][16];int q[N];void add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}void bfs(int root){    memset(depth, 0x3f, sizeof depth);    depth[0] = 0, depth[root] = 1;    int hh = 0, tt = 0;    q[0] = root;    while (hh &lt;= tt)    {        int t = q[hh ++ ];        for (int i = h[t]; ~i; i = ne[i])        {            int j = e[i];            if (depth[j] &gt; depth[t] + 1)            {                depth[j] = depth[t] + 1;                q[ ++ tt] = j;                fa[j][0] = t;                for (int k = 1; k &lt;= 15; k ++ )                    fa[j][k] = fa[fa[j][k - 1]][k - 1];            }        }    }}int lca(int a, int b){    if (depth[a] &lt; depth[b]) swap(a, b);    for (int k = 15; k &gt;= 0; k -- )        if (depth[fa[a][k]] &gt;= depth[b])            a = fa[a][k];    if (a == b) return a;    for (int k = 15; k &gt;= 0; k -- )        if (fa[a][k] != fa[b][k])        {            a = fa[a][k];            b = fa[b][k];        }    return fa[a][0];}int main(){    scanf(&quot;%d&quot;, &amp;n);    int root = 0;    memset(h, -1, sizeof h);    for (int i = 0; i &lt; n; i ++ )    {        int a, b;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        if (b == -1) root = a;        else add(a, b), add(b, a);    }    bfs(root);    scanf(&quot;%d&quot;, &amp;m);    while (m -- )    {        int a, b;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        int p = lca(a, b);        if (p == a) puts(&quot;1&quot;);        else if (p == b) puts(&quot;2&quot;);        else puts(&quot;0&quot;);    }    return 0;}</code></pre><h3 id="次小生成树">次小生成树</h3><pre><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 100010, M = 300010, INF = 0x3f3f3f3f;int n, m;struct Edge{    int a, b, w;    bool used;    bool operator&lt; (const Edge &amp;t) const    {        return w &lt; t.w;    }}edge[M];int p[N];int h[N], e[M], w[M], ne[M], idx;int depth[N], fa[N][17], d1[N][17], d2[N][17];int q[N];void add(int a, int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;}int find(int x){    if (p[x] != x) p[x] = find(p[x]);    return p[x];}LL kruskal(){    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    sort(edge, edge + m);    LL res = 0;    for (int i = 0; i &lt; m; i ++ )    {        int a = find(edge[i].a), b = find(edge[i].b), w = edge[i].w;        if (a != b)        {            p[a] = b;            res += w;            edge[i].used = true;        }    }    return res;}void build(){    memset(h, -1, sizeof h);    for (int i = 0; i &lt; m; i ++ )        if (edge[i].used)        {            int a = edge[i].a, b = edge[i].b, w = edge[i].w;            add(a, b, w), add(b, a, w);        }}void bfs(){    memset(depth, 0x3f, sizeof depth);    depth[0] = 0, depth[1] = 1;    q[0] = 1;    int hh = 0, tt = 0;    while (hh &lt;= tt)    {        int t = q[hh ++ ];        for (int i = h[t]; ~i; i = ne[i])        {            int j = e[i];            if (depth[j] &gt; depth[t] + 1)            {                depth[j] = depth[t] + 1;                q[ ++ tt] = j;                fa[j][0] = t;                d1[j][0] = w[i], d2[j][0] = -INF;                for (int k = 1; k &lt;= 16; k ++ )                {                    int anc = fa[j][k - 1];                    fa[j][k] = fa[anc][k - 1];                    int distance[4] = {d1[j][k - 1], d2[j][k - 1], d1[anc][k - 1], d2[anc][k - 1]};                    d1[j][k] = d2[j][k] = -INF;                    for (int u = 0; u &lt; 4; u ++ )                    {                        int d = distance[u];                        if (d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d;                        else if (d != d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d;                    }                }            }        }    }}int lca(int a, int b, int w){    static int distance[N * 2];    int cnt = 0;    if (depth[a] &lt; depth[b]) swap(a, b);    for (int k = 16; k &gt;= 0; k -- )        if (depth[fa[a][k]] &gt;= depth[b])        {            distance[cnt ++ ] = d1[a][k];            distance[cnt ++ ] = d2[a][k];            a = fa[a][k];        }    if (a != b)    {        for (int k = 16; k &gt;= 0; k -- )            if (fa[a][k] != fa[b][k])            {                distance[cnt ++ ] = d1[a][k];                distance[cnt ++ ] = d2[a][k];                distance[cnt ++ ] = d1[b][k];                distance[cnt ++ ] = d2[b][k];                a = fa[a][k], b = fa[b][k];            }        distance[cnt ++ ] = d1[a][0];        distance[cnt ++ ] = d1[b][0];    }    int dist1 = -INF, dist2 = -INF;    for (int i = 0; i &lt; cnt; i ++ )    {        int d = distance[i];        if (d &gt; dist1) dist2 = dist1, dist1 = d;        else if (d != dist1 &amp;&amp; d &gt; dist2) dist2 = d;    }    if (w &gt; dist1) return w - dist1;    if (w &gt; dist2) return w - dist2;    return INF;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 0; i &lt; m; i ++ )    {        int a, b, c;        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        edge[i] = {a, b, c};    }    LL sum = kruskal();    build();    bfs();    LL res = 1e18;    for (int i = 0; i &lt; m; i ++ )        if (!edge[i].used)        {            int a = edge[i].a, b = edge[i].b, w = edge[i].w;            res = min(res, sum + lca(a, b, w));        }    printf(&quot;%lld\n&quot;, res);    return 0;}</code></pre><h2 id="6-11-树上两点距离">6.11 树上两点距离</h2><pre><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 10010, M = N * 2;int n, m;int h[N], e[M], w[M], ne[M], idx;int dist[N];int p[N];int res[M];int st[N];vector&lt;PII&gt; query[N];   // first存查询的另外一个点，second存查询编号void add(int a, int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;}void dfs(int u, int fa){    for (int i = h[u]; ~i; i = ne[i])    {        int j = e[i];        if (j == fa) continue;        dist[j] = dist[u] + w[i];        dfs(j, u);    }}int find(int x){    if (p[x] != x) p[x] = find(p[x]);    return p[x];}void tarjan(int u){    st[u] = 1;    for (int i = h[u]; ~i; i = ne[i])    {        int j = e[i];        if (!st[j])        {            tarjan(j);            p[j] = u;        }    }    for (auto item : query[u])    {        int y = item.first, id = item.second;        if (st[y] == 2)        {            int anc = find(y);            res[id] = dist[u] + dist[y] - dist[anc] * 2;        }    }    st[u] = 2;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    memset(h, -1, sizeof h);    for (int i = 0; i &lt; n - 1; i ++ )    {        int a, b, c;        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        add(a, b, c), add(b, a, c);    }    for (int i = 0; i &lt; m; i ++ )    {        int a, b;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        if (a != b)        {            query[a].push_back({b, i});            query[b].push_back({a, i});        }    }    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    dfs(1, -1);    tarjan(1);    for (int i = 0; i &lt; m; i ++ ) printf(&quot;%d\n&quot;, res[i]);    return 0;}</code></pre><h2 id="6-12-有向图的强联通分量">6.12 有向图的强联通分量</h2><pre><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010, M = 50010;int n, m;int h[N], e[M], ne[M], idx;int dfn[N], low[N], timestamp;int stk[N], top;bool in_stk[N];int id[N], scc_cnt, Size[N];int dout[N];void add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}void tarjan(int u){    dfn[u] = low[u] = ++ timestamp;    stk[ ++ top] = u, in_stk[u] = true;    for (int i = h[u]; i != -1; i = ne[i])    {        int j = e[i];        if (!dfn[j])        {            tarjan(j);            low[u] = min(low[u], low[j]);        }        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);    }    if (dfn[u] == low[u])    {        ++ scc_cnt;        int y;        do {            y = stk[top -- ];            in_stk[y] = false;            id[y] = scc_cnt;            Size[scc_cnt] ++ ;        } while (y != u);    }}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    memset(h, -1, sizeof h);    while (m -- )    {        int a, b;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        add(a, b);    }    for (int i = 1; i &lt;= n; i ++ )        if (!dfn[i])            tarjan(i);    for (int i = 1; i &lt;= n; i ++ )        for (int j = h[i]; ~j; j = ne[j])        {            int k = e[j];            int a = id[i], b = id[k];            if (a != b) dout[a] ++ ;        }    int zeros = 0, sum = 0;    for (int i = 1; i &lt;= scc_cnt; i ++ )        if (!dout[i])        {            zeros ++ ;            sum += Size[i];            if (zeros &gt; 1)            {                sum = 0;                break;            }        }    printf(&quot;%d\n&quot;, sum);    return 0;}</code></pre><h2 id="6-13-无向图的双联通分量">6.13 无向图的双联通分量</h2><p><strong>冗余路径</strong></p><p>为了从 FF 个草场中的一个走到另一个，奶牛们有时不得不路过一些她们讨厌的可怕的树。</p><p>奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择。</p><p>每对草场之间已经有至少一条路径。</p><p>给出所有 RR 条双向路的描述，每条路连接了两个不同的草场，请计算最少的新建道路的数量，路径由若干道路首尾相连而成。</p><p>两条路径相互分离，是指两条路径没有一条重合的道路。</p><p>但是，两条分离的路径上可以有一些相同的草场。</p><p>对于同一对草场之间，可能已经有两条不同的道路，你也可以在它们之间再建一条道路，作为另一条不同的道路。</p><pre><code class="language-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5010, M = 20010;int n, m;int h[N], e[M], ne[M], idx;int dfn[N], low[N], timestamp;int stk[N], top;int id[N], dcc_cnt;bool is_bridge[M];int d[N];void add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}void tarjan(int u, int from){    dfn[u] = low[u] = ++ timestamp;    stk[ ++ top] = u;    for (int i = h[u]; ~i; i = ne[i])    {        int j = e[i];        if (!dfn[j])        {            tarjan(j, i);            low[u] = min(low[u], low[j]);            if (dfn[u] &lt; low[j])                is_bridge[i] = is_bridge[i ^ 1] = true;        }        else if (i != (from ^ 1))            low[u] = min(low[u], dfn[j]);    }    if (dfn[u] == low[u])    {        ++ dcc_cnt;        int y;        do {            y = stk[top -- ];            id[y] = dcc_cnt;        } while (y != u);    }}int main(){    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);    while (m -- )    {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        add(a, b), add(b, a);    }    tarjan(1, -1);    for (int i = 0; i &lt; idx; i ++ )        if (is_bridge[i])            d[id[e[i]]] ++ ;    int cnt = 0;    for (int i = 1; i &lt;= dcc_cnt; i ++ )        if (d[i] == 1)            cnt ++ ;    printf(&quot;%d\n&quot;, (cnt + 1) / 2);    return 0;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2022/10/18/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2022/10/18/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1>线段树</h1><h2 id="1-单点修改-区间查询线段树">1.单点修改，区间查询线段树</h2><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;struct info{int minv, cnt_min;};struct Node{info val;}tr[N * 4];int n, q;int a[N];info operator + (const info &amp;l, const info &amp;r){info a;a.minv = min(l.minv, r.minv);if(l.minv == r.minv)a.cnt_min = l.cnt_min + r.cnt_min;else if(l.minv &lt; r.minv)a.cnt_min = l.cnt_min;else a.cnt_min = r.cnt_min;return a;}void pushup(int u){tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val;}void build(int u, int l, int r){if(l == r)tr[u].val = {a[l], 1};else{int mid = l + r &gt;&gt; 1;build(u &lt;&lt; 1, l, mid);build(u &lt;&lt; 1 | 1, mid + 1, r);pushup(u);}}void change(int u, int l, int r, int pos, int val){if(l == r)tr[u].val = {val, 1};else{int mid = l + r &gt;&gt; 1;if(pos &lt;= mid)change(u &lt;&lt; 1, l, mid, pos, val);elsechange(u &lt;&lt; 1 | 1, mid + 1, r, pos, val);pushup(u);}}info query(int u, int l, int r, int ql, int qr){if(l == ql &amp;&amp; r == qr)return tr[u].val;int mid = l + r &gt;&gt; 1;if(qr &lt;= mid)return query(u &lt;&lt; 1, l, mid, ql, qr);else if(ql &gt; mid)return query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr);else{return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr);}}int main(){scanf(&quot;%d%d&quot;, &amp;n, &amp;q);for(int i = 1; i &lt;= n; i ++)scanf(&quot;%d&quot;, &amp;a[i]);build(1, 1, n);while(q --){int a, b, c;scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);if(a == 1){change(1, 1, n, b, c);}else{auto a = query(1, 1, n, b, c);printf(&quot;%d %d\n&quot;, a.minv, a.cnt_min);}}}</code></pre><h2 id="2-维护复杂信息的线段树-最大子段和">2.维护复杂信息的线段树（最大子段和）</h2><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 2e5 + 10;struct info{ll mss, mpre, msuf, s;info () {}info (int a):mss(a), mpre(a), msuf(a), s(a) {}};struct Node{info val;}tr[N * 4];int n, q;int a[N];info operator + (const info &amp;l, const info &amp;r){info a;a.mss = max(max(l.mss, r.mss), l.msuf + r.mpre);a.mpre = max(l.mpre, l.s + r.mpre);a.msuf = max(r.msuf, r.s + l.msuf);a.s = l.s + r.s;return a;}void pushup(int u){tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val;}void build(int u, int l, int r){if(l == r)tr[u].val = info(a[l]);else{int mid = l + r &gt;&gt; 1;build(u &lt;&lt; 1, l, mid);build(u &lt;&lt; 1 | 1, mid + 1, r);pushup(u);}}void change(int u, int l, int r, int pos, int val){if(l == r)tr[u].val = info(val);else{int mid = l + r &gt;&gt; 1;if(pos &lt;= mid)change(u &lt;&lt; 1, l, mid, pos, val);elsechange(u &lt;&lt; 1 | 1, mid + 1, r, pos, val);pushup(u);}}info query(int u, int l, int r, int ql, int qr){if(l == ql &amp;&amp; r == qr)return tr[u].val;int mid = l + r &gt;&gt; 1;if(qr &lt;= mid)return query(u &lt;&lt; 1, l, mid, ql, qr);else if(ql &gt; mid)return query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr);else{return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr);}}int main(){scanf(&quot;%d%d&quot;, &amp;n, &amp;q);for(int i = 1; i &lt;= n; i ++)scanf(&quot;%d&quot;, &amp;a[i]);build(1, 1, n);while(q --){ll a, b, c;scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c);if(a == 1){change(1, 1, n, b, c);}else{auto a = query(1, 1, n, b, c);printf(&quot;%lld\n&quot;, a.mss);}}}</code></pre><h2 id="3-区间修改-区间查询线段树">3.区间修改，区间查询线段树</h2><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;typedef long long ll;ll n, q;ll a[N];struct info{ll maxv;};struct tag{ll add;};info operator + (const info &amp;l, const info &amp;r){return {max(l.maxv, r.maxv)};}info operator + (const info &amp;v, const tag &amp;t){return {v.maxv + t.add};}tag operator + (const tag &amp;t1, const tag &amp;t2){return {t1.add + t2.add};}struct node{tag t;info val;}tr[N * 4];void pushup(int u){tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val;}void settag(int u, tag t){tr[u].val = tr[u].val + t;tr[u].t = tr[u].t + t;}void pushdown(int u){if(tr[u].t.add != 0){settag(u &lt;&lt; 1, tr[u].t);settag(u &lt;&lt; 1 | 1, tr[u].t);tr[u].t.add = 0;}}void build(int u, int l, int r){if(l == r)tr[u].val = {a[l]};else{ll mid = l + r &gt;&gt; 1;build(u &lt;&lt; 1, l, mid);build(u &lt;&lt; 1 | 1, mid + 1, r);pushup(u);}}void modify(int u, int l, int r, int ql, int qr, tag t){if(l == ql &amp;&amp; r == qr){settag(u, t);return ;}ll mid = l + r &gt;&gt; 1;pushdown(u);if(qr &lt;= mid)modify(u &lt;&lt; 1, l, mid, ql, qr, t);else if(ql &gt; mid)modify(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr, t);else{modify(u &lt;&lt; 1, l, mid, ql, mid, t);modify(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr, t);}pushup(u);}info query(int u, int l, int r, int ql, int qr){if(l == ql &amp;&amp; r == qr)return tr[u].val;ll mid = l + r &gt;&gt; 1;pushdown(u);if(qr &lt;= mid)query(u &lt;&lt; 1, l, mid, ql, qr);else if(ql &gt; mid)query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr);else{return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr);}}int main(){scanf(&quot;%d%d&quot;, &amp;n, &amp;q);for(int i = 1; i &lt;= n; i ++)scanf(&quot;%d&quot;, &amp;a[i]);build(1, 1, n);while(q --){int op;scanf(&quot;%d&quot;, &amp;op);if(op == 1){int l, r, d;scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d);modify(1, 1, n, l, r, (tag){d});}else{int l, r;scanf(&quot;%d%d&quot;, &amp;l, &amp;r);auto a = query(1, 1, n, l, r);printf(&quot;%lld\n&quot;, a.maxv);}}return 0;}</code></pre><h2 id="区间修改-区间查询线段树-复杂标记">区间修改，区间查询线段树（复杂标记）</h2><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10, mod = 1e9 + 7;typedef long long ll;ll n, q;ll a[N];struct tag{ll mul, add;};tag operator + (const tag &amp;t1, const tag &amp;t2){return {t1.mul * t2.mul % mod, (t1.add * t2.mul + t2.add) % mod};}struct node{tag t;ll val;int siz;}tr[N * 4];void pushup(int u){tr[u].val = (tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val) % mod;}void settag(int u, tag t){tr[u].val = (tr[u].val * t.mul + tr[u].siz * t.add) % mod;tr[u].t = tr[u].t + t;}void pushdown(int u){if(tr[u].t.mul != 1 || tr[u].t.add != 0){settag(u &lt;&lt; 1, tr[u].t);settag(u &lt;&lt; 1 | 1, tr[u].t);tr[u].t.add = 0;tr[u].t.mul = 1;}}void build(int u, int l, int r){tr[u].t = {1, 0};tr[u].siz = r - l + 1;if(l == r)tr[u].val = {a[l]};else{ll mid = l + r &gt;&gt; 1;build(u &lt;&lt; 1, l, mid);build(u &lt;&lt; 1 | 1, mid + 1, r);pushup(u);}}void modify(int u, int l, int r, int ql, int qr, tag t){if(l == ql &amp;&amp; r == qr){settag(u, t);return ;}ll mid = l + r &gt;&gt; 1;pushdown(u);if(qr &lt;= mid)modify(u &lt;&lt; 1, l, mid, ql, qr, t);else if(ql &gt; mid)modify(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr, t);else{modify(u &lt;&lt; 1, l, mid, ql, mid, t);modify(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr, t);}pushup(u);}ll query(int u, int l, int r, int ql, int qr){if(l == ql &amp;&amp; r == qr)return tr[u].val;ll mid = l + r &gt;&gt; 1;pushdown(u);if(qr &lt;= mid)query(u &lt;&lt; 1, l, mid, ql, qr);else if(ql &gt; mid)query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr);else{return (query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr)) % mod;}}int main(){scanf(&quot;%d%d&quot;, &amp;n, &amp;q);for(int i = 1; i &lt;= n; i ++)scanf(&quot;%d&quot;, &amp;a[i]);build(1, 1, n);while(q --){int op;scanf(&quot;%d&quot;, &amp;op);if(op &lt;= 3){int l, r, d;scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d);if(op == 1)modify(1, 1, n, l, r, (tag){1, d});if(op == 2)modify(1, 1, n, l, r, (tag){d, 0});if(op == 3)modify(1, 1, n, l, r, (tag){0, d});}else{int l, r;scanf(&quot;%d%d&quot;, &amp;l, &amp;r);ll res = query(1, 1, n, l, r);printf(&quot;%lld\n&quot;, res);}}return 0;}</code></pre><h2 id="4-线段树上二分">4. 线段树上二分</h2><h2 id="5-扫描线与权值线段树">5. 扫描线与权值线段树</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AtCoderBeginnerContest046题解</title>
      <link href="/2022/10/15/AtCoderBeginnerContest046%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/10/15/AtCoderBeginnerContest046%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>AtCoder Beginner Contest 046 题解</h1><h2 id="a-atcodeer-and-paint-cans">A - <strong>AtCoDeer and Paint Cans</strong></h2><p>给定三个数，求这三个数中有多少个数是重复的。</p><p>开一个桶统计即可。</p><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;int, int&gt; m;int main(){int a, b, c;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;m[a] ++, m[b] ++, m[c] ++;int t = max(max(m[a], m[b]), m[c]);if(t == 1)cout &lt;&lt; 3 &lt;&lt; endl;else if(t == 2)cout &lt;&lt; 2 &lt;&lt; endl;else if(t == 3)cout &lt;&lt; 1 &lt;&lt; endl;return 0;}</code></pre></details><h2 id="b-painting-balls-with-atcodeer"><strong>B - Painting Balls with AtCoDeer</strong></h2><p>有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个球，现在需要用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>种颜色给每个球染色，要求相邻两个球的颜色不能相同，求可行的方案数。</p><p>第一次可以使用全部<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个颜色，之后每次都不能使用上一次的颜色，因此只能使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>种颜色，根据乘法原理，将其累乘起来即可。</p><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;signed main(){int n, k;cin &gt;&gt; n &gt;&gt; k;int res = 0;for(int i = 1; i &lt;= n; i ++){if(i == 1)res += k;else{res *= (k - 1);}}cout &lt;&lt; res &lt;&lt; endl;return 0;}</code></pre></details><h2 id="c-atcodeer-and-election-report"><strong>C - AtCoDeer and Election Report</strong></h2><p>给定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>对正整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i,A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，已知正整数数列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i,a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>满足一下条件：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">t_i \leq t_{i + 1}, a_i \leq a_{i + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.844301em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>T</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i / a_i = T_i / A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_n + a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最小值。</p><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 1010;int a[N], t[N];int ceill(int u, int v){return (u - 1) / v + 1;}signed main(){int n;cin &gt;&gt; n;for(int i = 1; i &lt;= n; i ++){cin &gt;&gt; t[i] &gt;&gt; a[i]; }int u = t[1], v = a[1];for(int i = 2; i &lt;= n; i ++){u = t[i] * ceill(u, t[i]);v = a[i] * ceill(v, a[i]);if(u / t[i] &lt; v / a[i])u = v / a[i] * t[i];elsev = u / t[i] * a[i];}cout &lt;&lt; u + v &lt;&lt; endl;return 0;}</code></pre></details><h2 id="atcodeer-and-rock-paper"><strong>AtCoDeer and Rock-Paper</strong></h2><p>你和对手都只有两种出拳方式：石头<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>和布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span>，布可以战胜石头，赢了得一分，输了扣一分，平局得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>分，现在给你对手的出拳方式，设你到第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>次出拳共出了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>次石头，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>次布，在对于任意位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i \geq y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的条件下，输出你能得到的最大分数。</p><p>贪心，首先在满足条件的情况下，出拳或布的先后顺序对答案没有影响，因此我们可以直接按每一位考虑，我们统计之前出拳和出布的次数，然后对于当前对手的出法，我们考虑：</p><p>如果对手此时出拳：如果我们此时可以出布，那么我们就出布，否则出拳</p><p>如果对手此时出布，如果我们此时可以出布，那么我们就出布，否则出拳。</p><p>模拟一下即可。</p><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;string s;int main(){cin &gt;&gt; s;int cnt_g = 0, cnt_p = 0;int res = 0;for(int i = 0; i &lt; s.size(); i ++){if(s[i] == 'g'){if(cnt_p &lt; cnt_g){res ++;cnt_p ++;}elsecnt_g ++;}else if(s[i] == 'p'){if(cnt_p &lt; cnt_g){cnt_p ++;}else{res --;cnt_g ++;}}}cout &lt;&lt; res &lt;&lt; endl;return 0;}</code></pre></details>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树形DP笔记</title>
      <link href="/2022/10/15/%E6%A0%91%E5%BD%A2DP%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/15/%E6%A0%91%E5%BD%A2DP%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>树形DP笔记</h1><h2 id="1-树形背包">1. 树形背包</h2><p>给定一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个点的有根树，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>号点为根节点，每个点有一个权值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，权值可能为负数。</p><p>你需要回答<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>个询问，在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>的子树中，选择一个大小恰好为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>的包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>点的连通块，最大的权值和。保证<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>不会超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>的子树大小。</p><p>数据范围：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">1 \leq n \leq 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">-10^5 \leq a_i \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \leq m \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq q \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p>考虑DP，设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示从以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>为根的子树里选<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个点且包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>点，权值的最大值。</p><p>很明显的背包问题，我们需要把不同儿子的背包合并，考虑树形DP时如何更新状态</p><p>枚举已经遍历过的连通块中选择<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个点，在当前枚举到的子树中选择<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个点，将它们的和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[u][i] + dp[v][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>存入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span>数组中，最后用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span></span></span></span>的值整体更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span>数组的值。</p><p>由此可见，每次合并两个背包都需要一个双重循环，表面上时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，然而实际上时间复杂度只有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>假设我们当前合并的两个背包的大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mi>u</mi></msub><mtext>和</mtext><mi>s</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">size_u和size_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么合并这两个背包的复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>s</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mi>u</mi></msub><mo>×</mo><mi>s</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mi>v</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(size_u × size_v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的</p><p>我们考虑数学含义，可以理解为当两个背包合并时，每对元素都贡献了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的代价，也就是说，当两个子树合并的时候，每对点都贡献了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的贡献。</p><p>那么对于任意一对点，它们只会做出一次贡献，被合并一次，所以总的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2010;int n, m, q;vector&lt;int&gt; son[N];int a[N];int dp[N][N];int sz[N];int temp[N];void dfs(int u){sz[u] = 0;for(auto v : son[u]){dfs(v);for(int i = 0; i &lt;= sz[u] + sz[v]; i ++)temp[i] = -0x3f3f3f3f;for(int i = 0; i &lt;= sz[u]; i ++){for(int j = 0; j &lt;= sz[v]; j ++)temp[i + j] = max(temp[i + j], dp[u][i] + dp[v][j]);}for(int i = 0; i &lt;= sz[u] + sz[v]; i ++)dp[u][i] = temp[i];sz[u] += sz[v];}sz[u] ++;for(int i = sz[u]; i &gt;= 1; i --)dp[u][i] = dp[u][i - 1] + a[u];}void solve(){scanf(&quot;%lld%lld&quot;, &amp;n, &amp;q);for(int i = 2; i &lt;= n; i ++){int t;scanf(&quot;%lld&quot;, &amp;t);son[t].push_back(i);}for(int i = 1; i &lt;= n; i ++)scanf(&quot;%lld&quot;, &amp;a[i]);dfs(1);while(q --){int u, m;scanf(&quot;%lld%lld&quot;, &amp;u, &amp;m);printf(&quot;%lld\n&quot;, dp[u][m]);}}signed main(){//ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);solve();return 0;}</code></pre></details><h3 id="变式1：">变式1：</h3><p>上述问题的数据范围更改成：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>50000</mn></mrow><annotation encoding="application/x-tex">1 \leq n \leq 50000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1 \leq m \leq 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p><p>其他条件不变</p><p>继续设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>这个子树里面选了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个点，并且包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>点的最大权值和</p><p>对于这道题，维度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>只需要遍历到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>即可，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 50010, M = 100, INF = 2e9;vector&lt;int&gt; son[N];int dp[N][M + 10];int sz[N];int n, q;int temp[N];int w[N];void dfs(int u){sz[u] = 0;for(auto v : son[u]){dfs(v);for(int i = 0; i &lt;= sz[u] + sz[v] &amp;&amp; i &lt;= M; i ++)temp[i] = -INF;for(int i = 0; i &lt;= sz[u] &amp;&amp; i &lt;= M; i ++){for(int j = 0; j &lt;= sz[v] &amp;&amp; i + j &lt;= M; j ++)temp[i + j] = max(temp[i + j], dp[u][i] + dp[v][j]);}for(int i = 0; i &lt;= sz[u] + sz[v] &amp;&amp; i &lt;= M; i ++)dp[u][i] = temp[i];sz[u] += sz[v];}sz[u] ++;for(int i = min(sz[u], M); i &gt;= 1; i --)dp[u][i] = dp[u][i - 1] + w[u];dp[u][0] = 0;}void solve(){scanf(&quot;%d%d&quot;, &amp;n, &amp;q);for(int i = 2; i &lt;= n; i ++){int x;scanf(&quot;%d&quot;, &amp;x);son[x].push_back(i);}for(int i = 1; i &lt;= n; i ++)scanf(&quot;%d&quot;, &amp;w[i]);dfs(1);while(q --){int u, m;scanf(&quot;%d%d&quot;, &amp;u, &amp;m);printf(&quot;%d\n&quot;, dp[u][m]);}}int main(){//ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);solve();return 0;}</code></pre></details><h3 id="变式2：">变式2：</h3><p>给你一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个点的有根树，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>号点为根，每个点有一个权值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和重量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>你需要选择一个重量恰好为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的包含根的连通块，且权值和最大。</p><p>对所有的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">k = 0,1,2,...,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span>输出答案，不存在则输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><p>数据范围：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \leq n \leq 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq a_i \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>w</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq w_i \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1 \leq m \leq 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p><p>更加标准的树上01背包问题，如果我们仍然像前两道题一样设计DP状态，那么我们执行合并两个子树背包的操作时，由于每个物品都有重量，所以一个子树可能节点个数很少，但是状态很多（重量可能很大导致第二维很大），因此无法像之前一样保证时间复杂度。</p><p>因此要使用特殊的技巧：在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>序上做DP</p><p>求出整棵树的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>序，设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">r_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>序中跳过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>这个子树的下一个位置</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>g</mi><mo>:</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">eg:(1(2(3)(4))(5(6)(7)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">5</span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>2</mn></msub><mo>=</mo><mn>5</mn><mo separator="true">,</mo><msub><mi>r</mi><mn>3</mn></msub><mo>=</mo><mn>4</mn><mo separator="true">,</mo><msub><mi>r</mi><mn>5</mn></msub><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">r_2 = 5, r_3 = 4, r_5 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span></p><p>我们从后往前做，设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示考虑<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>序中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>这一段节点，选的重量和不超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的最大权值和，同时满足不存在一个点选了，但是它的祖先没有被选的情况。</p><p>状态转移方程：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo>+</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = max(dp[r_i][j], f[i + 1][j - w_i] + v_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>即：如果不选这个节点，那么整个子树都会被跳过，从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>转移过来，否则考虑下一个节点，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2010, INF = 2e9;int w[N];int n, m;int dp[N][N];vector&lt;int&gt; son[N];int dfn[N], tot;int a[N];int l[N], r[N];int id[N];void dfs(int u){l[u] = ++ tot;id[tot] = u;for(auto v : son[u]){dfs(v);}r[u] = tot;}int main(){cin &gt;&gt; n &gt;&gt; m;for(int i = 2; i &lt;= n; i ++){int x;scanf(&quot;%d&quot;, &amp;x);son[x].push_back(i);}for(int i = 1; i &lt;= m; i ++)dp[n + 1][i] = -INF;for(int i = 1; i &lt;= n; i ++)scanf(&quot;%d&quot;, &amp;a[i]);for(int i = 1; i &lt;= n; i ++)scanf(&quot;%d&quot;, &amp;w[i]);dfs(1);for(int i = n; i &gt;= 1; i --){int u = id[i];for(int j = 0; j &lt;= m; j ++){dp[i][j] = dp[r[u] + 1][j];if(j &gt;= w[u])dp[i][j] = max(dp[i][j], dp[i + 1][j - w[u]] + a[u]);}}for(int i = 0; i &lt;= m; i ++)if(dp[1][i] &gt;= 0)printf(&quot;%d\n&quot;, dp[1][i]);elseprintf(&quot;0\n&quot;);}&lt;/details&gt;</code></pre></details><h2 id="2-树上路径">2.树上路径</h2><p>给你一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个点的树。</p><p>给你<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>条树上的简单路径，每个路径都有一个权值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，要求选择一些路径，使得每个点<strong>至多</strong>在一条路径上，并且路径的权值和<strong>最大</strong>。</p><p>数据范围：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">1 \leq n \leq 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">1 \leq m \leq 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq a_i \leq 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><p>我们考虑在两个点的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">LCA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span></span></span></span>处决定这条路径是否选择。</p><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示考虑所有在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>为根的子树里的所有路径的最大权值和。</p><p>每次转移的时候，对于点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，考虑所有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">LCA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>点的路径，如果选择这条路径就相当于删除这条路径上所有的点，整个子树被拆成一个森林，将这些点的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span>值加上路径的权值即可，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。</p><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 2010;int n, m;vector&lt;int&gt; son[N];vector&lt;array&lt;int, 3&gt;&gt; path[N];int dp[N];int son_dp[N];int depth[N];int f[N];void dfs(int u){for(auto v : son[u]){dfs(v);son_dp[u] += dp[v];//所有儿子节点的DP值之和}dp[u] = son_dp[u];//不选u，DP值就是儿子节点的DP值之和for(auto p : path[u])//选u，考虑LCA上的一条路径{int temp = son_dp[u];int x = p[0];while(x != u){temp += son_dp[x] - dp[x];x = f[x];}x = p[1];while(x != u){temp += son_dp[x] - dp[x];x = f[x];}temp += p[2];dp[u] = max(dp[u], temp);}}signed main(){scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);for(int i = 2; i &lt;= n; i ++){scanf(&quot;%lld&quot;, &amp;f[i]);son[f[i]].push_back(i);depth[i] = depth[f[i]] + 1;}for(int i = 1; i &lt;= m; i ++){int u, v, a;scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;a);int x = u, y = v;while(x != y){if(depth[x] &gt; depth[y])x = f[x];elsey = f[y];}path[x].push_back({u, v, a});}dfs(1);printf(&quot;%lld\n&quot;, dp[1]);return 0;}</code></pre></details><h3 id="变式1：">变式1：</h3><p>给你一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个点的树。</p><p>给你<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>条树上的简单路径，每个路径都有权值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<strong>保证每条路径都是从一个点到它的祖先</strong></p><p>要求选择一些路径，使得每个点<strong>至少</strong>在一条路径上，并且路径的权值和<strong>最小</strong>，如果不存在输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></p><p>数据范围同上</p><p>这道题一个点可能会在多条路径上面，因此我们不能直接记录在哪些路径上。</p><p>然而如果有点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>在很多条路径上面，那么我们实际上只要知道这些路径最多能往上伸多少即可。</p><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示考虑<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>这个子树里面选择的路径，最多延伸到深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的位置最小的权值和。</p><p>在转移的时候，我们可以枚举每个儿子的路径最多延伸到多少，取深度的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span>即可。</p><p>然而这样做的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，考虑优化。</p><p>我们可以使用前缀最小值来进行优化，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces1700-2000难度部分题题解</title>
      <link href="/2022/09/06/Codeforces1700-2000%E9%9A%BE%E5%BA%A6%E9%83%A8%E5%88%86%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/09/06/Codeforces1700-2000%E9%9A%BE%E5%BA%A6%E9%83%A8%E5%88%86%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="codeforces-1700-2000难度部分题题解">Codeforces 1700-2000难度部分题题解</h2><h2 id="1721d-maximum-and">1721D -Maximum AND</h2><p><strong>题目大意</strong>:给出两个长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>，规定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>表示以下操作：</p><ol><li>创建一个长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的数组，满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>⊕</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i=a_i \oplus b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>c</mi><mn>1</mn></msub><mi mathvariant="normal">&amp;</mi><msub><mi>c</mi><mn>2</mn></msub><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">&amp;</mi><msub><mi>c</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">f(a,b) = c_1 \&amp; c_2 \&amp;...\&amp;c_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">&amp;</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">&amp;</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">&amp;</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ol><p>你可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>数组进行任意的排列，求最大的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p><p>数据范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq n \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>题解</strong>：二进制构造题，首先考虑二进制拆位，由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>由按位与操作得到，因此某一位为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>必然有：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\forall c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，该位的二进制为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>又由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>⊕</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i=a_i \oplus b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mtext>与</mtext><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i 与 b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">与</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>必然在该位上满足：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的个数与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的个数相同</p><p>由此考虑贪心：从高位向低位枚举，如果满足该位上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的个数相同，就选取这一位，但是这种贪心方式是错误的，因为：</p><pre><code>23 02 1</code></pre><p>如果按上述方式选取，会发现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>中一定有一个数被选择了两次，这显然是不合法的</p><p>于是进一步考虑一个数能被选取的条件，不妨设答案为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span></p><p>如果存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的排序，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\forall a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant="normal">&amp;</mi><mi>r</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo><mo>⊕</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mi>i</mi></msub><mi mathvariant="normal">&amp;</mi><mi>r</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">(a_i \&amp; res) \oplus (b_i \&amp; res) = res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">&amp;</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">&amp;</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>（即前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>位中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>中1的个数与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>中0的个数相同），则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>即为答案。</p><p>我们考虑每一位，将其异或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>,并将两个得到的数组排序，如果相同，则该位为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，否则为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><pre><code class="language-cpp">// Problem: D. Maximum AND// Contest: Codeforces - Educational Codeforces Round 134 (Rated for Div. 2)// URL: https://codeforces.com/problemset/problem/1721/D// Memory Limit: 256 MB// Time Limit: 3000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 + 10;int n;int a[N];int b[N];bool check(int x){vector&lt;int&gt; c, d;for(int i = 1; i &lt;= n; i ++){c.push_back(a[i] &amp; x);d.push_back((b[i] &amp; x) ^ x);}sort(c.begin(), c.end());sort(d.begin(), d.end());return c == d;}void solve(){cin &gt;&gt; n;int res = 0;for(int i = 1; i &lt;= n; i ++)cin &gt;&gt; a[i];for(int i = 1; i &lt;= n; i ++)cin &gt;&gt; b[i];for(int i = 30; i &gt;= 0; i --){if(check(res | (1 &lt;&lt; i)))res |= (1 &lt;&lt; i);}cout &lt;&lt; res &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="1718a1-a2-burenka-and-traditions-easy-version-hard-version">1718A1/A2 - Burenka and Traditions (easy version)+(hard version)</h2><p><strong>题目大意</strong>：有一个长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，每一次操作可以选择一段区间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>和一个非负整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，花费<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[(r - l + 1) / 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">]</span></span></span></span>秒使区间内的数都异或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，问最少几秒才能把数组中所有元素变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><p>数据范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">1 \leq n \leq 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">0 \leq a_i \leq 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p><p><strong>题解</strong>：我们可以对操作做等价变形，我们可以发现操作其实可以分为两种：</p><ol><li>异或一个数，代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>异或连续两个数，代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ol><p>显然，我们至多对每个数进行一次第一种操作，答案至多为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，考虑第二种操作对答案的影响，可以发现，如果一段连续的数异或为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么就可以连续用第二种操作，每用一次第二种操作，答案就会减少<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因此我们可以维护所有异或和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的块，这启发我们考虑前缀和。</p><p>对原数组求前缀异或和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sum(1,l)=sum(1,r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>，说明此时可以使用一次第二种操作，答案减少<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，我们可以用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span></span></span></span>来维护前缀异或和的值是否出现过，注意特判<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的情况即可。</p><pre><code class="language-cpp">// Problem: A1. Burenka and Traditions (easy version)// Contest: Codeforces - Codeforces Round #814 (Div. 1)// URL: https://codeforces.com/problemset/problem/1718/A1// Memory Limit: 256 MB// Time Limit: 1000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;string&gt;#define int long longusing namespace std;void solve(){int n;cin &gt;&gt; n;int res = n;map&lt;int, int&gt; m;m[0] = 1;int seg = 0;for(int i = 1; i &lt;= n; i ++){int x;cin &gt;&gt; x;seg ^= x;if(m.count(seg)){res --;m.clear();m[0] = 1;seg = 0;}elsem[seg] = 1;}cout &lt;&lt; res &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="1718b-fibonacci-strings">1718B - Fibonacci Strings</h2><p><strong>题目大意</strong>：给定一个数列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">{c_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>你可以执行若干次操作，对于第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>次操作：</p><ol><li>选定一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>范围内的整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i \geq 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，必须保证<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo mathvariant="normal">≠</mo><msub><mi>d</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">d_i \neq d_{i - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>。</li><li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><msub><mi>d</mi><mi>i</mi></msub></msub></mrow><annotation encoding="application/x-tex">c_{d_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68066em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span>减去<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是斐波那契数列中第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>项</li></ol><p>问：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">c_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>能否全为0？</p><p>数据范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq k \leq 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>题解</strong>：首先可以观察到，只有当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{i = 1}^k c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>等于斐波那契数列某项的前缀和时，才有可能全为0</p><p>之后考虑如何选择最优解</p><ol><li>优先考虑插入最小的数到最小的斐波那契数</li><li>优先考虑插入最大的数到最大的斐波那契数</li></ol><p>显然方案2为最优解，注意特判每次不能选两个相同的下标插入即可</p><pre><code class="language-cpp">// Problem: B. Fibonacci Strings// Contest: Codeforces - Codeforces Round #814 (Div. 1)// URL: https://codeforces.com/problemset/problem/1718/B// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;queue&gt;#define int long longusing namespace std;const int N = 2e5 + 10;typedef pair&lt;int, int&gt; PII;int a[N];int feb[N];int sum[N];int idx = 0;void init(){feb[1] = 1;feb[2] = 1;sum[1] = 1;sum[2] = 2;for(int i = 3; i &lt;= 50; i ++){feb[i] = feb[i - 1] + feb[i - 2];sum[i] = sum[i - 1] + feb[i];}}bool check(int s){for(int i = 1; i &lt;= 50; i ++){if(sum[i] == s){idx = i;return true;}}return false;}void solve(){priority_queue&lt;PII, vector&lt;PII&gt; &gt; heap;idx = 0;int n;cin &gt;&gt; n;int s = 0;for(int i = 1; i &lt;= n; i ++){cin &gt;&gt; a[i];s += a[i];heap.push({a[i], i});}bool flag = 1;if(!check(s)){cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;return ;}int back = -1;for(int i = idx; i &gt;= 1; i --){auto t = heap.top();heap.pop();if(t.second == back &amp;&amp; heap.size() &amp;&amp; heap.top().first != t.first)flag = 0;else if(t.second == back &amp;&amp; heap.size() &amp;&amp; heap.top().first == t.first){auto tt = heap.top();heap.pop();heap.push(t);t = tt;}else if(t.second == back &amp;&amp; heap.empty())flag = 0;if(t.first &gt;= feb[i]){t.first -= feb[i];heap.push(t);back = t.second;}else{flag = 0;break;}}if(flag)cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;elsecout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;init();while(T --){solve();}return 0;}</code></pre><h2 id="1716d-chip-move">1716D - Chip Move</h2><p><strong>题目大意</strong>：给定两个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，问从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始，第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>步只能走<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k + i - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的倍数，问分别走到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x \in [1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>的方案数，对998244353取模。</p><p>数据范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq k \leq n \leq 2*10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>题解</strong>：待补充…</p><pre><code class="language-cpp">// Problem: D. Chip Move// Contest: Codeforces - Educational Codeforces Round 133 (Rated for Div. 2)// URL: https://codeforces.com/problemset/problem/1716/D// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 + 10, mod = 998244353;int dp[2][N], res[N];void solve(){int n, k;cin &gt;&gt; n &gt;&gt; k;int sum = k, id = 1;dp[0][0] = 1;for(int i = k; sum &lt;= n; i ++){id ^= 1;for(int j = i; j &lt;= n; j ++)dp[id][j] = (dp[id][j] + dp[id ^ 1][j - i] + dp[id][j - i]) % mod;dp[id][0] = 0, sum += i;for(int j = 1; j &lt;= n; j ++){res[j] = (res[j] + dp[id][j]) % mod;dp[id ^ 1][j] = 0;}}for(int i = 1; i &lt;= n; i ++)cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);solve();return 0;}</code></pre><h2 id="1716c-robot-in-a-hallway">1716C -  Robot in a Hallway</h2><p><strong>题目大意</strong>：</p><p><strong>题解</strong>：</p><pre><code class="language-cpp">// Problem: C. Robot in a Hallway// Contest: Codeforces - Educational Codeforces Round 133 (Rated for Div. 2)// URL: https://codeforces.com/problemset/problem/1716/C// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 + 10;int a[2][N], f[2][N];int n;void solve(){cin &gt;&gt; n;for(int i = 0; i &lt;= 1; i ++)for(int j = 1; j &lt;= n; j ++)cin &gt;&gt; a[i][j];a[0][1] = -1;f[0][n] = a[0][n], f[1][n] = a[1][n];for(int i = 0; i &lt;= 1; i ++)for(int j = n - 1; j &gt;= 1; j --)f[i][j] = max(f[i][j + 1] - 1, a[i][j]);f[0][n] = max(a[1][n] - 1, a[0][n]);f[1][n] = max(a[0][n] - 1, a[1][n]);for(int i = 0; i &lt;= 1; i ++)for(int j = n - 1; j &gt;= 1; j --)f[i][j] = max(f[i][j + 1] - 1, max(a[i][j], a[i ^ 1][j] - 2 * (n - j) - 1));int res = f[0][1] + 2 * n, rec = a[1][1] + 1;;for(int i = 2, p = 1; i &lt;= n; i ++, p ^= 1){res = min(res, rec + (f[p][i] - rec &gt; 0 ? f[p][i] - rec : 0ll) + 2 * (n - i + 1));rec = max(rec + 1, a[p][i] + 1);rec = max(rec + 1, a[p ^ 1][i] + 1);}res = min(res, rec);cout &lt;&lt; res &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="1700d-river-locks">1700D -River Locks</h2><p><strong>题目大意</strong>：</p><p><strong>题解</strong>：</p><pre><code class="language-cpp">// Problem: D.River Locks// Contest: Codeforces - Codeforces Round #802 (Div. 2)// URL: https://codeforces.com/problemset/problem/1700/D// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 + 10;int a[N], s[N];int n, q;void solve(){cin &gt;&gt; n;double mmax = 0;for(int i = 1; i &lt;= n; i ++){cin &gt;&gt; a[i];s[i] = s[i - 1] + a[i];mmax = max(mmax, (double)s[i] / i);}cin &gt;&gt; q;while(q --){int x;cin &gt;&gt; x;if(mmax - x &gt; 1e-7){cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;continue;}cout &lt;&lt; (s[n] + x - 1) / x &lt;&lt; endl;}}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);solve();return 0;}</code></pre><h2 id="1695c-zero-path">1695C - Zero Path</h2><p><strong>题目大意</strong>：</p><p><strong>题解</strong>：</p><pre><code class="language-cpp">// Problem: C. Zero Path// Contest: Codeforces - Codeforces Round #801 (Div. 2) and EPIC Institute of Technology Round// URL: https://codeforces.com/problemset/problem/1695/C// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 1010, INF = 0x3f3f3f3f;int a[N][N];int pd[N][N];int dp[N][N];void solve(){int n, m;cin &gt;&gt; n &gt;&gt; m;for(int i = 1; i &lt;= n; i ++)for(int j = 1; j &lt;= m; j ++)cin &gt;&gt; a[i][j];if((n + m - 1) &amp; 1){cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;return ;}int h = (n + m - 1) / 2;dp[1][1] = (a[1][1] == 1);for(int i = 1; i &lt;= n; i ++)for(int j = 1; j &lt;= m; j ++)dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + (a[i][j] == 1);for(int i = 2; i &lt;= n; i ++)pd[i][0] = INF;for(int i = 2; i &lt;= m; i ++)pd[0][i] = INF;for(int i = 1; i &lt;= n; i ++)for(int j = 1; j &lt;= m; j ++)pd[i][j] = min(pd[i - 1][j], pd[i][j - 1]) + (a[i][j] == 1);if(h &gt;= pd[n][m] &amp;&amp; h &lt;= dp[n][m])cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;elsecout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="1592c-bakry-and-partitioning">1592C - Bakry and Partitioning</h2><p><strong>题目大意</strong>：</p><p><strong>题解</strong>：</p><pre><code class="language-cpp">// Problem: C. Bakry and Partitioning// Contest: Codeforces - Codeforces Round #746 (Div. 2)// URL: https://codeforces.com/problemset/problem/1592/C// Memory Limit: 256 MB// Time Limit: 1000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 + 10, M = N * 2;int h[N], e[M], ne[M], w[N], idx;int n, k;int dp[N];bool v[N];void add(int a, int b){e[idx] = b;ne[idx] = h[a];h[a] = idx ++;}void dfs(int u, int val){dp[u] = w[u];for(int i = h[u]; ~i; i = ne[i]){int j = e[i];if(v[j])continue;v[j] = true;dfs(j, val);if(dp[j] != val)dp[u] ^= dp[j];}}void solve(){cin &gt;&gt; n &gt;&gt; k;memset(v, 0, sizeof v);idx = 0;int sum = 0;for(int i = 1; i &lt;= n; i ++){h[i] = -1;dp[i] = 0;cin &gt;&gt; w[i];sum ^= w[i];}for(int i = 1; i &lt;= n - 1; i ++){int a, b;cin &gt;&gt; a &gt;&gt; b;add(a, b);add(b, a);}if(sum == 0){cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;return;}else if(k == 2){cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;return;}dfs(1, sum);int cnt = 0;for(int i = 1; i &lt;= n; i ++)cnt += dp[i] == sum;if(cnt &gt;= 2)cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;elsecout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="1454-e-number-of-simple-paths">1454 - E Number of Simple Paths</h2><p><strong>题目大意</strong>：给定一颗基环树，求基环树中长度大于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的不同简单路径的数量</p><p><strong>题解</strong>:</p><pre><code class="language-cpp">// Problem: E. Number of Simple Paths// Contest: Codeforces - Codeforces Round #686 (Div. 3)// URL: https://codeforces.com/problemset/problem/1454/E// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;queue&gt;#define int long longusing namespace std;const int N = 2e5 + 10, M = N * 2;int h[N], e[M], ne[M], idx;int siz[N];int n;bool v[N];int d[N];void add(int a, int b){e[idx] = b;ne[idx] = h[a];h[a] = idx ++;}void topsort(){queue&lt;int&gt; q;for(int i = 1; i &lt;= n; i ++)if(d[i] == 1)q.push(i);while(q.size()){int t = q.front();q.pop();for(int i = h[t]; ~i; i = ne[i]){int j = e[i];if(-- d[j] == 1)q.push(j);}}}void dfs(int u, int fa){siz[u] = 1;for(int i = h[u]; ~i; i = ne[i]){int j = e[i];if(j != fa){ dfs(j, u);siz[u] += siz[j];}}}void solve(){cin &gt;&gt; n;int res = 0, t = 0;;for(int i = 1; i &lt;= n; i ++){h[i] = -1;v[i] = 0;siz[i] = 0;idx = 0;d[i] = 0;}for(int i = 1; i &lt;= n; i ++){int a, b;cin &gt;&gt; a &gt;&gt; b;add(a, b);add(b, a);d[a] ++;d[b] ++;}topsort();for(int i = 1; i &lt;= n; i ++)if(d[i] &gt; 1)v[i] = true;for(int i = 1; i &lt;= n; i ++){if(v[i]){t = 0;for(int j = h[i]; ~j; j = ne[j]){int p = e[j];if(!v[p]){dfs(p, i);t += siz[p];}}res += t;res += t * (t - 1) / 2;}}cout &lt;&lt; n * (n - 1) - res &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="1619g-unusual-minesweeper">1619G - Unusual Minesweeper</h2><p><strong>题目大意</strong>：</p><p><strong>题解</strong>：</p><pre><code class="language-cpp">// Problem: G. Unusual Minesweeper// Contest: Codeforces - Codeforces Round #762 (Div. 3)// URL: https://codeforces.com/problemset/problem/1619/G// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 + 10, INF = 1e18;typedef pair&lt;int, int&gt; PII;int n, k;pair&lt;pair&lt;int, int&gt;, int&gt; poi[N];int p[N], t[N];int res[N];int x, y, id, l, i, ii, nn;int find(int x){if(p[x] != x)p[x] = find(p[x]);return p[x];} void solve(){cin &gt;&gt; n &gt;&gt; k;for(i = 1; i &lt;= n; i ++){cin &gt;&gt; x &gt;&gt; y &gt;&gt; t[i];poi[i] = {{x, y}, i};p[i] = i;}for(ii = 0; ii &lt; 2; ii ++){sort(poi + 1, poi + 1 + n);for(i = 1; i &lt;= n; i ++){y = poi[i].first.first;x = poi[i].first.second;id = poi[i].second;if(i &gt; 1 &amp;&amp; y == poi[i - 1].first.first &amp;&amp; x - poi[i - 1].first.second &lt;= k){l = poi[i - 1].second;t[find(id)] = min(t[find(id)], t[find(l)]);p[find(l)] = find(id);}}for(int i = 1; i &lt;= n; i ++)swap(poi[i].first.first, poi[i].first.second);}nn = 0;for(i = 1; i &lt;= n; i ++){if(find(i) == i){nn ++;res[nn] = t[i];}} sort(res + 1, res + nn + 1, greater&lt;int&gt; ());res[nn + 1] = -INF;for(i = 1; i &lt;= nn; i ++)if(res[i + 1] &lt;= i - 1)break;cout &lt;&lt; i - 1 &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="1728d-letter-picking">1728D -  Letter Picking</h2><p><strong>题目大意</strong>：</p><p><strong>题解</strong>：</p><pre><code class="language-cpp">// Problem: D. Letter Picking// Contest: Codeforces - Educational Codeforces Round 135 (Rated for Div. 2)// URL: https://codeforces.com/problemset/problem/1728/D// Memory Limit: 512 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;void solve(){string s;cin &gt;&gt; s;s = '_' + s;int n = s.size() - 1;int i = 1, j = n;while(i &lt; j){if(s[i] == s[j]){i ++, j --;}elsebreak;}while(i &lt; j){if(s[i] == s[i + 1])i += 2;else if(s[j] == s[j - 1]) j -= 2;elsebreak;}if(i &lt; j)cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl;elsecout &lt;&lt; &quot;Draw&quot; &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="1722f-l-shapes">1722F - L-shapes</h2><p><strong>题目大意</strong>：</p><p><strong>题解</strong>：若一个点是L形的一部分，先用BFS四连通找此连通块是否是L形，再找此点的八连通看是否只有两个L形的一部分，若不是，则不合法。</p><pre><code class="language-cpp">// Problem: F. L-shapes// Contest: Codeforces - Codeforces Round #817 (Div. 4)// URL: https://codeforces.com/problemset/problem/1722/F// Memory Limit: 256 MB// Time Limit: 1000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;queue&gt;#define int long longusing namespace std;const int N = 110;char g[N][N];int n, m;bool v[N][N];int dx4[4] = {1, -1, 0, 0}, dy4[4] = {0, 0, 1, -1};int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1}, dy8[8] = {-1, 0, 1, 1, -1, -1, 0, 1};int bfs_4(int sx, int sy)//判断L型{if(v[sx][sy])return 3;int cnt = 0;v[sx][sy] = 1;queue&lt;pair&lt;int, int&gt;&gt; q;q.push({sx, sy});while(q.size()){int x = q.front().first, y = q.front().second;q.pop();cnt ++;for(int i = 0; i &lt; 4; i ++){int zx = x + dx4[i], zy = y + dy4[i];if(zx &amp;&amp; zy &amp;&amp; zx &lt;= n &amp;&amp; zy &lt;= m &amp;&amp; !v[zx][zy] &amp;&amp; g[zx][zy] == '*' &amp;&amp; abs(zx - sx) &lt;= 1 &amp;&amp; abs(zy - sy) &lt;= 1){v[zx][zy] = 1;q.push({zx, zy});}}}return cnt;}int bfs_8(int sx, int sy){int cnt = 0;for(int i = 0; i &lt; 8; i ++){int zx = sx + dx8[i], zy = sy + dy8[i];if(zx &amp;&amp; zy &amp;&amp; zx &lt;= n &amp;&amp; zy &lt;= m &amp;&amp; g[zx][zy] == '*')cnt ++;}return cnt;}void solve(){memset(v, 0, sizeof v);cin &gt;&gt; n &gt;&gt; m;for(int i = 1; i &lt;= n; i ++)for(int j = 1; j &lt;= m; j ++)cin &gt;&gt; g[i][j];for(int i = 1; i &lt;= n; i ++)for(int j = 1; j &lt;= m; j ++)if(g[i][j] == '*'){int cnt4 = bfs_4(i, j);int cnt8 = bfs_8(i, j);if(cnt4 != 3 || cnt8 != 2){cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;return ;}}cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="1647d-madoka-and-the-best-school-in-russia">1647D Madoka and the Best School in Russia</h2><p><strong>题目大意</strong>：</p><ul><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>的倍数，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>为“好数”</li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是好数且不能写成任意两个好数之积，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是美丽数</li></ul><p>T组询问，每组询问给定两个正整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">x,d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span></span></span></span>，问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>是否有至少两种方式写为至少一个美丽数之积。如果是，输出“YES”，否则输出“NO”</p><p><strong>题解</strong>：分类讨论</p><p>令$x = d^k \times s <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，其中</mtext></mrow><annotation encoding="application/x-tex">，其中</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span></span></span></span>k &gt; 0, d | s<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（题中</mtext></mrow><annotation encoding="application/x-tex">（题中</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">题</span><span class="mord cjk_fallback">中</span></span></span></span>x<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>一定满足是</mtext></mrow><annotation encoding="application/x-tex">一定满足是</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">满</span><span class="mord cjk_fallback">足</span><span class="mord cjk_fallback">是</span></span></span></span>d$的倍数）</p><p>则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>和一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>×</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">d \times s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>即为一种分解方案</p><p>考虑<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则显然不合法</p><p>此时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k &gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>​若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>为合数，则将其分解为两个数，分别乘在两个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>上，得到第二种方案</p><p>此时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>为质数或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，显然只能拆<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span></p><p>​若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>为质数，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>无法拆，不合法</p><p>​若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>含有与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>不同的质因数，将这个质因子乘<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>，剩下的部分与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>乘在另一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>上，得到第二种方案，此时需要3个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p><p>​若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><msup><mi>s</mi><mi>q</mi></msup></mrow><annotation encoding="application/x-tex">d = s^q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span></span></span></span></span></span></span></span>且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">q &gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><ol><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">q = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>可以拆成两个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>，然后将三个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>乘在三个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>上，此时需要4个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&gt;</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k &gt; 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></li><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">q &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>可以拆为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>s</mi><mrow><mi>q</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">s^{q - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>s</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">s^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>s</mi><mrow><mi>q</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">s^{q - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>乘在一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>上，得到第二种方案，此时需要3个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li></ol><pre><code class="language-cpp">// Problem: D. Madoka and the Best School in Russia// Contest: Codeforces - Codeforces Round #777 (Div. 2)// URL: https://codeforces.com/problemset/problem/1647/D// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;int x, d, k;bool check(int x){if(x &lt; 4)return 1;if(x % 2 == 0 || x % 3 == 0)return 0;for(int i = 5; i * i &lt;= x; i += 6)if(x % i == 0 || x % (i + 2) == 0)return 0;return 1;}void solve(){cin &gt;&gt; x &gt;&gt; d;for(k = 0; x % d == 0; k ++, x /= d);if(k &lt; 2)cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;else if(!check(x))cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;else if(check(d))cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;elsecout &lt;&lt; (k &gt; (x * x == d) + 2 ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="167b-wizards-and-huge-prize">167B - Wizards and Huge Prize</h2><p><strong>题目大意</strong>：</p><p>最开始你有k的容积，有n轮比赛，比赛分为两种(具体种类由输入给出)，一种的奖品是增加ai容积，另一种增加一个物品，只有到最后的容积装得下所有赢得的物品才算合法的方案，问赢得的比赛总场数&gt;=l的合法方案的概率。</p><p><strong>题解</strong>：</p><p>期望DP</p><p>将第二种奖品看成容积为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，之后考虑DP</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>表示从前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>次比赛中获胜<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>次，容积为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>时的概率</p><p>状态转移方程：</p><p>如果第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>场比赛输掉，则有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>∗</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i+1][j][k] += dp[i][j][k] * (1 - p[i + 1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p><p>如果第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>场比赛获胜，则有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>∗</mo><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i+1][j+1][k+a[i+1] += dp[i][j][k] * p[i + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">// Problem: B. Wizards and Huge Prize// Contest: Codeforces - Codeforces Round #114 (Div. 1)// URL: https://codeforces.com/problemset/problem/167/B// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 210;int n, l, k;double dp[N][N][N * 2];double res;int a[N];double p[N];void work(){dp[0][0][k + 200] = 1;//将-1考虑为容积为-1for(int i = 0; i &lt; n; i ++){for(int j = 0; j &lt;= i; j ++){for(int q = 0; q &lt;= 400; q ++){int t = min(400ll, q + a[i + 1]);dp[i + 1][j][q] += dp[i][j][q] * (1 - p[i + 1]);if(t &gt;= 0)dp[i + 1][j + 1][t] += dp[i][j][q] * p[i + 1];}}}}void solve(){cin &gt;&gt; n &gt;&gt; l &gt;&gt; k;for(int i = 1; i &lt;= n; i ++){cin &gt;&gt; p[i];p[i] /= 100;}for(int i = 1; i &lt;= n; i ++)cin &gt;&gt; a[i];work();for(int i = l; i &lt;= n; i ++){for(int j = 200; j &lt;= 400; j ++)res += dp[n][i][j];}printf(&quot;%.10lf\n&quot;, res);}signed main(){//ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);solve();return 0;}</code></pre></details><h2 id="cf730-bottles">CF730 - Bottles</h2><p><strong>题目大意</strong>：</p><p>有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 瓶水，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 瓶水的水量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，容量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 单位水从一个瓶子转移到另一个瓶子所消耗时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 秒，且可以进行无限次转移。求储存所有水所需最小瓶子数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 以及该情况下所用最小时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>。</p><p><strong>题解</strong>：</p><p>01背包</p><p>第一问答案显然，考虑第二问</p><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>为前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个瓶子里取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个瓶子，总容积为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的最大不倒入杯中的体积</p><p>状态转移方程：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><msub><mi>b</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - b_i][k] + a_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>第一维可以滚掉，答案即为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow></msub><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_{sum} - max(dp[j][k])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p><details>    <summary> <font face="Comic Sans MS" size="4" color="green">AC 代码</font></summary><pre><code class="language-cpp">// Problem: J. Bottles// Contest: Codeforces - 2016-2017 ACM-ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred)// URL: https://codeforces.com/problemset/problem/730/J// Memory Limit: 512 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 110;int res, sum1, sum2;int n;int dp[N * N][N];PII a[N];int k;bool cmp(PII a, PII b){return a.second &gt; b.second;}void work(){memset(dp, 128, sizeof dp);dp[0][0] = 0;for(int i = 1; i &lt;= n; i ++)for(int j = sum2; j &gt;= a[i].second; j --)for(int p = 1; p &lt;= k; p ++)dp[j][p] = max(dp[j][p], dp[j - a[i].second][p - 1] + a[i].first);for(int i = sum1; i &lt;= sum2; i ++)res = max(res, dp[i][k]);cout &lt;&lt; sum1 - res &lt;&lt; endl;}void solve(){cin &gt;&gt; n;for(int i = 1; i &lt;= n; i ++){cin &gt;&gt; a[i].first;sum1 += a[i].first;}for(int i = 1; i &lt;= n; i ++){cin &gt;&gt; a[i].second;}sort(a + 1, a + n + 1, cmp);while(sum2 &lt; sum1)sum2 += a[++ k].second;cout &lt;&lt; k &lt;&lt; &quot; &quot;;work();}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);solve();return 0;}</code></pre></details>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3分钟了解猫宫Hinata的FPS</title>
      <link href="/2022/09/06/3%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E7%8C%AB%E5%AE%ABHinata%E7%9A%84FPS/"/>
      <url>/2022/09/06/3%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E7%8C%AB%E5%AE%ABHinata%E7%9A%84FPS/</url>
      
        <content type="html"><![CDATA[<h1>猫宫赛高！</h1><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=36352138&page=" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随想test</title>
      <link href="/2022/09/05/%E9%9A%8F%E6%83%B3test/"/>
      <url>/2022/09/05/%E9%9A%8F%E6%83%B3test/</url>
      
        <content type="html"><![CDATA[<h1>为什么我FPS玩的这么菜！！！！</h1>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces1500-1600部分题题解</title>
      <link href="/2022/09/05/CodeForces1500-1600%E9%83%A8%E5%88%86%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/09/05/CodeForces1500-1600%E9%83%A8%E5%88%86%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>Codeforces 1500 - 1600难度笔记</h1><h2 id="1675e-replace-with-the-previous-minimize">1675E- Replace With the Previous, Minimize</h2><p>给定一个长度为n的字符串，有k次操作，每次操作可以选一个字母，让所有该字母变成字典序的前一个字母，求能够通过k次操作得到的最小字典序。</p><p>贪心，维护一个max_idx表示从a到a + max_idx中的字母都可以通过max_idx次操作转化为a</p><p>如果当前字母转换为a的操作数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\leq k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> ,则直接更新max_idx</p><p>如果当前字母转换为a的操作数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">&gt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，则该字母最多只能进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">k - midx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span>次操作，设当前字母为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>−</mo><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>d</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s-(k - midx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>区间内的字母都可以转化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>−</mo><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>d</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s - (k - midx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，因此直接将其转化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>−</mo><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>d</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s - (k - midx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p><pre><code class="language-cpp">// Problem: E. Replace With the Previous, Minimize// Contest: Codeforces - Codeforces Round #787 (Div. 3)// URL: https://codeforces.com/problemset/problem/1675/E// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 + 10;void solve(){    int n, k;    cin &gt;&gt; n &gt;&gt; k;    string s;    cin &gt;&gt; s;    int max_idx = 0;    for(int i = 0; i &lt; s.size(); i ++)    {        int t = s[i] - 'a';        if(t &lt;= k)            max_idx = max(max_idx, t);        else        {            char min_c = s[i] - k + max_idx;            char max_c = s[i];            for(int j = 0; j &lt; s.size(); j ++)            {                if(min_c &lt;= s[j] &amp;&amp; s[j] &lt;= max_c)                    s[j] = min_c;            }            break;        }    }    for(int i = 0; i &lt; s.size(); i ++)    {        if(s[i] - 'a' &lt;= max_idx)    s[i] = 'a';    }    cout &lt;&lt; s &lt;&lt; endl;}signed main(){    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);    int T;    cin &gt;&gt; T;    while(T --)    {        solve();    }    return 0;}</code></pre><h2 id="1673c-palindrome-basis">1673C- Palindrome Basis</h2><p>给定一个数n，问有多少种拼法满足n可以被若干回文数拼成</p><p>回文数指正着看和倒着看的值相同的数</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>40000</mn></mrow><annotation encoding="application/x-tex">1 \leq n \leq 40000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p><p>首先观察到n的值域很小，直觉上告诉我们40000以内的回文数数量不多（事实上只有500个左右），因此我们先将n以内的回文数预处理出来。</p><p>剩下的问题就是，如何将n用回文数拼出来，这是一个经典的DP问题</p><p>设dp[i][j]表示从前i个回文数中选，拼成的数为j的方案数</p><p>于是状态转移方程非常显然：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = dp[i - 1][j] + dp[i][j - p[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></p><p>其中p[i]表示的是第i个回文数是多少</p><p>边界：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>M</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{M - 1}dp[i][0] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2809409999999999em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，其中M - 1为回文数的个数</p><p>目标：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>M</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[M - 1][n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span></p><pre><code class="language-cpp">// Problem: C. Palindrome Basis// Contest: Codeforces - Codeforces Round #785 (Div. 2)// URL: https://codeforces.com/problemset/problem/1673/C// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 4e4 + 10, M = 510, mod = 1e9 + 7;int dp[510][N];vector&lt;int&gt; p;int reverse_i(int a){    int res = 0;    while(a &gt; 0)    {        res = res * 10 + a % 10;        a /= 10;    }    return res;}void init(){    p.push_back(0);    for(int i = 1; i &lt; N; i ++)    {        if(reverse_i(i) == i)            p.push_back(i);    }}void solve(){    for(int i = 1; i &lt; M; i ++)        dp[i][0] = 1;    for(int i = 1; i &lt; M; i ++)    {        for(int j = 1; j &lt; N; j ++)        {            if(p[i] &lt;= j)                dp[i][j] = (dp[i - 1][j] + dp[i][j - p[i]]) % mod;                else    dp[i][j] = dp[i - 1][j];        }    }}signed main(){    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);    int T;    cin &gt;&gt; T;    init();    solve();    while(T --)    {        int n;        cin &gt;&gt; n;        cout &lt;&lt; dp[M - 1][n] % mod &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="1665c-tree-infection">1665C-  Tree Infection</h2><p>给定一个n个节点的数，一开始n个节点都是健康的，每秒可以进行两种操作</p><ol><li><p>选定一个节点，将其感染</p></li><li><p>如果节点v有一个子节点被感染，那么将传播到另一个子节点</p></li></ol><p>求将所有节点传染所需的最小秒数</p><p>通过观察可以发现，任意两个不同的节点，它们的子节点互相独立，我们只关心每个节点有多少个儿子。</p><p>于是问题简化为：给定k个数，每个数表示该节点的子节点数量，每秒所有数减少1，并且你可以额外选择一个数使其减少1，求至少需要多少秒使得数组中所有数小于等于0</p><p>首先预处理出每个节点的子节点数量，将其从大到小排序并排除所有的0,</p><p>此时根据贪心，我们应该从大到小将所有子树先感染一遍，然后再次从大到小排序并排除所有小于等于0的数<br>之后，我们每次需要将数组中的所有数减1，并额外选择一个数减1，显然每次额外选择都应该选数组中最大的数，我们不断模拟这个过程，并且每次记录最大值最后出现下标last，额外操作就应当选择last对应的数，这样可以保证序列始终为单调递减。</p><pre><code class="language-cpp">// Problem: C. Tree Infection// Contest: Codeforces - Codeforces Round #781 (Div. 2)// URL: https://codeforces.com/problemset/problem/1665/C// Memory Limit: 256 MB// Time Limit: 1000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 + 10, M = N * 2;int n;int res;void calc(vector&lt;int&gt; a){    if(a.empty())    return;    int n = a.size();    int last = 0;    for(int i = 0; i &lt; n; i ++)    {        if(a[i] == a[0])    last = i;        else    break;    }    -- a[last];    for(int i = 0; i &lt; n; i ++)    a[i] --;    res ++;    while(a.size() &amp;&amp; a.back() &lt;= 0)    a.pop_back();    calc(a);}void solve(){    cin &gt;&gt; n;    vector&lt;int&gt; a(n);    for(int i = 1; i &lt; n; i ++)    {        int x;        cin &gt;&gt; x;        a[-- x] ++;    }    a.push_back(1);    sort(a.begin(), a.end(), greater&lt;int&gt;());    while(a.size() &amp;&amp; a.back() &lt;= 0) a.pop_back();    n = a.size();    res = 0;    for(int i = 0; i &lt; n; i ++)    {        a[i] = a[i] - (n - i);        res ++;    }    sort(a.begin(), a.end(), greater&lt;int&gt;());    while(a.size() &amp;&amp; a.back() &lt;= 0)    a.pop_back();    calc(a);    cout &lt;&lt; res &lt;&lt; endl;}signed main(){    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);    int T;    cin &gt;&gt; T;    while(T --)    {        solve();    }    return 0;}</code></pre><h2 id="1671d-insert-a-progression">1671D- Insert a Progression</h2><p>给定一个数组a，再给出x个正整数1-x</p><p>将这x个数插入到数组a中（可以插入到任何一个位置，包括边界）得到a‘</p><p>a’的代价为数组中所有元素差的绝对值之和，求a’的最小代价</p><p>这道题最重要的是观察出结论：设原数组最大值为a，最小值为b，一定存在一种插入方式，使得数组a’中插入了大小为[a,b]的所有数，且满足代价不变。</p><p>一种比较好理解的方式是：假设原数组a中存在相邻的两个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">a_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">a_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,不妨设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>x</mi></msub><mo>&lt;</mo><msub><mi>a</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">a_x &lt; a_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,那么我们可以尝试在这两个数之间插入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>y</mi></msub><mo>−</mo><msub><mi>a</mi><mi>x</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_y - a_x - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个正整数，而代价不变，因此所有在最值范围内的数都可以起到“桥梁”的作用。</p><p>因此我们需要先算出原数组的代价t，然后只需要看最值所覆盖的区间是否完全包含区间[1,x]</p><p>如果完全覆盖，则答案为t，否则考虑剩下的数如何放置</p><p>容易发现，除了1和x，剩下的所有数都是“桥梁”，对答案没有影响，因此我们只需要枚举1和x出现的位置，取最小值即可。</p><pre><code class="language-cpp">// Problem: D. Insert a Progression// Contest: Codeforces - Educational Codeforces Round 127 (Rated for Div. 2)// URL: https://codeforces.com/problemset/problem/1671/D// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 + 10;int a[N];int n, x;void solve(){    cin &gt;&gt; n &gt;&gt; x;    memset(a, 0, sizeof a);    int res = 0;    for(int i = 1; i &lt;= n; i ++)    {        cin &gt;&gt; a[i];        if(i &gt; 1)    res += abs(a[i] - a[i - 1]);    }    int max_num = 0, min_num = 0x3f3f3f3f;    for(int i = 1; i &lt;= n; i ++)    {        if(a[i] &gt; max_num)    max_num = a[i];        if(a[i] &lt; min_num)    min_num = a[i];    }    if(x &gt; max_num)    {        if(n == 1)        {            res += x - a[1];        }        else        {            int plus = 0x3f3f3f3f;            for(int i = 1; i &lt; n; i ++)            {                plus = min(plus, x - a[i] + x - a[i + 1] - abs(a[i + 1] - a[i]));            }            plus = min(plus, min(x - a[n], x - a[1]));            res += plus;        }        }    if(min_num != 1)    {        if(n == 1)        {            res += a[1] - 1;        }        else        {            int plus = 0x3f3f3f3f;            for(int i = 1; i &lt; n; i ++)            {                plus = min(plus, a[i] - 1 + a[i + 1] - 1 - abs(a[i + 1] - a[i]));            }            plus = min(plus, min(a[n] - 1, a[1] - 1));            res += plus;        }    }    cout &lt;&lt; res &lt;&lt; endl;}signed main(){    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);    int T;    cin &gt;&gt; T;    while(T --)    {        solve();    }    return 0;}</code></pre><h2 id="1659c-line-empire">1659C- Line Empire</h2><p>你是一个国王，你有n个国家需要占领，起初你的首都在0位置处，现在你有两种操作：</p><ol><li><p>将一个已经被占领的国家视为首都，代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><msub><mi>c</mi><mn>1</mn></msub><mo>−</mo><msub><mi>c</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">a *|c_1 - c_2|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></p></li><li><p>占领一个未被占领的国家，前提是这个国家与首都之间的所有国家都被占领，代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><msub><mi>c</mi><mn>1</mn></msub><mo>−</mo><msub><mi>c</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">b * |c_1 - c_2|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></p></li></ol><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_1,c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为两个国家的位置，求占领所有国家所需要的最小代价，最终首都可以在任何地方。</p><p>对于每个出现过的位置（包括0）我们都可以预处理出前缀和sum以及两个数组：</p><ol><li><p>以该位置为首都，之后的所有国家都采用直接占领所需要的花费<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>c</mi><mi>k</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">back[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></p></li><li><p>在该位置之前，通过交替进行占领和替换首都使得该位置成为首都所需要的花费<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">pre[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>c</mi><mi>k</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">back[i] = (sum[n] - sum[i] - (n - i) * x[i]) * b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pre[i] = x[i] * (a + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p><p>枚举所有的位置，答案即为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>p</mi><mi>r</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>b</mi><mi>a</mi><mi>c</mi><mi>k</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">min(pre[i] + back[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p></li></ol><p>为什么交替进行操作的方式一定是最优的：如果我们并没有采用交替的方式进行操作，就一定会连续进行若干次占领操作，之后仍然要通过替换操作使得首都到达目标位置，显然进行了多余的占领操作，代价变大。</p><pre><code class="language-cpp">// Problem: C. Line Empire// Contest: Codeforces - Codeforces Round #782 (Div. 2)// URL: https://codeforces.com/problemset/problem/1659/C// Memory Limit: 256 MB// Time Limit: 1000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 + 10;int n, a, b;int x[N];int sum[N];int back[N];int pre[N];void solve(){    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;    for(int i = 1; i &lt;= n; i ++)    cin &gt;&gt; x[i];    for(int i = 1; i &lt;= n; i ++)    {        sum[i] = sum[i - 1] + x[i];    }    for(int i = 0; i &lt;= n; i ++)    {        pre[i] = x[i] * (a + b);        back[i] = (sum[n] - sum[i] - (n - i) * x[i]) * b;    }    int res = 1e18;    for(int i = 0; i &lt;= n; i ++)    {        res = min(res, pre[i] + back[i]);    }    cout &lt;&lt; res &lt;&lt; endl;}signed main(){    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);    int T;    cin &gt;&gt; T;    while(T --)    {        solve();    }    return 0;}</code></pre><h2 id="1658d1-388535-easy-version">1658D1-  388535 (Easy Version)</h2><p>给定一个区间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，已知原数组是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的排列，现在给出原数组异或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>后的数组，求出任意一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的可能值</p><p>Easy Verson数据范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>=</mo><mi>l</mi><mo>≤</mo><mi>r</mi><mo>&lt;</mo><msup><mn>2</mn><mn>17</mn></msup></mrow><annotation encoding="application/x-tex">0 = l \leq r &lt; 2^{17}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></p><p>由于位运算每一位独立，我们考虑每一位按位异或的值。</p><p>对于每个二进制位，分别统计当前排列（下标）中1的个数，以及当前数组元素中1的个数，如果不相同，说明当前这一位需要进行一次异或，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的当前位为1，考虑完所有的位就得到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>.</p><pre><code class="language-cpp">// Problem: D1. 388535 (Easy Version)// Contest: Codeforces - Codeforces Round #779 (Div. 2)// URL: https://codeforces.com/problemset/problem/1658/D1// Memory Limit: 256 MB// Time Limit: 1000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = (1 &lt;&lt; 17) + 5;int l, r;int a[N];void solve(){cin &gt;&gt; l &gt;&gt; r;for(int i = l; i &lt;= r; i ++)cin &gt;&gt; a[i];int res = 0;for(int j = 0; j &lt;= 17; j ++){int cnt_idx = 0, cnt_num = 0;for(int i = l; i &lt;= r; i ++){if(i &amp; (1 &lt;&lt; j))cnt_idx ++;if(a[i] &amp; (1 &lt;&lt; j))cnt_num ++;}if(cnt_idx != cnt_num)res += 1 &lt;&lt; j;}cout &lt;&lt; res &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="1658d2-388535-hard-version">1658D2- 388535 (Hard Version)</h2><p>给定一个区间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，已知原数组是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的排列，现在给出原数组异或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>后的数组，求出任意一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的可能值</p><p>Easy Verson数据范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>r</mi><mo>&lt;</mo><msup><mn>2</mn><mn>17</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq l \leq r &lt; 2 ^ {17}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></p><p>通过观察（或许）可以发现：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>中一定存在一个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>⊕</mo><mi>x</mi><mo>=</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">a_i \oplus x = l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，于是我们可以确定存在一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>⊕</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">x = a_i\oplus l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span></p><p>由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>中的数互不相同，所以其中的数异或上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>也互不相同，我们用数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>来存储<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>⊕</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">a_i \oplus l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>的值，然后维护一个01Trie来查找<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>⊕</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i \oplus a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最大值和最小值，这个值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>需要满足最大值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，最小值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span></p><pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;#define N 1000005#define int long longusing namespace std;int T,l,r,a[N],cnt,trie[N][30],b[N];void insert(int sum){int now=0;for(int i=17;i&gt;=0;i--){bool tmp=(1&lt;&lt;i)&amp;sum;if(!trie[now][tmp])trie[now][tmp]=++cnt;now=trie[now][tmp];}}int Max(int sum){int now=0,res=0;for(int i=17;i&gt;=0;i--){bool tmp=(1&lt;&lt;i)&amp;sum;if(!trie[now][tmp^1])now=trie[now][tmp];else now=trie[now][tmp^1],res+=(1&lt;&lt;i);}return res;}int Min(int sum){int now=0,res=0;for(int i=17;i&gt;=0;i--){bool tmp=(1&lt;&lt;i)&amp;sum;if(!trie[now][tmp])now=trie[now][tmp^1],res+=(1&lt;&lt;i);else now=trie[now][tmp];}return res;}signed main() {cin&gt;&gt;T;while(T--){cin&gt;&gt;l&gt;&gt;r;for(int i=0;i&lt;=cnt;i++)trie[i][0]=trie[i][1]=0;cnt=0;for(int i=l;i&lt;=r;i++)cin&gt;&gt;a[i],b[i]=a[i]^l;for(int i=l;i&lt;=r;i++)insert(a[i]);for(int i=l;i&lt;=r;i++){if(Max(b[i])==r&amp;&amp;Min(b[i])==l){cout&lt;&lt;b[i]&lt;&lt;endl;break;}}}}</code></pre><h2 id="1651c-fault-tolerant-network">1651C- Fault-tolerant Network</h2><p>给定两个数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>，数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>相邻两个元素之间通过线相连，数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>同理，现在要将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>两个数组互相连接，连接的代价为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>b</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|a[i]-b[j]|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord">∣</span></span></span></span>要求当删除两个数组中任意一个元素时，剩下的所有元素仍然能通过线连通，且代价最小。</p><p>通过观察可以发现，想要让两个数组在删除一个任意一个数的情况下保持连通，则两个数组的开头和末尾一定要有线来连接。</p><p>假设某一个数组的开头或结尾没有数连接，那么当我们删除这个数的时候，会发现这个数一定是孤立的状态，所以上面结论成立。</p><p>进一步观察可以发现，只要保证两个数的开头或结尾处于连接状态，此时两个数组已经可以保证在删除任意数的条件下保持连通，不需要添加额外的边。因此我们只需要分别求这四个点进行连线的最小代价，最后求和即可。</p><p>本题还要注意边界问题：四个点互相连线的情况下需要特判最小值。</p><pre><code class="language-cpp">// Problem: C. Fault-tolerant Network// Contest: Codeforces - Educational Codeforces Round 124 (Rated for Div. 2)// URL: https://codeforces.com/problemset/problem/1651/C// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 + 10, INF = 2e18;int a[N], b[N];int n;void solve(){cin &gt;&gt; n;for(int i = 1; i &lt;= n; i ++)cin &gt;&gt; a[i];for(int i = 1; i &lt;= n; i ++)cin &gt;&gt; b[i];int st1 = a[1], ed1 = a[n], st2 = b[1], ed2 = b[n];int t1, t2, t3, t4;t1 = t2 = t3 = t4 = INF;int idx1, idx2, idx3, idx4;for(int i = 1; i &lt;= n; i ++){t1 = min(t1, abs(b[i] - st1));t2 = min(t2, abs(b[i] - ed1));t3 = min(t3, abs(a[i] - st2));t4 = min(t4, abs(a[i] - ed2));}int res = t1 + t2 + t3 + t4;res = min(res, min(abs(st1 - ed2) + abs(st2 - ed1), abs(st1 - st2) + abs(ed1 - ed2)));res = min(res, min(abs(st1 - st2) + t2 + t4, abs(ed1 - ed2) + t1 + t3));res = min(res, min(abs(st1 - ed2) + t2 + t3, abs(st2 - ed1) + t1 + t4));cout &lt;&lt; res &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="1646c-factorials-and-powers-of-two">1646C- Factorials and Powers of Two</h2><p>定义<strong>好数</strong>：如果某个数可以被表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">d!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mclose">!</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">2^d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span></span></span>，则这个数被称为好数</p><p>给定一个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>最少可以被拆分成多少个好数的和</p><p>数据范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq n \leq 10^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>首先任何一个正整数一定可以被拆分成若干个好数的和，因为该数一定可以由二进制表示，且最多拆为二进制中1的个数</p><p>然后可以发现，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">10^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>以内的阶乘数很少，最多只有15个</p><p>于是方法非常显然：枚举阶乘数的所有使用情况的总和，剩下的数用二进制表示，答案取最小值，采用DFS暴搜即可</p><pre><code class="language-cpp">// Problem: C. Factorials and Powers of Two// Contest: Codeforces - Codeforces Round #774 (Div. 2)// URL: https://codeforces.com/problemset/problem/1646/C// Memory Limit: 256 MB// Time Limit: 3000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 + 10;int n;int p[50], cnt;bool v[50];void init(){int t = 1;for(int i = 1; i &lt;= 15; i ++){t *= i;p[i] = t;}}int dfs(int fac, int val, int idx){if(val &lt; 0)return 1e18;else if(fac == 16){int res = 0;while(val &gt; 0){if(val &amp; 1)res ++;val &gt;&gt;= 1;}return res + idx;}else return min(dfs(fac + 1, val, idx), dfs(fac + 1, val - p[fac], idx + 1));}void solve(){int n;cin &gt;&gt; n;cout &lt;&lt; dfs(1, n, 0) &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;init();while(T --){solve();}return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces2000-2300难度部分题题解</title>
      <link href="/2022/09/05/CodeForces2000-2300%E9%9A%BE%E5%BA%A6%E9%83%A8%E5%88%86%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/09/05/CodeForces2000-2300%E9%9A%BE%E5%BA%A6%E9%83%A8%E5%88%86%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>Codeforces 2000-2300 难度题解</h1><h2 id="808g-anthem-of-berland">808G-Anthem of Berland</h2><p><strong>题目描述</strong>：给定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 串和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 串，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 串包含小写字母和问号，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 串只包含小写字母。</p><p>假设共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个问号。</p><p>你需要给把每个问号变成一个小写字母，共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mn>6</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">26^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 种可能。</p><p>对于每种可能，设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 匹配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 的次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，请输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\max(f_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。</p><p>数据范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq |s|,|t| \leq 10^5,|s|*|t| \leq 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>题解</strong>：KMP自动机：构建一个数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>u</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">aut[i][c]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span></span></span></span>，表示模式串的前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>位已经匹配完成，用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>匹配后的匹配长度</p><p>构造方式：先求出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">next</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span>数组</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>u</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mi>u</mi><mi>t</mi><mo stretchy="false">[</mo><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>t</mi><mi>i</mi></msub><mo mathvariant="normal">≠</mo><mi>c</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>+</mo><mo stretchy="false">[</mo><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><mi>c</mi><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>&lt;</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">aut[i][c] = \begin{cases}aut[next[i - 1] + 1][c],&amp;i = 1 || t_i \neq c \\i + [t_i = c],&amp;a &lt; 1\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">c</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>首先构建KMP自动机，然后考虑DP</p><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>为当前扫描到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>位，在KMP自动机上的节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>匹配的最大次数</p><p>状态转移方程：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">(</mo><mi>j</mi><mo>=</mo><mo>=</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = max(dp[i][j], dp[i - 1][j] + (j == m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>答案为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi mathvariant="normal">∣</mi><mi>t</mi><mi mathvariant="normal">∣</mi></mrow><mn>1</mn></msubsup><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum^1_{|t|} max(dp[|s|][i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4287180000000002em;vertical-align:-0.47471em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9540080000000001em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight">t</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.47471em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mn>26</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|s|*|t|*26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></p><pre><code class="language-cpp">// Problem: G. Anthem of Berland// Contest: Codeforces - Educational Codeforces Round 21// URL: https://codeforces.com/contest/808/problem/G// Memory Limit: 256 MB// Time Limit: 3000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 1e5 + 10;int n, m;int dp[2][N];int ne[N], aut[N][26];char s[N], t[N];void init_ne(){ne[1] = 0;for(int i = 2, j = 0; i &lt;= m; i ++){while(j &amp;&amp; t[i] != t[j + 1])j = ne[j];if(t[i] == t[j + 1])j ++;ne[i] = j;}}void init_KMPAM(){for(int i = 1; i &lt;= m; i ++){for(int c = 0; c &lt; 26; c ++){if(i &gt; 1 &amp;&amp; t[i] != c + 'a')aut[i][c] = aut[ne[i - 1] + 1][c];elseaut[i][c] = i + (t[i] == c + 'a');}}}void dp_KMP(){memset(dp, 0xcf, sizeof dp);//初始化负无穷dp[0][1] = 0;for(int i = 1; i &lt;= n; i ++){if(s[i] == '?'){for(int j = 1; j &lt;= m; j ++){for(int c = 0; c &lt; 26; c ++)dp[i &amp; 1][aut[j][c]] = max(dp[i &amp; 1][aut[j][c]], dp[(i - 1) &amp; 1][j] + (aut[j][c] == m));}}else{for(int j = 1; j &lt;= m; j ++)dp[i &amp; 1][aut[j][s[i] - 'a']] = max(dp[i &amp; 1][aut[j][s[i] - 'a']], dp[(i - 1) &amp; 1][j] + (aut[j][s[i] - 'a'] == m));}for(int j = 1; j &lt;= m; j ++)dp[(i - 1) &amp; 1][j] = -0x3f3f3f3f;}}void solve(){cin &gt;&gt; (s + 1) &gt;&gt; (t + 1);n = strlen(s + 1), m = strlen(t + 1);t[++ m] = '#';//加特殊字符init_ne();init_KMPAM();dp_KMP();int mmax = 0;for(int j = 1; j &lt;= m; j ++)mmax = max(mmax, dp[n &amp; 1][j]);cout &lt;&lt; mmax &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);solve();return 0;}</code></pre><h2 id="1721e-prefix-function-queries">1721E- Prefix Function Queries</h2><p><strong>题目大意</strong>：给定字符串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>,以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>个串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，求将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>分别与每个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>拼接起来后，最靠右的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>t</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|t_i|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>个前缀的border长度，每个询问相互独立</p><p>数据范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo separator="true">,</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><msub><mi>t</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">|s| \leq 10^6, q \leq 10^5, |t_i| \leq 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></p><p><strong>题解</strong>：对原串<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>求KMP自动机，每次询问在线构造<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>+</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s + t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>部分的KMP自动机，输出对应的next值即可</p><pre><code class="language-cpp">// Problem: E. Prefix Function Queries// Contest: Codeforces - Educational Codeforces Round 134 (Rated for Div. 2)// URL: https://codeforces.com/problemset/problem/1721/E// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;using namespace std;const int N = 1e6 + 10;char s[N];int ne[N], aut[N][27];int n, m;void init_next(){ne[1] = 0;for(int i = 2, j = 0; i &lt;= n; i ++){while(j &amp;&amp; s[i] != s[j + 1])j = ne[j];if(s[i] == s[j + 1])j ++;ne[i] = j;}}void init_KMPAM(){for(int i = 0; i &lt; n; i ++){for(int c = 1; c &lt;= 26; c ++){aut[i][c] = aut[ne[i]][c];}aut[i][s[i + 1] - 'a' + 1] = i;}}void solve(){int q;cin &gt;&gt; (s + 1);n = strlen(s + 1);init_next();init_KMPAM();cin &gt;&gt; q;while(q --){cin &gt;&gt; (s + n + 1);m = n + strlen(s + n + 1);for(int i = n + 1, k = ne[n]; i &lt;= m; i ++){int id = i - 1;k = aut[k][s[i] - 'a' + 1];if(s[i] == s[k + 1])k ++;ne[i] = k;cout &lt;&lt; k &lt;&lt; &quot; &quot;;for(int c = 1; c &lt;= 26; c ++)aut[id][c] = aut[ne[id]][c];aut[id][s[i] - 'a' + 1] = id;}cout &lt;&lt; endl;}}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);solve();return 0;}</code></pre><h2 id="1712d-empty-graph">1712D- Empty Graph</h2><p><strong>题目大意</strong>：给定一个长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></p><p>定义一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个点的无向完全图，点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>和点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>之间的距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><munder><mo><mi>m</mi><mi>i</mi><mi>n</mi></mo><mrow><mi>l</mi><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>r</mi></mrow></munder></mi><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\underset{l\leq i \leq r}{min} \{a[i]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.597287em;vertical-align:-0.8472869999999999em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.65952em;"><span style="top:-2.347892em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathdefault">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8472869999999999em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span></p><p>你可以进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>次操作，每次操作可以选定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1-n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>中任意一个数并将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>赋值为一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,10^9]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>的整数，请最大化这个图的直径。</p><p>图的直径定义为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><munder><mo><mi>m</mi><mi>a</mi><mi>x</mi></mo><mrow><mn>1</mn><mo>≤</mo><mi>u</mi><mo>≤</mo><mi>v</mi><mo>≤</mo><mi>n</mi></mrow></munder></mi><mi>d</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\underset{1 \leq u \leq v \leq n}{max}d(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.562287em;vertical-align:-0.812287em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.382892em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">u</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathdefault">ma</span><span class="mord mathdefault">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.812287em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>的最短路长度。</p><p><strong>题解</strong>：本题的答案具有最大值最小的性质，考虑二分答案</p><p>首先需要发现一个性质：对于两点间的最短路，最多走两条边，要么走两点直接相连的边，要么先走一个最小边走到某个点，再从这个点走到目标点 ，即</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>2</mn><mo>∗</mo><mi>m</mi><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d(u,v) = min(e(u,v),2*mmin)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">mmin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><munder><mo><mi>m</mi><mi>i</mi><mi>n</mi></mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow></munder></mi><mo stretchy="false">{</mo><mi>a</mi><mi>i</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\underset{1 \leq i \leq n}{min} \{ai\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.572843em;vertical-align:-0.822843em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.65952em;"><span style="top:-2.372336em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathdefault">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.822843em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mclose">}</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi><munder><mo><mi>m</mi><mi>i</mi><mi>n</mi></mo><mrow><mi>u</mi><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>v</mi><mo>−</mo><mn>1</mn></mrow></munder></mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(u,v) = \underset{u \leq i \leq v - 1}{min}(e(a_i,a_{i + 1}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.572843em;vertical-align:-0.822843em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.65952em;"><span style="top:-2.372336em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathdefault">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.822843em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>设图的直径为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，由此可得：</p><p class="katex-block katex-error" title="ParseError: KaTeX parse error: No such environment: align at position 7: \begin{̲a̲l̲i̲g̲n̲}̲l &amp;= max(min(e…">\begin{align}l &amp;= max(min(e(u,v), 2*mmin)) \\&amp;= min(max(e(u,v)), 2*mmin) \\&amp;= min(max(\underset{1 \leq i \leq n - 1}{min}(a_i, a_{i + 1})), 2 * mmin)\end{align}</p><p>至此我们已经知道如何二分答案：</p><p>设当前二分的答案为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>，我们需要将所有值小于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{mid}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的点赋值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>，因为这些点走两次之后依然比答案小，我们就一定要修改这些边，同时记录修改的次数</p><p>如果被修改次数大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，则显然不合法</p><p>如果被修改次数等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，我们需要求出此时的直径<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>&gt;</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">l &gt;= mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>显然合法</p><p>如果被修改次数小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，我们需要分类讨论一下：</p><p>​如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k &gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，说明我们还有更多修改余地，已经不需要修改了，那么一定合法</p><p>​如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，说明不存在小于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{mid}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的点，此时我们仅能修改一条边，观察上面的公式，我们需要求出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi><munder><mo><mi>m</mi><mi>i</mi><mi>n</mi></mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munder></mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(\underset{1 \leq i \leq n - 1}{min}(a_i, a_{i + 1}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.572843em;vertical-align:-0.822843em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.65952em;"><span style="top:-2.372336em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathdefault">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.822843em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>​换句话说，我们只需要求出是否存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>≥</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a_i \geq mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>，如果存在，我们就要把与他相邻的另一个改成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>即可。</p><pre><code class="language-cpp">// Problem: D. Empty Graph// Contest: Codeforces - Codeforces Round #813 (Div. 2)// URL: https://codeforces.com/problemset/problem/1712/D// Memory Limit: 256 MB// Time Limit: 1500 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 1e5 + 10;int n, k;bool check(vector&lt;int&gt; a, int mid, int t){for(int i = 0; i &lt; a.size(); i ++)if(a[i] * 2 &lt; mid)t --, a[i] = 1e9;if(t &lt; 0)return false;if(t == 0){for(int i = 0; i &lt; a.size() - 1; i ++)if(min(a[i], a[i + 1]) &gt;= mid)return true;}else if(t == 1)return *max_element(a.begin(), a.end()) &gt;= mid;else return true;return false;}void solve(){vector&lt;int&gt; a;cin &gt;&gt; n &gt;&gt; k;for(int i = 1; i &lt;= n; i ++){int x;cin &gt;&gt; x;a.push_back(x);}int l = 1, r = 1e9;while(l &lt; r){int mid = (l + r + 1) &gt;&gt; 1;if(check(a, mid, k))l = mid;elser = mid - 1;}cout &lt;&lt; l &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre><h2 id="1706e-qpwoeirut-and-vertices">1706E- Qpwoeirut and Vertices</h2><p><strong>题目大意</strong>：给出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>条边的不带权连通无向图，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>次询问至少要加完编号前多少的边，才能使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>中的所有点<strong>两两连通</strong>。</p><p><strong>题解</strong>：前置知识：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="pink"><mi>K</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi><mtext>重构树</mtext></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{pink}{Kruskal重构树}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;color:pink;">K</span><span class="mord mathdefault" style="margin-right:0.02778em;color:pink;">r</span><span class="mord mathdefault" style="color:pink;">u</span><span class="mord mathdefault" style="color:pink;">s</span><span class="mord mathdefault" style="margin-right:0.03148em;color:pink;">k</span><span class="mord mathdefault" style="color:pink;">a</span><span class="mord mathdefault" style="margin-right:0.01968em;color:pink;">l</span><span class="mord cjk_fallback" style="color:pink;">重</span><span class="mord cjk_fallback" style="color:pink;">构</span><span class="mord cjk_fallback" style="color:pink;">树</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Kruskal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>重构树是将一张无向图经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Kruskal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>算法得到最小生成树后，再将其重建成一颗二叉树，原图中所有的<strong>叶子结点</strong>都是原图中的点，其他点具有一个点权<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，表示左集合到右集合的边权。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Kruskal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>重构树的性质：原图中两点之间所有简单路径上最大边权的最小值=最小生成树上两个点之间的简单路径上的最大值=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Kruskal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>重构树上两点之间LCA的权值</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><msub><mi>g</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">eg_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：求节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>到节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>路径的最大边权，就是求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>A</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LCA(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>的点权</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">eg_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>:从点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>出发，给定一个值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>，在通过所有边的权值小于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>时，走过了多少个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">=&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span></span></span>从点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>向上找，找到最后一个小于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>的虚点，子树中的点都可以通过（因为重构树上的点从上往下点权单调不升）</p><p>回到这道题，结论显而易见：使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>之间两两连通的最小边权为重构树上的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">v(LCA(u,v))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>为点权。</p><p>剩下的问题是处理所有询问，我们可以采用ST表预处理所有询问，或者采用线段树。多个点的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">LCA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span></span></span></span>的求法：取出其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span></span></span></span>最小和最大的点求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">LCA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span></span></span></span>即为答案。</p><pre><code class="language-cpp">// Problem: E. Qpwoeirut and Vertices// Contest: Codeforces - Codeforces Round #809 (Div. 2)// URL: https://codeforces.com/problemset/problem/1706/E// Memory Limit: 256 MB// Time Limit: 2000 ms// Author:Ray#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 1e5 + 10, M = N * 2;struct Edge{int x, y;}e[M];struct D{int l, r, c;int fa[20];int p;int depth;}d[M];int n, m, q;int t[N * 4];void init(){for(int i = 1; i &lt;= n; i ++){memset(d[i].fa, 0, sizeof d[i].fa);d[i].p = d[i].l = d[i].r = d[i].c = 0;}}int find(int x){if(d[x].p != x)d[x].p = find(d[x].p);return d[x].p;}void merge_seg(int x, int y, int c){int px = find(x), py = find(y);if(px == py)return ;elsen ++;d[px].p = d[py].p = d[n].p = n;d[px].fa[0] = d[py].fa[0] = n;d[n].l = px, d[n].r = py, d[n].c = c;}void kruskal(){for(int i = 1; i &lt;= n; i ++)d[i].p = i;for(int i = 1; i &lt;= m; i ++)merge_seg(e[i].x, e[i].y, i);}void dfs(int x){if(x == 0)return ;d[x].depth = d[d[x].fa[0]].depth + 1;for(int i = 1; i &lt;= 18; i ++)d[x].fa[i] = d[d[x].fa[i - 1]].fa[i - 1];dfs(d[x].l);dfs(d[x].r);}int lca(int x, int y){if(d[x].depth &lt; d[y].depth)swap(x, y);for(int i = 18; i &gt;= 0; i --)if(d[d[x].fa[i]].depth &gt;= d[y].depth)x = d[x].fa[i];if(x == y)return y;for(int i = 18; i &gt;= 0; i --)if(d[x].fa[i] != d[y].fa[i]){x = d[x].fa[i];y = d[y].fa[i];}return d[y].fa[0];}int build(int x, int l ,int r){int mid = l + r &gt;&gt; 1;if(l == r)t[x] = mid;elset[x] = lca(build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r));return t[x];}int query(int x, int l, int r, int a, int b){int mid = l + r &gt;&gt; 1;if(a == l &amp;&amp; b == r)return t[x];else{if(b &lt;= mid)return query(x &lt;&lt; 1, l, mid, a, b);if(a &gt; mid)return query(x &lt;&lt; 1 | 1, mid + 1, r, a, b);return lca(query(x &lt;&lt; 1, l, mid, a, mid), query(x &lt;&lt; 1 | 1, mid + 1, r, mid + 1, b));}}void solve(){init();cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;int nn = n;for(int i = 1; i &lt;= m; i ++)cin &gt;&gt; e[i].x &gt;&gt; e[i].y;kruskal();dfs(n);build(1, 1, nn);for(int i = 1; i &lt;= q; i ++){int l, r;cin &gt;&gt; l &gt;&gt; r;cout &lt;&lt; d[query(1, 1, nn, l, r)].c &lt;&lt; &quot; &quot;;}cout &lt;&lt; endl;}signed main(){ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);int T;cin &gt;&gt; T;while(T --){solve();}return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
