<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">ACM算法模板 | Ray&#39;s Blog</title>
  
    <link rel="shortcut icon" href="https://s3.bmp.ovh/imgs/2022/09/04/c0bc4141609ace8f.jpg">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "某不科学のBlog by Ray";
  mashiro_option.author_name = "Blog by Ray";
  mashiro_option.site_url = "https://memsetray.github.io";
  mashiro_option.v_appId = "V4LQyWrCS47hAhp7YxKwbUBV-gzGzoHsz";
  mashiro_option.v_appKey = "GsZXzubUOpBDJOygIvKoskyN";
  mashiro_option.mathjax = "1";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://api.ixiaowai.cn/api/api.php".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
</html>
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/xuehua.js"></script>
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/love.js"></script>
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/sakura.js"></script>
<script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
<script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dot">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="https://memsetray.github.io">
          <img src="https://cdn.jsdelivr.net/gh/memsetray/cdn@latest/img/custom/avatar.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>Live your life with passion! With some drive!</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="http://github.com/MemsetRay" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/memsetray/cdn@latest/img/social/github.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://music.163.com/#/user/home?id=136452478" target="_blank" class="social-github" title="wangyiyun">
                    <img src="https://cdn.jsdelivr.net/gh/memsetray/cdn@latest/img/social/wangyiyun.png">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/memsetray/cdn@latest/img/social/wechat.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/memsetray/cdn@latest/img/custom/wechat.jpg">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">某不科学の</span>
            <span class="shironeko">Blog by Ray</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/题解/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          题解
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/随想/">
                          <i class="fa fa-commenting-o" aria-hidden="true"></i>
                          随想
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    清单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/bangumi/">
                          <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                          番组
                        </a>
                      </li>
                    
                      <li>
                        <a href="/music/">
                          <i class="fa fa-headphones" aria-hidden="true"></i>
                          歌单
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/links/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
                    友人帐
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我？
                        </a>
                      </li>
                    
                      <li>
                        <a href="/lab/">
                          <i class="fa fa-cogs" aria-hidden="true"></i>
                          Lab
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://s3.bmp.ovh/imgs/2022/10/18/d5cd5df136dd1f26.jpg);" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://s3.bmp.ovh/imgs/2022/10/18/d5cd5df136dd1f26.jpg">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      ACM算法模板</h1>
      <p class="entry-census">
        <span>
          <a href="sakana.icu">
            <img src="https://cdn.jsdelivr.net/gh/memsetray/cdn/img/custom/avatar.jpg">
          </a>
        </span>
        <span>
          <a href="sakana.icu">Ray</a>
        </span>
        <span class="bull">
        ·</span>
        2022-10-18<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <h1>1. 基础算法</h1>
<h4 id="1-1求逆序对数量">1.1求逆序对数量</h4>
<pre><code class="language-cpp">long long m_sort(int l,int r)
{
    if(l&gt;=r) return 0;
    int mid=l+r&gt;&gt;1;
    int i=l,j=mid+1;
    long long res=m_sort(l,mid)+m_sort(mid+1,r);
    int k=0;
    while(i&lt;=mid&amp;&amp;j&lt;=r)
    {
        if(q[i]&lt;=q[j]) temp[k++]=q[i++];
        else {
            temp[k++]=q[j++];
            res+=mid-i+1;
        }
    }
    while(i&lt;=mid)
    {
        temp[k++]=q[i++];
    }
    while(j&lt;=r) temp[k++]=q[j++];
    for(int i=l,j=0;i&lt;=r;i++,j++)
    q[i]=temp[j];
    return res;
}
</code></pre>
<h4 id="1-2-二分">1.2 二分</h4>
<pre><code class="language-cpp">while(l&lt;r)
        {
            int mid=l+r&gt;&gt;1;
            if(q[mid]&gt;=k) r=mid;        //二分，若右区间被替换，则mid为l+r&gt;&gt;1
            else l=mid+1;
        }

while(l&lt;r)
            {
                int mid=l+r+1 &gt;&gt; 1;
                if(q[mid]&lt;=k)   l=mid;      //若左区间被替换，则mid为l+r+1&gt;&gt;1
                else r=mid-1;
            }
</code></pre>
<h4 id="1-3-二维前缀和与差分与二维差分">1.3 二维前缀和与差分与二维差分</h4>
<pre><code class="language-cpp">/二维前缀和
  for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;=m;j++)
            S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j];
//一维差分
void insert(int l,int r,int c)
{
    b[l]+=c;
    b[r+1]-=c;
}

 for(int i=1;i&lt;=n;i++)
    insert(i,i,a[i]);

    while (m -- ){
        int l,r,c;
        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;
        insert(l,r,c);
    }

    for(int i=1;i&lt;=n;i++)
    b[i]+=b[i-1];

//二维差分
void insert(int x1,int y1,int x2,int y2,int c)
{
    b[x1][y1]+=c;
    b[x2+1][y1]-=c;
    b[x1][y2+1]-=c;
    b[x2+1][y2+1]+=c;
}


for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            insert(i,j,i,j,a[i][j]);

    while (q -- ){
        int x1,y1,x2,y2,c;
        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;
        insert(x1,y1,x2,y2,c);
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];
</code></pre>
<h4 id="1-4-双指针典例">1.4 双指针典例</h4>
<h5 id="1-4-1-最长连续不重复子序列">1.4.1 最长连续不重复子序列</h5>
<pre><code class="language-cpp">int res=0;
    for(int i=0,j=0;i&lt;n;i++)
    {
        s[a[i]]++;
        while(s[a[i]]&gt;1)
        {
            s[a[j]]--;
            j++;
        }
        res=max(res,i-j+1);
    }
</code></pre>
<h5 id="1-4-2-判断a是否为b的子序列-1e5">1.4.2 判断a是否为b的子序列（1e5）</h5>
<pre><code class="language-cpp">    int i=0,j=0;
    while( i&lt;n &amp;&amp;j &lt; m)
    {
        if(a[i]==b[j])  i++;;
        j++;
    }
</code></pre>
<h4 id="1-5-需要保序的离散化">1.5 需要保序的离散化</h4>
<pre><code class="language-cpp">typedef pair&lt;int, int&gt; PII;         //每一次操作都是一个二元组，这里用pair


int n,m;
int a[N],s[N];
vector &lt;int&gt; alls;          //alls数组内存的是所有需要进行离散化的数以及进行完离散化之后的数组
vector&lt;PII&gt; add,query;          //add数组内存的是每次对数的操作，query数组内存的是每次询问的左右区间

int find (int x)            //查找离散化后数组的下标
{
    int l = 0, r = alls.size()-1;       
    while(l &lt; r)
    {
        int mid = (l+r) &gt;&gt; 1;
        if(alls[mid] &gt;= x)  r = mid;        //当该下标对应的值为待查找值（离散化前的大数）时，返回下标+1（为了从1开始便于求前缀和）
        else l = mid + 1;
    }
    return r + 1;
}


int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=0;i &lt; n ; i++)
    {
        int x , c;
        scanf(&quot;%d%d&quot;,&amp;x, &amp;c);

        add.push_back({x,c});   //把对原数组的操作存放进去,即把x加上c

        alls.push_back(x);      //将需要进行离散化的数存到alls里
    }
    for(int i = 0; i &lt; m; i++)
            {
                int l, r;
                scanf(&quot;%d%d&quot;,&amp;l, &amp;r);
                query.push_back({l, r});        //把每次询问存放进去，即存放需要求和的左右区间
                alls.push_back(l);          //由于l,r也可能是大数，因此我们也需要将l和r进行离散化
                alls.push_back(r);
            }

    //此处是离散化的核心，即进行离散化的过程
    sort(alls.begin(), alls.end());             //将需要离散化的数组进行排序
    alls.erase(unique(alls.begin(), alls.end()),alls.end());    //去重，目的是将数组中的存放的数量减少，节省内存空间

    for(auto it : add)          
    {
        int x = find(it.first);         //寻找被加的数进行离散化之后的下标
        a[x] += it.second;              //求离散化后的数组a
    }

    for(int i=1;i&lt;=alls.size(); i++)
    s[i] = s[i-1] + a[i];               //求离散化后数组的前缀和

    for(auto it : query) {                  //处理每次询问
        int l = find(it.first);                 //寻找左区间进行离散化之后的下标
        int r = find(it.second);                //寻找右区间进行离散化之后的下标
        printf(&quot;%d\n&quot; ,s[r]-s[l-1]);             //求区间和
    }

    return 0;
}
</code></pre>
<h4 id="1-6-不需要保序的离散化">1.6 不需要保序的离散化</h4>
<pre><code class="language-cpp">//待补充
</code></pre>
<h4 id="1-7-区间合并">1.7 区间合并</h4>
<pre><code class="language-cpp">vector&lt;PII&gt; segs;

void merge(vector&lt;PII&gt; &amp;segs)
{
    vector&lt;PII&gt; res;
    sort(segs.begin(), segs.end());
    int st = -2e9, ed = -2e9;
    for(auto seg : segs)
    {
        if(ed &lt; seg.first)
        {
            if(st != -2e9)    
            res.push_back({st , ed});
            st = seg.first;
            ed = seg.second;
        }   
        else
        ed=max(ed , seg.second);
    }    
        if(st != -2e9)  res.push_back({st , ed});

        segs=res;


}

int main()
{
    int n;
    cin&gt;&gt;n;
    for(int i = 0;i &lt; n; i++ )
    {
        int l , r;
        cin&gt;&gt;l&gt;&gt;r;
        segs.push_back({l,r});
    }

    merge(segs);

    cout&lt;&lt;segs.size()&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="1-8-区间最值问题-rmq">1.8 区间最值问题（RMQ）</h4>
<pre><code class="language-cpp">int w[N];
int f[N][M];
int n, m;

void init()
{
    for(int j = 0; j &lt; M; j ++)     //先枚举区间长度
    {
        for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++)      //枚举区间左端点
        {
            if(!j)  f[i][j] = w[i];
            else    f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; j - 1)][j - 1]);
        }
    }
}

int query(int l, int r)
{
    int len = r - l + 1;
    int k = log(len) / log(2);

    return max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);        //这两个区间一定覆盖查询区间
}

int main()
{
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i ++)
        cin &gt;&gt; w[i];

    init();
    cin &gt;&gt; m;
    while (m -- )
    {
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        cout &lt;&lt; query(l, r) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h4 id="1-9-manacher算法">1.9 manacher算法</h4>
<pre><code class="language-cpp">int n;
char a[N], b[N];
int p[N];
int res;

void init()
{
    int k = 0;
    b[k ++] = '$';
    b[k ++] = '#';
    for(int i = 0; i &lt; n; i ++)
    {
        b[k ++] = a[i];
        b[k ++] = '#';
    }
    b[k ++] = '^';
    n = k;
}

void manacher()
{
    int mr = 0, mid;
    for(int i = 1; i &lt; n; i ++)
    {
        if(i &lt; mr)
            p[i] = min(p[mid * 2 - i], mr - i);
        else p[i] = 1;
        while(b[i - p[i]] == b[i + p[i]])   p[i] ++;
        if(i + p[i] &gt; mr)
        {
            mr = i + p[i];
            mid = i;
        }
    }
}

int main()
{
    scanf(&quot;%s&quot;, a);
    n = strlen(a);

    init();
    manacher();

    for(int i = 0; i &lt; n; i ++)
        res = max(res, p[i]);

    cout &lt;&lt; res - 1 &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="1-10-最小表示法">1.10 最小表示法</h4>
<pre><code class="language-cpp">//用于求字符串的最小表示，可以用来判断两个环形字符串是否是同一个字符串
int get_min(char s[])
{
    int i = 0, j = 1;
    while(i &lt; n &amp;&amp; j &lt; n)
    {
        int k = 0;
        while(k &lt; n &amp;&amp; s[i + k] == s[j + k])    k ++;
        if(k == n)  break;
        if(s[i + k] &gt; s[j + k]) i += k + 1;
        else j += k + 1;
        if(i == j)  j ++;
    }
    int k = min(i, j);
    s[k + n] = 0;
    return k;
}

int main()
{
    cin &gt;&gt; a &gt;&gt; b;
    n = strlen(a);
    memcpy(a + n, a, n);
    memcpy(b + n, b, n);
    int x = get_min(a);
    int y = get_min(b);
    if(strcmp(a + x, b + y))    cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    else
    {
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        cout &lt;&lt; a + x &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h4 id="1-11-对顶堆维护动态中位数">1.11 对顶堆维护动态中位数</h4>
<pre><code class="language-cpp">/*
对顶堆，维护一个大根堆和一个小根堆，对于每个元素，如果大根堆为空或小于大根堆顶，则插入大根堆，否则插到小根堆，这两个堆需要时刻满足：
序列中从小到大排名为1 ~ M / 2 + 1的整数在大根堆中
序列中从小到大排名为M / 2 + 2 ~ M的整数存储在小根堆中
如果不满足，就把多出来的数放到另一个堆，由此序列的中位数一定是大根堆的堆顶
*/
int main()
{
    int T;
    cin &gt;&gt; T;
    while(T --)
    {
        priority_queue&lt;int&gt; b_heap;
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; s_heap;
        int n, m;
        cin &gt;&gt; n &gt;&gt; m;
        cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; (m + 1 &gt;&gt; 1) &lt;&lt; endl;
        int cnt = 0;
        for(int i = 0; i &lt; m; i ++)
        {
            int x;
            cin &gt;&gt; x;
            if(b_heap.empty() || x &lt;= b_heap.top()) //大根堆为空或x小于大根堆顶，插入大根堆
                b_heap.push(x);
            else    s_heap.push(x);     //否则插入小根堆

            if(b_heap.size() &gt; s_heap.size() + 1)
            {
                s_heap.push(b_heap.top());
                b_heap.pop();
            }

            if(s_heap.size() &gt; b_heap.size())
            {
                b_heap.push(s_heap.top());
                s_heap.pop();
            }

            if(i % 2 == 0)
            {
                cout &lt;&lt; b_heap.top() &lt;&lt; &quot; &quot;;
                if(++ cnt % 10 == 0)    cout &lt;&lt; endl;
            }
        }
        if(cnt % 10)    cout &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h4 id="1-12-二进制状态压缩求最短hamilton路径">1.12 二进制状态压缩求最短Hamilton路径</h4>
<pre><code class="language-cpp">int n;
int w[N][N];                            //用w来存储整个图
int f[M][N];                            //f[i][j]表示从0走到j，走过的点为i的所有路径长度，i是一个20位二进制数，如果第k位为1，表示这个点已经走过了

int main()
{
    cin &gt;&gt; n;                           //n个点
    for(int i = 0; i &lt; n; i ++)         
    {
        for(int j = 0; j &lt; n; j ++)
            cin &gt;&gt; w[i][j];             //输入n个点
    }

    memset(f, 0x3f, sizeof f);          //初始化路径长度为无穷大
    f[1][0] = 0;                        //初始化0号点的路径长度为0
    for(int i = 0; i &lt; 1 &lt;&lt; n; i ++)    //枚举所有的状态
        for(int j = 0; j &lt; n; j ++)
            if(i &gt;&gt; j &amp; 1)              //从0走到j时，i中一定要包含j，即i的第j位一定为1
                for(int k = 0; k &lt; n; k ++)             //枚举j点从哪一个点转移过来
                    if((i - (1 &lt;&lt; j)) &gt;&gt; k &amp; 1)         //如果i除去第j个点之后包含第k个点
                        f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j]);   //那么当前的状态就是从0走到k加上k走到j的所有路径取最小值

    cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;             //输出走完所有的点，并且走到n-1号点时的距离
    return 0;
}
</code></pre>
<h1>2. 数据结构</h1>
<h4 id="2-1-单调栈">2.1 单调栈</h4>
<pre><code class="language-cpp">//用于寻找一个数左边最近的比它大（小）的数
int stk[N],tt;
int main()
{
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
    {
        int x;
        cin&gt;&gt;x;
        while(tt &amp;&amp; stk[tt]&gt;=x) tt--;
        if(tt)      cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;;
        else        cout&lt;&lt;&quot;-1&quot;&lt;&lt;&quot; &quot;;

        stk[++tt] = x;

    }
    return 0;
}
</code></pre>
<h4 id="2-2-单调队列-滑动窗口">2.2 单调队列（滑动窗口）</h4>
<pre><code class="language-cpp">//维护区间内最大值和最小值
int n,k;
int a[N],q[N];

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
    for(int i=0;i&lt;n;i++)
    scanf(&quot;%d&quot;,&amp;a[i]);

    int hh=0,tt=-1;
    for(int i=0;i&lt;n;i++)
    {
        //首先判断队头是否滑出滑动窗口
        if(hh &lt;=tt   &amp;&amp; i - k + 1 &gt; q[hh])  hh++;
        while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;
        q[++tt] = i;
        if(i &gt;= k-1)
        printf(&quot;%d &quot;,a[q[hh]]);
    }
    puts(&quot;&quot;);

    hh = 0, tt = -1;
    for(int i=0;i&lt;n;i++)
    {
        //首先判断队头是否滑出滑动窗口
        if(hh &lt;=tt   &amp;&amp; i - k + 1 &gt; q[hh])  hh++;
        while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;
        q[++tt] = i;
        if(i &gt;= k - 1)
        printf(&quot;%d &quot;,a[q[hh]]);
    }
    puts(&quot;&quot;);

    return 0;
}
</code></pre>
<h4 id="2-3-kmp算法">2.3 KMP算法</h4>
<pre><code class="language-cpp">/*
KMP算法是一种在模式串中寻找给定模板串的一种算法，该算法的时间复杂度为O(M+N)，相较于暴力算法，该算法最大的特点是模板串指针不需要回溯即可判断两个串是否匹配

该算法需要注意的几个地方

1. next数组的含义：next[i]的含义为：当当前模式串与模板串的元素不匹配时，当前元素之前的模板串的元素中，前缀与后缀相同的最大串长度
2. 求next数组时，next数组从下标2开始求，因为next[0]和next[1]的值均为0,
3. 进行kmp匹配时，从i下标1开始，j从下标0开始
4. p数组和s数组均从下标1开始存放元素
*/
int n,m;
char p[N], s[M];

int ne[N];

int main()
{
    cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1;    //p数组和s数组均从下标1开始存放元素

    //求next数组的过程
    for(int i = 2 ,j = 0; i &lt;= n ; i++ )
    {
        while(j &amp;&amp; p[i] != p[j+1])  j=ne[j];    //前缀与后缀不同时，记录前缀与后缀相同时的长度
        if(p[i] == p[j+1])  j++;        //如果前缀和后缀相同，那么ij继续右移，判断更大的前缀后缀是否相同
        ne[i] = j;     //next数组的含义是:当当前模式串与模板串的元素不匹配时，当前元素之前的模板串的元素中，前缀与后缀相同的最大串长度
    }

    //kmp的匹配过程
    for(int i = 1, j = 0; i &lt;= m; i ++)
    {
        while(j &amp;&amp; s[i] != p[j+1])  j = ne[j];      //当模板串与模式串不匹配时，将模板串右移ne[j]的距离
        if(s[i] == p[j+1])  j++;        //如果模板串与模式串匹配，那么就将它们的下一位进行匹配
        if(j == n)      //如果模板串所有的字符都被匹配了，那么匹配成功
        {
            printf(&quot;%d &quot;,i-n);
            j=ne[j];
        }
    }
    return 0;
}
</code></pre>
<h4 id="2-4-trie统计字符串">2.4 Trie统计字符串</h4>
<pre><code class="language-cpp">//son数组第一维表示n号节点，第二维表示它的第几个儿子
int son[N][26],cnt[N],idx;
char str[N];

void insert(char str[])
{
    int p=0;
    for(int i=0 ; str[i] ; i++)
    {
        int u = str[i] - 'a';           //将字母映射到下标
        if(!son[p][u])      son[p][u]=++idx;        //如果该节点的儿子不存在，那么就将它加入进去
        p=son[p][u];            //转到p号节点的u号儿子
    }
    cnt[p]++;           //出现次数+1
}

int query(char str[])
{
    int p=0;
    for(int i=0;str[i];i++)
    {
        int u = str[i] - 'a';
        if(!son[p][u])  return 0;
        p = son[p][u];
    }
    return cnt[p];
}

int main()
{
    int n;
    cin&gt;&gt;n;
    while (n -- ){
        char op[2];
        scanf(&quot;%s%s&quot;,op,str);
        if(op[0] == 'I')    insert(str);
        else printf(&quot;%d\n&quot;, query(str));
    }
    return 0;
}
</code></pre>
<h4 id="2-5-并查集带维护集合大小">2.5 并查集带维护集合大小</h4>
<pre><code class="language-cpp">int find(int x)  // 并查集
{
    if(p[x] != x)   p[x] = find(p[x]);
    return p[x];
}


int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
    p[i]=i;
    siz[i]=1;
    }
    cin&gt;&gt;m;
    while (m -- )
    {
        char op[5];
        int a,b;

        scanf(&quot;%s&quot;,op);
        if(op[0] == 'C')
        {
             scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            if(find(a) == find(b))  continue;
            siz[find(b)] += siz[find(a)];
            p[find(a)] = find(b); 

        }

        else if(op[1] == '1')
        {
             scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            if(find(a) == find(b))
            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;
            else
            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;
        }

        else if(op[1] == '2')
        {
             scanf(&quot;%d&quot;,&amp;a);
             cout&lt;&lt;siz[find(a)]&lt;&lt;endl;
        }
    }
    return 0;
}
</code></pre>
<h4 id="2-6-拓展域并查集-拆点">2.6 拓展域并查集（拆点）</h4>
<pre><code class="language-cpp">int find(int x)
{
    if(p[x] != x)   p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin &gt;&gt; n &gt;&gt; k;
    int res = 0;

    for(int i = 1; i &lt;= 3 * n; i ++)    p[i] = i;

    while(k --)
    {
        int d, x, y;
        cin &gt;&gt; d &gt;&gt; x &gt;&gt; y;
        int xs = x, xe = x + n, xy = x + 2 * n;
        int ys = y, ye = y + n, yy = y + 2 * n;

        if(d == 1)
        {
            if(x &gt; n || y &gt; n)  res ++;
            else if(find(xs) == find(yy))   res ++;
            else if(find(ye) == find(xs))   res ++;
            else
            {
                p[find(xs)] = find(ys);
                p[find(xe)] = find(ye);
                p[find(xy)] = find(yy);
            }
        }

        if(d == 2)
        {
            if(x &gt; n || y &gt; n)  res ++;
            else if(x == y) res ++;
            else if(find(xs) == find(ys))   res ++;
            else if(find(ye) == find(xs))   res ++;
            else
            {
                p[find(xe)] = find(ys);
                p[find(xs)] = find(yy);
                p[find(xy)] = find(ye);
            }
        }

    }

    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="2-7-手写堆排序">2.7 手写堆排序</h4>
<pre><code class="language-cpp">int h[N];
int n,m;
int siz;

void down(int u)
{
    int t = u;                  //t为最小值
    if(u * 2 &lt;= siz &amp;&amp; h[u * 2] &lt; h[t])    t = u * 2;                  //如果左儿子存在并且左儿子的值小于父节点的值，那么最小值更新为左儿子
    if(u * 2 + 1 &lt;= siz &amp;&amp; h[u * 2 + 1] &lt; h[t])  t = u * 2 + 1;        //如果右儿子存在并且右儿子的值小于父节点的值，那么最小值更新为右儿子
    if(u != t)                          //如果传入的值不是最小值，那么将该值与最小值互换，然后递归将该值放入堆中
    {
        swap(h[u], h[t]);
        down(t);
    }
}


void up(int u)
{
   while(u / 2 &amp;&amp; h[u / 2] &gt; h[u])
   {
       swap(h[u / 2], h[u]);
       u /= 2;
   }

}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)
    scanf(&quot;%d&quot;, &amp;h[i]);
    siz = n;

    for(int i = n / 2; i; i--)
    down(i);

    while (m -- )
    {
            cout &lt;&lt; h[1] &lt;&lt; &quot; &quot;;
            h[1] = h[siz];
            siz--;
            down(1);
    }

    return 0;
}
</code></pre>
<h4 id="2-8-字符串哈希">2.8 字符串哈希</h4>
<pre><code class="language-cpp">//用于判断两个区间内的字符串是否完全相同
typedef unsigned long long ULL;
const int N = 1e5 + 5, P = 131;
ULL h[N], p[N];

ULL query(int l, int r)
{
    return  h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    string x;
    cin &gt;&gt; x;
    p[0] = 1;
    h[0] = 0;
    for(int i = 0; i &lt; n; i ++)
    {
        p[i + 1] = p[i] * P;
        h[i + 1] = h[i] * P + x[i];
    }

    while(m --)
    {
        int l1, r1, l2, r2;
        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;
        if(query(l1, r1) == query(l2, r2))
            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h4 id="2-9-树状数组">2.9 树状数组</h4>
<h5 id="2-9-1-区间修改-单点查询">2.9.1 区间修改，单点查询</h5>
<pre><code class="language-cpp">LL tr[N];
int a[N];
int n, m;

int lowbit(int x)
{
    return x &amp; -x;
}

void add(int x, int c)
{
    for(int i = x; i &lt;= n; i += lowbit(i))
    tr[i] += c;
}

LL sum(int x)
{
    LL res = 0;
    for(int i = x; i ; i -= lowbit(i))
    res += tr[i];
    return res;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n ; i ++)
    cin &gt;&gt; a[i];
    for(int i = 1; i &lt;= n ;i ++)
    {
        add(i, a[i] - a[i - 1]);
    }

    while(m --)
    {
        char op[2];
        int l;
        scanf(&quot;%s%d&quot;, op, &amp;l);
        if(op[0] == 'C')
        {
            int r, d;
            cin &gt;&gt; r &gt;&gt; d;
            add(l, d);
            add(r + 1, -d);
        }
        else
        cout &lt;&lt; sum(l) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h5 id="2-9-2-单点修改-区间查询">2.9.2 单点修改，区间查询</h5>
<pre><code class="language-cpp">int lowbit(int x)
{
    return x &amp; -x;
}

void add(int x, int c)
{
    for(int i = x; i &lt;= n; i += lowbit(i))
    tr[i] += c;    
}

int sum(int x)
{
    int res = 0;
    for(int i = x; i; i -= lowbit(i))  res += tr[i];
    return res;
}
</code></pre>
<h5 id="2-9-3-区间修改-区间查询">2.9.3 区间修改，区间查询</h5>
<pre><code class="language-cpp">int a[N];
LL tr1[N], tr2[N];
int n, m;

int lowbit(int x)
{
    return x &amp; -x;
}

void add(LL tr[], int x, LL c)
{
    for(int i = x; i &lt;= n; i += lowbit(i))
    tr[i] += c;
}

LL sum(LL tr[], int x)
{
    LL res = 0;
    for(int i = x; i; i -= lowbit(i))
    res += tr[i];
    return res;
}

LL pre_sum(int x)                       //求原数组的前缀和
{
    return sum(tr1, x) * (x + 1) - sum(tr2, x);
}


int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++)
    cin &gt;&gt; a[i];

    for(int i = 1; i &lt;= n; i ++)
    {
        int b = a[i] - a[i - 1];
        add(tr1, i, b);
        add(tr2, i, (LL)b * i);
    }

    while(m --)
    {
        char op[2];
        int l ,r, d;
        scanf(&quot;%s%d%d&quot;, op, &amp;l, &amp;r);
        if(op[0] == 'Q')
        printf(&quot;%lld\n&quot;, pre_sum(r) - pre_sum(l - 1));          //原数组的区间查询
        else
        {
            cin &gt;&gt; d;
            add(tr1, l, d), add(tr2, l, l * d);
            add(tr1, r + 1, -d), add(tr2, r + 1, (r + 1) * -d);
        }
    }
    return 0;
}
</code></pre>
<h4 id="2-10-线段树">2.10 线段树</h4>
<h5 id="2-10-1-单点修改-区间查询">2.10.1  单点修改，区间查询</h5>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2e5 + 10;
 
struct info
{
	int minv, cnt_min;
};
 
struct Node
{
	info val;
}tr[N * 4];
int n, q;
int a[N];
 
info operator + (const info &amp;l, const info &amp;r)
{
	info a;
	a.minv = min(l.minv, r.minv);
	if(l.minv == r.minv)	a.cnt_min = l.cnt_min + r.cnt_min;
	else if(l.minv &lt; r.minv)	a.cnt_min = l.cnt_min;
	else	 a.cnt_min = r.cnt_min;
	return a;
}
 
void pushup(int u)
{
	tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val;
}
 
void build(int u, int l, int r)
{
	if(l == r)	tr[u].val = {a[l], 1};
	else
	{
		int mid = l + r &gt;&gt; 1;
		build(u &lt;&lt; 1, l, mid);
		build(u &lt;&lt; 1 | 1, mid + 1, r);
		pushup(u);
	}
}
 
void change(int u, int l, int r, int pos, int val)
{
	if(l == r)	tr[u].val = {val, 1};
	else
	{
		int mid = l + r &gt;&gt; 1;
		if(pos &lt;= mid)	change(u &lt;&lt; 1, l, mid, pos, val);
		else	change(u &lt;&lt; 1 | 1, mid + 1, r, pos, val);
		pushup(u);
	}
}
 
info query(int u, int l, int r, int ql, int qr)
{
	if(l == ql &amp;&amp; r == qr)	return tr[u].val;
	int mid = l + r &gt;&gt; 1;
	if(qr &lt;= mid)	return query(u &lt;&lt; 1, l, mid, ql, qr);
	else if(ql &gt; mid)	return query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
	else
	{
		return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr);
	}
	
}
 
int main()
{
	scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
	for(int i = 1; i &lt;= n; i ++)	scanf(&quot;%d&quot;, &amp;a[i]);
	build(1, 1, n);
	while(q --)
	{
		int a, b, c;
		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
		if(a == 1)
		{
			change(1, 1, n, b, c);
		}
		else
		{
			auto a = query(1, 1, n, b, c);
			printf(&quot;%d %d\n&quot;, a.minv, a.cnt_min);
		}
	}
}

</code></pre>
<h5 id="2-10-2-区间最大公约数-区间修改-区间查询">2.10.2 区间最大公约数（区间修改，区间查询）</h5>
<pre><code class="language-cpp">struct Node{
    int l, r;
    LL sum, d;
}tr[N * 4];

LL a[N];

LL gcd(LL a, LL b)
{
    return b ? gcd(b, a % b) : a;
}

void build(int u, int l, int r)
{
    if(l == r)
    {
        LL b = a[r] - a[r - 1];
        tr[u] = {l, l, b, b};
    }
    else
    {
        tr[u] = {l ,r};
        int mid = l + r &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid);
        build(u &lt;&lt; 1 | 1, mid + 1, r);
        tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
        tr[u].d = gcd(tr[u &lt;&lt; 1].d, tr[u &lt;&lt; 1 | 1].d);
    }
}

Node query(int u, int l, int r)
{
    if(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)    return tr[u];
    else
    {
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        if(r &lt;= mid)    return  query(u &lt;&lt; 1, l, r);
        if(l &gt; mid)    return query(u &lt;&lt; 1 | 1, l, r);
        else
        {
            auto left = query(u &lt;&lt; 1, l, r);
            auto right = query(u &lt;&lt; 1 | 1, l, r);
            Node res;
            res.sum = left.sum + right.sum;
            res.d = gcd(left.d, right.d);

            return res;
        }
    }
}

void modify(int u, int x, LL c)
{
    if(tr[u].l == x &amp;&amp;  tr[u].r == x)
    {
        LL b = tr[u].sum + c;
        tr[u] = {x, x, b, b};
    }
    else
    {
        int mid = tr[u].l +tr[u].r &gt;&gt; 1;
        if(x &lt;= mid)    modify(u &lt;&lt; 1, x, c);
        else    modify(u &lt;&lt; 1 | 1, x, c);
        tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
        tr[u].d = gcd(tr[u &lt;&lt; 1].d, tr[u &lt;&lt; 1 | 1].d);
    }
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++)
        cin &gt;&gt; a[i];

    build(1, 1, n);

    char op[2];
    while(m --)
    {
        int l, r;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
        if(op[0] == 'C')
        {
            LL d;
            cin &gt;&gt; d;
            modify(1, l, d);
            if(r + 1 &lt;= n)
                modify(1, r + 1, -d);
        }
        else
        {
            auto left = query(1, 1, l);
            Node right({0, 0, 0, 0});
            if(l + 1 &lt;= r)    right = query(1, l + 1, r);
            cout &lt;&lt; abs(gcd(left.sum, right.d)) &lt;&lt; endl;
        }
    }

    return 0;
}
</code></pre>
<h5 id="2-10-3-带懒标记的区间修改-区间查询">2.10.3 带懒标记的区间修改，区间查询</h5>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2e5 + 10;
typedef long long ll;
ll n, q;
ll a[N];
 
struct info
{
	ll maxv;
};
 
struct tag
{
	ll add;
};
 
info operator + (const info &amp;l, const info &amp;r)
{
	return {max(l.maxv, r.maxv)};
}
 
info operator + (const info &amp;v, const tag &amp;t)
{
	return {v.maxv + t.add};
}
 
tag operator + (const tag &amp;t1, const tag &amp;t2)
{
	return {t1.add + t2.add};
}
 
struct node
{
	tag t;
	info val;
}tr[N * 4];
 
void pushup(int u)
{
	tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val;
}
 
void settag(int u, tag t)
{
	tr[u].val = tr[u].val + t;
	tr[u].t = tr[u].t + t;
}
 
void pushdown(int u)
{
	if(tr[u].t.add != 0)
	{
		settag(u &lt;&lt; 1, tr[u].t);
		settag(u &lt;&lt; 1 | 1, tr[u].t);
		tr[u].t.add = 0;
	}
}
 
void build(int u, int l, int r)
{
	if(l == r)	tr[u].val = {a[l]};
	else
	{
		ll mid = l + r &gt;&gt; 1;
		build(u &lt;&lt; 1, l, mid);
		build(u &lt;&lt; 1 | 1, mid + 1, r);
		pushup(u);
	}
}
 
void modify(int u, int l, int r, int ql, int qr, tag t)
{
	if(l == ql &amp;&amp; r == qr)
	{
		settag(u, t);
		return ;
	}
	ll mid = l + r &gt;&gt; 1;
	pushdown(u);
	if(qr &lt;= mid)	modify(u &lt;&lt; 1, l, mid, ql, qr, t);
	else if(ql &gt; mid)	modify(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr, t);
	else
	{
		modify(u &lt;&lt; 1, l, mid, ql, mid, t);
		modify(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr, t);
	}
	pushup(u);
}
 
info query(int u, int l, int r, int ql, int qr)
{
	if(l == ql &amp;&amp; r == qr)
		return tr[u].val;
	ll mid = l + r &gt;&gt; 1;
	pushdown(u);
	if(qr &lt;= mid)	query(u &lt;&lt; 1, l, mid, ql, qr);
	else if(ql &gt; mid)	query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr);
	else
	{
		return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr);
	}
}
 
int main()
{
	scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
	for(int i = 1; i &lt;= n; i ++)	scanf(&quot;%d&quot;, &amp;a[i]);
	build(1, 1, n);
	while(q --)
	{
		int op;
		scanf(&quot;%d&quot;, &amp;op);
		if(op == 1)
		{
			int l, r, d;
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d);
			modify(1, 1, n, l, r, (tag){d});
		}
		else
		{
			int l, r;
			scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
			auto a = query(1, 1, n, l, r);
			printf(&quot;%lld\n&quot;, a.maxv);
		}
	}
	return 0;
}

</code></pre>
<h5 id="2-10-4-扫描线求矩形的面积并">2.10.4 扫描线求矩形的面积并</h5>
<pre><code class="language-cpp">struct Segment
{
    double x, y1, y2;
    int k;
    bool operator&lt; (const Segment &amp;t)const
    {
        return x &lt; t.x;
    }
}seg[N * 2];
struct Node
{
    int l, r;
    int cnt;
    double len;
}tr[N * 8];

vector&lt;double&gt; ys;

int find(double y)
{
    return lower_bound(ys.begin(), ys.end(), y) - ys.begin();
}

void pushup(int u)
{
    if (tr[u].cnt) tr[u].len = ys[tr[u].r + 1] - ys[tr[u].l];
    else if (tr[u].l != tr[u].r)
    {
        tr[u].len = tr[u &lt;&lt; 1].len + tr[u &lt;&lt; 1 | 1].len;
    }
    else tr[u].len = 0;
}

void build(int u, int l, int r)
{
    tr[u] = {l, r, 0, 0};
    if (l != r)
    {
        int mid = l + r &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
    }
}

void modify(int u, int l, int r, int k)
{
    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)
    {
        tr[u].cnt += k;
        pushup(u);
    }
    else
    {
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, k);
        if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, k);
        pushup(u);
    }
}

int main()
{
    int T = 1;
    while (scanf(&quot;%d&quot;, &amp;n), n)
    {
        ys.clear();
        for (int i = 0, j = 0; i &lt; n; i ++ )
        {
            double x1, y1, x2, y2;
            scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
            seg[j ++ ] = {x1, y1, y2, 1};
            seg[j ++ ] = {x2, y1, y2, -1};
            ys.push_back(y1), ys.push_back(y2);
        }

        sort(ys.begin(), ys.end());
        ys.erase(unique(ys.begin(), ys.end()), ys.end());

        build(1, 0, ys.size() - 2);

        sort(seg, seg + n * 2);

        double res = 0;
        for (int i = 0; i &lt; n * 2; i ++ )
        {
            if (i &gt; 0) res += tr[1].len * (seg[i].x - seg[i - 1].x);
            modify(1, find(seg[i].y1), find(seg[i].y2) - 1, seg[i].k);
        }

        printf(&quot;Test case #%d\n&quot;, T ++ );
        printf(&quot;Total explored area: %.2lf\n\n&quot;, res);
    }

    return 0;
}
</code></pre>
<h5 id="2-10-5-动态开点与权值线段树">2.10.5 动态开点与权值线段树</h5>
<pre><code class="language-cpp">//待补充
</code></pre>
<h4 id="2-11-可持久化数据结构">2.11 可持久化数据结构</h4>
<h5 id="2-11-1-可持久化trie">2.11.1 可持久化Trie</h5>
<pre><code class="language-cpp">//支持两种操作：末尾添加一个数，求一个位置p，使得p在l-r之间，且a[p] xor ... xor a[n] xor x的值最大
int tr[M][2], max_id[M];
int root[N];
int n, m, idx;
int s[N];

void insert(int i, int k, int p, int q) //i为前缀和下标，k为当前第几位，p为上一个版本，q为当前版本
{
    if(k &lt; 0)
    {
        max_id[q] = i;
        return ;
    }
    int v = s[i] &gt;&gt; k &amp; 1;
    if(p)   tr[q][v ^ 1] = tr[p][v ^ 1];
    tr[q][v] =  ++ idx;
    insert(i, k - 1, tr[p][v], tr[q][v]);
    max_id[q] = max(max_id[tr[q][0]], max_id[tr[q][1]]);
}

int query(int root, int c, int l)
{
    int p = root;
    for(int i = 23; i &gt;= 0; i --)
    {
        int v = c &gt;&gt; i &amp; 1;
        if(max_id[tr[p][v ^ 1]] &gt;= l)   p = tr[p][v ^ 1];
        else    p = tr[p][v];
    }

    return c ^ s[max_id[p]];
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    max_id[0] = -1;
    root[0] = ++ idx;
    insert(0, 23, 0, root[0]);

    for(int i = 1; i &lt;= n; i ++)
    {
        int x;
        cin &gt;&gt; x;
        s[i] = s[i - 1] ^ x;
        root[i] = ++ idx;
        insert(i, 23, root[i - 1], root[i]);
    }

    char op[2];
    int l, r, x;
    while(m --)
    {
        cin &gt;&gt; op;
        if(op[0] == 'A')
        {
            cin &gt;&gt; x;
            n ++;
            s[n] = s[n - 1] ^ x;
            root[n] = ++ idx;
            insert(n, 23, root[n - 1], root[n]);
        }
        else
        {
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;
            cout &lt;&lt; query(root[r - 1], s[n] ^ x, l - 1) &lt;&lt; endl;
        }
    }

    return 0;
}
</code></pre>
<h5 id="2-11-2-可持久化线段树-主席树">2.11.2 可持久化线段树(主席树)</h5>
<pre><code class="language-cpp">//求区间内第k小数
int n, m;
int a[N];
vector&lt;int&gt; nums;
struct Node
{
    int l, r;
    int cnt;
}tr[N * 4 + N * 17];

int root[N], idx;

int build(int l, int r) //l,r表示左右儿子
{
    int p = ++ idx;
    if(l == r)  return p;
    int mid = l + r &gt;&gt; 1;
    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);
    return p;
}

int insert(int p, int l, int r, int x)
{
    int q = ++ idx;
    tr[q] = tr[p];
    if(l == r)
    {
        tr[q].cnt ++;  
        return q;
    }
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid)    tr[q].l = insert(tr[p].l, l, mid, x);
    else    tr[q].r = insert(tr[p].r, mid + 1, r, x);
    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;
    return q;
}

int find(int x)
{
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
}

int query(int q, int p, int l, int r, int k)
{
    if(l == r)  return r;
    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int mid = l + r &gt;&gt; 1;
    if(k &lt;= cnt)    return query(tr[q].l, tr[p].l, l, mid, k);
    else    return query(tr[q].r, tr[p].r, mid + 1, r, k - cnt);
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++)
    {
        cin &gt;&gt; a[i];
        nums.push_back(a[i]);
    }

    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());

    root[0] = build(0, nums.size() - 1);
    for(int i = 1; i &lt;= n; i ++)
        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]));

    while(m --)
    {
        int l, r, k;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
        cout &lt;&lt; nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &lt;&lt; endl;
    }
}
</code></pre>
<h4 id="2-12-平衡树">2.12 平衡树</h4>
<h5 id="2-12-1-普通平衡树-treap">2.12.1 普通平衡树（Treap）</h5>
<pre><code class="language-cpp">/*
支持的操作：
1. 插入数值 x。
2. 删除数值 x(若有多个相同的数，应只删除一个)。
3. 查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。
4. 查询排名为 x 的数值。
5. 求数值 x 的前驱(前驱定义为小于 x 的最大的数)。
6. 求数值 x 的后继(后继定义为大于 x 的最小的数)。
*/
struct Node
{
    int l, r;
    int key, val;
    int cnt, size;  //cnt表示某个数出现的次数，size表示子树中有多少个数
}tr[N];

int root, idx;  //idx表示当前分配到第几个节点

void pushup(int p)
{
    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;
}

int get_node(int key)   //创建节点
{
    tr[++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].size = 1; //初始化cnt和size
    return idx;
}

void zig(int &amp;p)    //右旋，传引用
{
    int q = tr[p].l;
    tr[p].l = tr[q].r, tr[q].r = p, p = q;
    pushup(tr[p].r), pushup(p);
}

void zag(int &amp;p)
{
    int q = tr[p].r;
    tr[p].r = tr[q].l, tr[q].l = p, p = q;
    pushup(tr[p].l), pushup(p);
}

void build()
{
    get_node(-INF), get_node(INF);  //插入正无穷和无负穷哨兵
    root = 1, tr[1].r = 2;  //根节点是一号点，右儿子是二号点
    pushup(root);
    if(tr[1].val &lt;tr[2].val) zag(root);
}

void insert(int &amp;p, int key)
{
    if(!p)  p = get_node(key);
    else if(tr[p].key == key)   tr[p].cnt ++;
    else if(tr[p].key &gt; key)
    {
        insert(tr[p].l, key);
        if(tr[tr[p].l].val &gt; tr[p].val) zig(p);
    }
    else
    {
        insert(tr[p].r, key);
        if(tr[tr[p].r].val &gt; tr[p].val) zag(p);
    }
    pushup(p);
}

void remove(int &amp;p, int key)
{
    if(!p)  return ;
    if(tr[p].key == key)
    {
        if(tr[p].cnt &gt; 1)   tr[p].cnt --;
        else if(tr[p].l || tr[p].r)
        {
            if(!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)
            {
                zig(p);
                remove(tr[p].r, key);
            }
            else
            {
                zag(p);
                remove(tr[p].l, key);
            }
        }
        else p = 0;
    }
    else if(tr[p].key &gt; key)    remove(tr[p].l, key);
    else remove(tr[p].r, key);
    pushup(p);
}

int get_rank_by_key(int &amp;p, int key)    //通过排名找数值
{
    if(!p)  return 0;
    if(tr[p].key == key)    return tr[tr[p].l].size + 1;
    if(tr[p].key &gt; key) return get_rank_by_key(tr[p].l, key);
    return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r, key);
}

int get_key_by_rank(int &amp;p, int rank)   //通过数值找排名
{
    if(!p)  return INF;
    if(tr[tr[p].l].size &gt;= rank)    return get_key_by_rank(tr[p].l, rank);
    if(tr[tr[p].l].size + tr[p].cnt &gt;= rank)    return tr[p].key;
    return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);
}

int get_prev(int &amp;p, int key)   //找到严格小于key的最大数
{
    if(!p)  return -INF;
    if(tr[p].key &gt;= key)    return get_prev(tr[p].l, key);
    return max(tr[p].key, get_prev(tr[p].r, key));
}

int get_next(int &amp;p, int key)   //找到严格大于key的最小数
{
    if(!p)  return INF;
    if(tr[p].key &lt;= key)    return get_next(tr[p].r, key);
    return min(tr[p].key, get_next(tr[p].l, key));
}

int main()
{
    build();
    cin &gt;&gt; n;
    while(n --)
    {
        int op, x;
        cin &gt;&gt; op &gt;&gt; x;
        if(op == 1) insert(root, x);
        else if(op == 2)    remove(root, x);
        else if(op == 3)    cout &lt;&lt; get_rank_by_key(root, x) - 1 &lt;&lt; endl;
        else if(op == 4)    cout &lt;&lt; get_key_by_rank(root, x + 1) &lt;&lt; endl;
        else if(op == 5)    cout &lt;&lt; get_prev(root, x) &lt;&lt; endl;
        else if(op == 6)    cout &lt;&lt; get_next(root, x) &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h5 id="2-12-2-splay-伸展树">2.12.2 Splay(伸展树)</h5>
<pre><code class="language-cpp">/*
m 次操作，每次操作选定一个子序列 [l,r]，并将该子序列中的所有数字进行翻转
*/
int n, m;
struct Node
{
    int s[2], p, v;
    int size, flag;

    void init(int _v, int _p)
    {
        v = _v, p = _p;
        size = 1;
    }
}tr[N];
int root, idx;

void pushup(int x)
{
    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;
}

void pushdown(int x)
{
    if (tr[x].flag)
    {
        swap(tr[x].s[0], tr[x].s[1]);
        tr[tr[x].s[0]].flag ^= 1;
        tr[tr[x].s[1]].flag ^= 1;
        tr[x].flag = 0;
    }
}

void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;  // k=0表示x是y的左儿子；k=1表示x是y的右儿子
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

void splay(int x, int k)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
    if (!k) root = x;
}

void insert(int v)
{
    int u = root, p = 0;
    while (u) p = u, u = tr[u].s[v &gt; tr[u].v];
    u = ++ idx;
    if (p) tr[p].s[v &gt; tr[p].v] = u;
    tr[u].init(v, p);
    splay(u, 0);
}

int get_k(int k)
{
    int u = root;
    while (true)
    {
        pushdown(u);
        if (tr[tr[u].s[0]].size &gt;= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].size + 1 == k) return u;
        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
    }
    return -1;
}

void output(int u)
{
    pushdown(u);
    if (tr[u].s[0]) output(tr[u].s[0]);
    if (tr[u].v &gt;= 1 &amp;&amp; tr[u].v &lt;= n) printf(&quot;%d &quot;, tr[u].v);
    if (tr[u].s[1]) output(tr[u].s[1]);
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 0; i &lt;= n + 1; i ++ ) insert(i);
    while (m -- )
    {
        int l, r;
        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
        l = get_k(l), r = get_k(r + 2);
        splay(l, 0), splay(r, l);
        tr[tr[r].s[0]].flag ^= 1;
    }
    output(root);
    return 0;
}
</code></pre>
<h4 id="2-13-ac自动机">2.13  AC自动机</h4>
<pre><code class="language-cpp">/给定n个单词，长度为m的文章，求有多少个单词在文章中出现了
int n;
int tr[N * S][26], cnt[N * S], idx;
char str[M];
int q[N * S], ne[N * S];

void insert()
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int t = str[i] - 'a';
        if (!tr[p][t]) tr[p][t] = ++ idx;
        p = tr[p][t];
    }
    cnt[p] ++ ;
}

void build()
{
    int hh = 0, tt = -1;
    for (int i = 0; i &lt; 26; i ++ )
        if (tr[0][i])
            q[ ++ tt] = tr[0][i];

    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = 0; i &lt; 26; i ++ )
        {
            int p = tr[t][i];
            if (!p) tr[t][i] = tr[ne[t]][i];
            else
            {
                ne[p] = tr[ne[t]][i];
                q[ ++ tt] = p;
            }
        }
    }
}

int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T -- )
    {
        memset(tr, 0, sizeof tr);
        memset(cnt, 0, sizeof cnt);
        memset(ne, 0, sizeof ne);
        idx = 0;

        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 0; i &lt; n; i ++ )
        {
            scanf(&quot;%s&quot;, str);
            insert();
        }

        build();

        scanf(&quot;%s&quot;, str);

        int res = 0;
        for (int i = 0, j = 0; str[i]; i ++ )
        {
            int t = str[i] - 'a';
            j = tr[j][t];

            int p = j;
            while (p)
            {
                res += cnt[p];
                cnt[p] = 0;
                p = ne[p];
            }
        }

        printf(&quot;%d\n&quot;, res);
    }

    return 0;
}
</code></pre>
<h4 id="2-14-分块与莫队">2.14 分块与莫队</h4>
<h5 id="2-14-1-分块解决区间修改-区间查询">2.14.1 分块解决区间修改，区间查询</h5>
<pre><code class="language-cpp">LL a[N], sum[N], add[N];
int L[N], R[N];
int pos[N];
int n, m, t;

void modify(int l, int r, LL d)
{
    int p = pos[l], q = pos[r];
    if(p == q)
    {
        for(int i = l; i &lt;= r; i ++)
            a[i] += d;
        sum[p] += d * (r - l + 1);
    }
    else
    {
        for(int i = p + 1; i &lt;= q - 1; i ++)
            add[i] += d;

        for(int i = l; i &lt;= R[p]; i ++)
            a[i] += d;

        sum[p] += d * (R[p] - l + 1);
        for(int i = L[q]; i &lt;= r; i ++)
            a[i] += d;

        sum[q] += d * (r - L[q] + 1);
    }
}

LL query(int l, int r)
{
    int p = pos[l], q = pos[r];
    LL ans = 0;
    if(p == q)
    {
        for(int i = l; i &lt;= r; i ++)
            ans += a[i];

        ans += add[p] * (r - l + 1);
    }
    else
    {
        for(int i = p + 1; i &lt;= q - 1; i ++)
            ans += sum[i] + add[i] * (R[i] - L[i] + 1);

        for(int i = l; i &lt;= R[p]; i ++)
            ans += a[i];

        ans += add[p] * (R[p] - l + 1);

        for(int i = L[q]; i &lt;= r; i ++)
            ans += a[i];

        ans += add[q] * (r - L[q] + 1);
    }

    return ans;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++)
        cin &gt;&gt; a[i];

    //分块
    t = sqrt(n);
    for(int i = 1; i &lt;= t; i ++)
    {
        L[i] = (i - 1) * sqrt(n) + 1;
        R[i] = i * sqrt(n);
    }

    if(R[t] &lt; n)
    {
        t ++;
        L[t] = R[t - 1] + 1;
        R[t] = n;
    }

    for(int i = 1; i &lt;= t; i ++)
    {
        for(int j = L[i]; j &lt;= R[i]; j ++)
        {
            pos[j] = i;
            sum[i] += a[j];
        }
    }

    while(m --)
    {
        char op[3];
        int l, r, d;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
        if(op[0] == 'C')
        {
            cin &gt;&gt; d;
            modify(l, r, d);
        }
        else    cout &lt;&lt; query(l, r) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h5 id="2-14-2-分块-块状链表">2.14.2 分块-块状链表</h5>
<pre><code class="language-cpp">//待补充
</code></pre>
<h5 id="2-14-3-基础莫队">2.14.3 基础莫队</h5>
<pre><code class="language-cpp">//求一段区间内有多少个不同的数
int n, m, len;
int w[N], ans[M];
struct Query{
    int id, l, r;
}q[M];
int cnt[S];

int get(int x)      //求块的编号
{
    return x / len;
}

bool cmp(const Query&amp; a, const Query&amp; b)
{
    int i = get(a.l), j = get(b.l);
    if(i != j)  return i &lt; j;
    return a.r &lt; b.r;
}

void add(int x, int&amp; res)
{
    if(!cnt[x]) res ++;
    cnt[x] ++;
}

void del(int x, int &amp; res)
{
    cnt[x] --;
    if(!cnt[x]) res --;
}

int main()
{
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i ++)
        cin &gt;&gt; w[i];
    cin &gt;&gt; m;
    len = max(1, (int)sqrt((double)n * n / m));
    for(int i = 0; i &lt; m; i ++)
    {
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        q[i] = {i, l, r};
    }

    sort(q, q + m, cmp);

    for(int k = 0, i = 0, j = 1, res = 0; k &lt; m; k ++)  //处理所有询问
    {
        int id = q[k].id, l = q[k].l, r = q[k].r;   //区间的编号，区间左右端点
        while(i &lt; r)    add(w[ ++ i], res);     //当前区间加一个数
        while(i &gt; r)    del(w[i --], res);
        while(j &lt; l)    del(w[j ++], res);
        while(j &gt; l)    add(w[-- j], res);
        ans[id] = res;
    }

    for(int i = 0; i &lt; m; i ++)
        cout &lt;&lt; ans[i] &lt;&lt; endl;

    return 0;
}
</code></pre>
<h4 id="2-15-点分治">2.15 点分治</h4>
<pre><code class="language-cpp">//求树上边权长度不超过K的路径有多少条
int n, m;
int h[N], e[M], w[M], ne[M], idx;
bool st[N];     //表示点是否被删掉
int p[N], q[N];

void add(int a, int b, int c)
{
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx ++;
}

int get_size(int u, int fa)     //求子树大小
{
    if(st[u])   return 0;
    int res = 1;
    for(int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if(j != fa)
            res += get_size(j, u);
    }

    return res;
}

int get_wc(int u, int fa, int tot, int&amp; wc) //求树的重心
{
    if(st[u])   return 0;
    int sum = 1, ms = 0;
    for(int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if(j == fa) continue;
        int t = get_wc(j, u, tot, wc);
        ms = max(ms, t);
        sum += t;
    }
    ms = max(ms, tot - sum);
    if(ms &lt;= tot / 2)   wc = u;
    return sum;
}

void get_dist(int u, int fa, int dist, int&amp; qt)
{
    if(st[u])   return ;
    q[qt ++] = dist;
    for(int i = h[u]; ~i; i = ne[i])
        if(e[i] != fa)
            get_dist(e[i], u, dist + w[i], qt);
}

int get(int a[], int k)
{
    sort(a, a + k);
    int res = 0;
    for(int i = k - 1, j = -1; i &gt;= 0; i --)
    {
        while(j + 1 &lt; i &amp;&amp; a[j + 1] + a[i] &lt;= m)    j ++;
        j = min(j, i - 1);
        res += j + 1;
    }

    return res;
}

int calc(int u)
{
    if(st[u])   return 0;
    int res = 0;
    get_wc(u, -1, get_size(u, -1), u);
    st[u] = true;

    int pt = 0;
    for(int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i], qt = 0;
        get_dist(j, -1, w[i], qt);
        res -= get(q, qt);
        for(int k = 0; k &lt; qt; k ++)
        {
            if(q[k] &lt;= m)   res ++;
            p[pt ++] = q[k];
        }
    }
    res += get(p, pt);

    for(int i = h[u]; ~i; i = ne[i])
    {
        res += calc(e[i]);
    }

    return res;
}

int main()
{
    while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n, m)
    {
        memset(st, 0, sizeof st);
        idx = 0;
        memset(h, -1, sizeof h);
        for(int i = 0; i &lt; n - 1; i ++)
        {
            int a, b, c;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            add(a, b, c);
            add(b, a, c);
        }

        cout &lt;&lt; calc(0) &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h4 id="2-16-树套树-线段树套平衡树">2.16 树套树(线段树套平衡树)</h4>
<pre><code class="language-cpp">/*
树套树用于维护一个长度为n的数列，支持以下操作

1. `1 l r x`，查询整数 x 在区间 [l,r] 内的排名。

2. `2 l r k`，查询区间 [l,r] 内排名为 k 的值。

3. `3 pos x`，将 pos 位置的数修改为 x。

4. `4 l r x`，查询整数 x 在区间 [l,r] 内的前驱(前驱定义为小于 x，且最大的数)。

5. `5 l r x`，查询整数 x 在区间 [l,r] 内的后继(后继定义为大于 x，且最小的数)。的数)。
*/
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 2000010, INF = 1e9;

int n, m;
struct Node
{
    int s[2], p, v;
    int size;

    void init(int _v, int _p)
    {
        v = _v, p = _p;
        size = 1;
    }
}tr[N];
int L[N], R[N], T[N], idx;
int w[N];

void pushup(int x)
{
    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;
}

void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

void splay(int&amp; root, int x, int k)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
    if (!k) root = x;
}

void insert(int&amp; root, int v)
{
    int u = root, p = 0;
    while (u) p = u, u = tr[u].s[v &gt; tr[u].v];
    u = ++ idx;
    if (p) tr[p].s[v &gt; tr[p].v] = u;
    tr[u].init(v, p);
    splay(root, u, 0);
}

int get_k(int root, int v)
{
    int u = root, res = 0;
    while (u)
    {
        if (tr[u].v &lt; v) res += tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
        else u = tr[u].s[0];
    }
    return res;
}

void update(int&amp; root, int x, int y)
{
    int u = root;
    while (u)
    {
        if (tr[u].v == x) break;
        if (tr[u].v &lt; x) u = tr[u].s[1];
        else u = tr[u].s[0];
    }
    splay(root, u, 0);
    int l = tr[u].s[0], r = tr[u].s[1];
    while (tr[l].s[1]) l = tr[l].s[1];
    while (tr[r].s[0]) r = tr[r].s[0];
    splay(root, l, 0), splay(root, r, l);
    tr[r].s[0] = 0;
    pushup(r), pushup(l);
    insert(root, y);
}

void build(int u, int l, int r)
{
    L[u] = l, R[u] = r;
    insert(T[u], -INF), insert(T[u], INF);
    for (int i = l; i &lt;= r; i ++ ) insert(T[u], w[i]);
    if (l == r) return;
    int mid = l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
}

int query(int u, int a, int b, int x)
{
    if (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) return get_k(T[u], x) - 1;
    int mid = L[u] + R[u] &gt;&gt; 1, res = 0;
    if (a &lt;= mid) res += query(u &lt;&lt; 1, a, b, x);
    if (b &gt; mid) res += query(u &lt;&lt; 1 | 1, a, b, x);
    return res;
}

void change(int u, int p, int x)
{
    update(T[u], w[p], x);
    if (L[u] == R[u]) return;
    int mid = L[u] + R[u] &gt;&gt; 1;
    if (p &lt;= mid) change(u &lt;&lt; 1, p, x);
    else change(u &lt;&lt; 1 | 1, p, x);
}

int get_pre(int root, int v)
{
    int u = root, res = -INF;
    while (u)
    {
        if (tr[u].v &lt; v) res = max(res, tr[u].v), u = tr[u].s[1];
        else u = tr[u].s[0];
    }
    return res;
}

int get_suc(int root, int v)
{
    int u = root, res = INF;
    while (u)
    {
        if (tr[u].v &gt; v) res = min(res, tr[u].v), u = tr[u].s[0];
        else u = tr[u].s[1];
    }
    return res;
}

int query_pre(int u, int a, int b, int x)
{
    if (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) return get_pre(T[u], x);
    int mid = L[u] + R[u] &gt;&gt; 1, res = -INF;
    if (a &lt;= mid) res = max(res, query_pre(u &lt;&lt; 1, a, b, x));
    if (b &gt; mid) res = max(res, query_pre(u &lt;&lt; 1 | 1, a, b, x));
    return res;
}

int query_suc(int u, int a, int b, int x)
{
    if (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) return get_suc(T[u], x);
    int mid = L[u] + R[u] &gt;&gt; 1, res = INF;
    if (a &lt;= mid) res = min(res, query_suc(u &lt;&lt; 1, a, b, x));
    if (b &gt; mid) res = min(res, query_suc(u &lt;&lt; 1 | 1, a, b, x));
    return res;
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);
    build(1, 1, n);

    while (m -- )
    {
        int op, a, b, x;
        scanf(&quot;%d&quot;, &amp;op);
        if (op == 1)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x);
            printf(&quot;%d\n&quot;, query(1, a, b, x) + 1);
        }
        else if (op == 2)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x);
            int l = 0, r = 1e8;
            while (l &lt; r)
            {
                int mid = l + r + 1 &gt;&gt; 1;
                if (query(1, a, b, mid) + 1 &lt;= x) l = mid;
                else r = mid - 1;
            }
            printf(&quot;%d\n&quot;, r);
        }
        else if (op == 3)
        {
            scanf(&quot;%d%d&quot;, &amp;a, &amp;x);
            change(1, a, x);
            w[a] = x;
        }
        else if (op == 4)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x);
            printf(&quot;%d\n&quot;, query_pre(1, a, b, x));
        }
        else
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x);
            printf(&quot;%d\n&quot;, query_suc(1, a, b, x));
        }
    }

    return 0;
}
</code></pre>
<h6 id="树套树动态维护区间第k大数">树套树动态维护区间第k大数</h6>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

const int N = 50010, P = N * 17 * 17, M = N * 4;

int n, m;
struct Tree
{
    int l, r, sum, add;
}tr[P];
int L[M], R[M], T[M], idx;
struct Query
{
    int op, a, b, c;
}q[N];
vector&lt;int&gt; nums;

int get(int x)
{
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
}

void build(int u, int l, int r)
{
    L[u] = l, R[u] = r, T[u] = ++ idx;
    if (l == r) return;
    int mid = l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
}

int intersection(int a, int b, int c, int d)
{
    return min(b, d) - max(a, c) + 1;
}

void update(int u, int l, int r, int pl, int pr)
{
    tr[u].sum += intersection(l, r, pl, pr);
    if (l &gt;= pl &amp;&amp; r &lt;= pr)
    {
        tr[u].add ++ ;
        return;
    }
    int mid = l + r &gt;&gt; 1;
    if (pl &lt;= mid)
    {
        if (!tr[u].l) tr[u].l = ++ idx;
        update(tr[u].l, l, mid, pl, pr);
    }
    if (pr &gt; mid)
    {
        if (!tr[u].r) tr[u].r = ++ idx;
        update(tr[u].r, mid + 1, r, pl, pr);
    }
}

void change(int u, int a, int b, int c)
{
    update(T[u], 1, n, a, b);
    if (L[u] == R[u]) return;
    int mid = L[u] + R[u] &gt;&gt; 1;
    if (c &lt;= mid) change(u &lt;&lt; 1, a, b, c);
    else change(u &lt;&lt; 1 | 1, a, b, c);
}

int get_sum(int u, int l, int r, int pl, int pr, int add)
{
    if (l &gt;= pl &amp;&amp; r &lt;= pr) return tr[u].sum + (r - l + 1) * add;
    int mid = l + r &gt;&gt; 1, res = 0;
    add += tr[u].add;
    if (pl &lt;= mid)
    {
        if (tr[u].l) res += get_sum(tr[u].l, l, mid, pl, pr, add);
        else res += intersection(l, mid, pl, pr) * add;
    }
    if (pr &gt; mid)
    {
        if (tr[u].r) res += get_sum(tr[u].r, mid + 1, r, pl, pr, add);
        else res += intersection(mid + 1, r, pl, pr) * add;
    }
    return res;
}

int query(int u, int a, int b, int c)
{
    if (L[u] == R[u]) return R[u];
    int mid = L[u] + R[u] &gt;&gt; 1;
    int k = get_sum(T[u &lt;&lt; 1 | 1], 1, n, a, b, 0);
    if (k &gt;= c) return query(u &lt;&lt; 1 | 1, a, b, c);
    return query(u &lt;&lt; 1, a, b, c - k);
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 0; i &lt; m; i ++ )
    {
        scanf(&quot;%d%d%d%d&quot;, &amp;q[i].op, &amp;q[i].a, &amp;q[i].b, &amp;q[i].c);
        if (q[i].op == 1) nums.push_back(q[i].c);
    }
    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());
    build(1, 0, nums.size() - 1);

    for (int i = 0; i &lt; m; i ++ )
    {
        int op = q[i].op, a = q[i].a, b = q[i].b, c = q[i].c;
        if (op == 1) change(1, a, b, get(c));
        else printf(&quot;%d\n&quot;, nums[query(1, a, b, c)]);
    }

    return 0;
}
</code></pre>
<h4 id="2-17-树链剖分-树上差分plus">2.17 树链剖分(树上差分plus)</h4>
<pre><code class="language-cpp">/*
维护一棵树，支持以下操作：
- `1 u v k`，修改路径上节点权值，将节点 u 和节点 v 之间路径上的所有节点（包括这两个节点）的权值增加 k。
- `2 u k`，修改子树上节点权值，将以节点 u 为根的子树上的所有节点的权值增加 k。
- `3 u v`，询问路径，询问节点 u 和节点 v 之间路径上的所有节点（包括这两个节点）的权值和。
- `4 u`，询问子树，询问以节点 u 为根的子树上的所有节点的权值和。
*/
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;
const int N = 100010, M = N * 2;

int n, m;
int w[N], h[N], e[M], ne[M], idx;
int id[N], nw[N], cnt;
int dep[N], sz[N], top[N], fa[N], son[N];
struct Tree
{
    int l, r;
    LL add, sum;
}tr[N * 4];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs1(int u, int father, int depth)
{
    dep[u] = depth, fa[u] = father, sz[u] = 1;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j == father) continue;
        dfs1(j, u, depth + 1);
        sz[u] += sz[j];
        if (sz[son[u]] &lt; sz[j]) son[u] = j;
    }
}

void dfs2(int u, int t)
{
    id[u] = ++ cnt, nw[cnt] = w[u], top[u] = t;
    if (!son[u]) return;
    dfs2(son[u], t);
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j == fa[u] || j == son[u]) continue;
        dfs2(j, j);
    }
}

void pushup(int u)
{
    tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
}

void pushdown(int u)
{
    auto &amp;root = tr[u], &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1];
    if (root.add)
    {
        left.add += root.add, left.sum += root.add * (left.r - left.l + 1);
        right.add += root.add, right.sum += root.add * (right.r - right.l + 1);
        root.add = 0;
    }
}

void build(int u, int l, int r)
{
    tr[u] = {l, r, 0, nw[r]};
    if (l == r) return;
    int mid = l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u);
}

void update(int u, int l, int r, int k)
{
    if (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)
    {
        tr[u].add += k;
        tr[u].sum += k * (tr[u].r - tr[u].l + 1);
        return;
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    if (l &lt;= mid) update(u &lt;&lt; 1, l, r, k);
    if (r &gt; mid) update(u &lt;&lt; 1 | 1, l, r, k);
    pushup(u);
}

LL query(int u, int l, int r)
{
    if (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) return tr[u].sum;
    pushdown(u);
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    LL res = 0;
    if (l &lt;= mid) res += query(u &lt;&lt; 1, l, r);
    if (r &gt; mid) res += query(u &lt;&lt; 1 | 1, l, r);
    return res;
}

void update_path(int u, int v, int k)
{
    while (top[u] != top[v])
    {
        if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);
        update(1, id[top[u]], id[u], k);
        u = fa[top[u]];
    }
    if (dep[u] &lt; dep[v]) swap(u, v);
    update(1, id[v], id[u], k);
}

LL query_path(int u, int v)
{
    LL res = 0;
    while (top[u] != top[v])
    {
        if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);
        res += query(1, id[top[u]], id[u]);
        u = fa[top[u]];
    }
    if (dep[u] &lt; dep[v]) swap(u, v);
    res += query(1, id[v], id[u]);
    return res;
}

void update_tree(int u, int k)
{
    update(1, id[u], id[u] + sz[u] - 1, k);
}

LL query_tree(int u)
{
    return query(1, id[u], id[u] + sz[u] - 1);
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);
    memset(h, -1, sizeof h);
    for (int i = 0; i &lt; n - 1; i ++ )
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        add(a, b), add(b, a);
    }
    dfs1(1, -1, 1);
    dfs2(1, 1);
    build(1, 1, n);

    scanf(&quot;%d&quot;, &amp;m);
    while (m -- )
    {
        int t, u, v, k;
        scanf(&quot;%d%d&quot;, &amp;t, &amp;u);
        if (t == 1)
        {
            scanf(&quot;%d%d&quot;, &amp;v, &amp;k);
            update_path(u, v, k);
        }
        else if (t == 2)
        {
            scanf(&quot;%d&quot;, &amp;k);
            update_tree(u, k);
        }
        else if (t == 3)
        {
            scanf(&quot;%d&quot;, &amp;v);
            printf(&quot;%lld\n&quot;, query_path(u, v));
        }
        else printf(&quot;%lld\n&quot;, query_tree(u));
    }

    return 0;
}
</code></pre>
<h4 id="2-18-动态树">2.18 动态树</h4>
<pre><code class="language-cpp">/*
维护一棵树，支持以下操作：
- `0 x y`，表示询问点 x 到点 y 之间的路径上的所有点（包括两端点）的权值的异或和。保证 x 和 y 之间存在连通路径。
- `1 x y`，表示在点 x 和点 y 之间增加一条边 (x,y)。注意：**如果两点已经处于连通状态，则无视该操作**。
- `2 x y`，表示删除边 (x,y)。注意：**如果该边不存在，则无视该操作**。
- `3 x w`，表示将点 x 的权值修改为 w。
*/
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n, m;
struct Node
{
    int s[2], p, v;
    int sum, rev;
}tr[N];
int stk[N];

void pushrev(int x)
{
    swap(tr[x].s[0], tr[x].s[1]);
    tr[x].rev ^= 1;
}

void pushup(int x)
{
    tr[x].sum = tr[tr[x].s[0]].sum ^ tr[x].v ^ tr[tr[x].s[1]].sum;
}

void pushdown(int x)
{
    if (tr[x].rev)
    {
        pushrev(tr[x].s[0]), pushrev(tr[x].s[1]);
        tr[x].rev = 0;
    }
}

bool isroot(int x)
{
    return tr[tr[x].p].s[0] != x &amp;&amp; tr[tr[x].p].s[1] != x;
}

void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    if (!isroot(y)) tr[z].s[tr[z].s[1] == y] = x;
    tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

void splay(int x)
{
    int top = 0, r = x;
    stk[ ++ top] = r;
    while (!isroot(r)) stk[ ++ top] = r = tr[r].p;
    while (top) pushdown(stk[top -- ]);
    while (!isroot(x))
    {
        int y = tr[x].p, z = tr[y].p;
        if (!isroot(y))
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
}

void access(int x)  // 建立一条从根到x的路径，同时将x变成splay的根节点
{
    int z = x;
    for (int y = 0; x; y = x, x = tr[x].p)
    {
        splay(x);
        tr[x].s[1] = y, pushup(x);
    }
    splay(z);
}

void makeroot(int x)  // 将x变成原树的根节点
{
    access(x);
    pushrev(x);
}

int findroot(int x)  // 找到x所在原树的根节点, 再将原树的根节点旋转到splay的根节点
{
    access(x);
    while (tr[x].s[0]) pushdown(x), x = tr[x].s[0];
    splay(x);
    return x;
}

void split(int x, int y)  // 给x和y之间的路径建立一个splay，其根节点是y
{
    makeroot(x);
    access(y);
}

void link(int x, int y)  // 如果x和y不连通，则加入一条x和y之间的边
{
    makeroot(x);
    if (findroot(y) != x) tr[x].p = y;
}

void cut(int x, int y)  // 如果x和y之间存在边，则删除该边
{
    makeroot(x);
    if (findroot(y) == x &amp;&amp; tr[y].p == x &amp;&amp; !tr[y].s[0])
    {
        tr[x].s[1] = tr[y].p = 0;
        pushup(x);
    }
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;tr[i].v);
    while (m -- )
    {
        int t, x, y;
        scanf(&quot;%d%d%d&quot;, &amp;t, &amp;x, &amp;y);
        if (t == 0)
        {
            split(x, y);
            printf(&quot;%d\n&quot;, tr[y].sum);
        }
        else if (t == 1) link(x, y);
        else if (t == 2) cut(x, y);
        else
        {
            splay(x);
            tr[x].v = y;
            pushup(x);
        }
    }

    return 0;
}
</code></pre>
<h4 id="2-19-dancing-links-dlx">2.19 Dancing Links(DLX)</h4>
<h6 id="2-19-1-精确覆盖问题">2.19.1 精确覆盖问题</h6>
<pre><code>给定一个01矩阵A，找到一个行的集合，使得这些行中，每一列有且仅有一个数字1
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 5510;

int n, m;
int l[N], r[N], u[N], d[N], s[N], row[N], col[N], idx;
int ans[N], top;

void init()
{
    for (int i = 0; i &lt;= m; i ++ )
    {
        l[i] = i - 1, r[i] = i + 1;
        u[i] = d[i] = i;
    }
    l[0] = m, r[m] = 0;
    idx = m + 1;
}

void add(int&amp; hh, int&amp; tt, int x, int y)
{
    row[idx] = x, col[idx] = y, s[y] ++ ;
    u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx;
    r[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh;
    tt = idx ++ ;
}

void remove(int p)
{
    r[l[p]] = r[p], l[r[p]] = l[p];
    for (int i = d[p]; i != p; i = d[i])
        for (int j = r[i]; j != i; j = r[j])
        {
            s[col[j]] -- ;
            u[d[j]] = u[j], d[u[j]] = d[j];
        }
}

void resume(int p)
{
    for (int i = u[p]; i != p; i = u[i])
        for (int j = l[i]; j != i; j = l[j])
        {
            u[d[j]] = j, d[u[j]] = j;
            s[col[j]] ++ ;
        }
    r[l[p]] = p, l[r[p]] = p;
}

bool dfs()
{
    if (!r[0]) return true;
    int p = r[0];
    for (int i = r[0]; i; i = r[i])
        if (s[i] &lt; s[p])
            p = i;
    remove(p);
    for (int i = d[p]; i != p; i = d[i])
    {
        ans[ ++ top] = row[i];
        for (int j = r[i]; j != i; j = r[j]) remove(col[j]);
        if (dfs()) return true;
        for (int j = l[i]; j != i; j = l[j]) resume(col[j]);
        top -- ;
    }
    resume(p);
    return false;
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    init();
    for (int i = 1; i &lt;= n; i ++ )
    {
        int hh = idx, tt = idx;
        for (int j = 1; j &lt;= m; j ++ )
        {
            int x;
            scanf(&quot;%d&quot;, &amp;x);
            if (x) add(hh, tt, i, j);
        }
    }

    if (dfs())
    {
        for (int i = 1; i &lt;= top; i ++ ) printf(&quot;%d &quot;, ans[i]);
        puts(&quot;&quot;);
    }
    else puts(&quot;No Solution!&quot;);

    return 0;
}
</code></pre>
<p>填写16*16的数独</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 20000;

int m = 16 * 16 * 4;
int u[N], d[N], l[N], r[N], s[N], col[N], row[N], idx;
int ans[N], top;
struct Op
{
    int x, y;
    char z;
}op[N];
char g[20][20];

void init()
{
    for (int i = 0; i &lt;= m; i ++ )
    {
        l[i] = i - 1, r[i] = i + 1;
        s[i] = 0;
        d[i] = u[i] = i;
    }
    l[0] = m, r[m] = 0;
    idx = m + 1;
}

void add(int&amp; hh, int&amp; tt, int x, int y)
{
    row[idx] = x, col[idx] = y, s[y] ++ ;
    u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx;
    r[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh;
    tt = idx ++ ;
}

void remove(int p)
{
    r[l[p]] = r[p], l[r[p]] = l[p];
    for (int i = d[p]; i != p; i = d[i])
        for (int j = r[i]; j != i; j = r[j])
        {
            s[col[j]] -- ;
            u[d[j]] = u[j], d[u[j]] = d[j];
        }
}

void resume(int p)
{
    for (int i = u[p]; i != p; i = u[i])
        for (int j = l[i]; j != i; j = l[j])
        {
            u[d[j]] = j, d[u[j]] = j;
            s[col[j]] ++ ;
        }
    r[l[p]] = p, l[r[p]] = p;
}

bool dfs()
{
    if (!r[0]) return true;
    int p = r[0];
    for (int i = r[0]; i; i = r[i])
        if (s[i] &lt; s[p])
            p = i;
    remove(p);
    for (int i = d[p]; i != p; i = d[i])
    {
        ans[ ++ top] = row[i];
        for (int j = r[i]; j != i; j = r[j]) remove(col[j]);
        if (dfs()) return true;
        for (int j = l[i]; j != i; j = l[j]) resume(col[j]);
        top -- ;
    }
    resume(p);
    return false;
}

int main()
{
    while (~scanf(&quot;%s&quot;, g[0]))
    {
        for (int i = 1; i &lt; 16; i ++ ) scanf(&quot;%s&quot;, g[i]);
        init();

        for (int i = 0, n = 1; i &lt; 16; i ++ )
            for (int j = 0; j &lt; 16; j ++ )
            {
                int a = 0, b = 15;
                if (g[i][j] != '-') a = b = g[i][j] - 'A';
                for (int k = a; k &lt;= b; k ++, n ++ )
                {
                    int hh = idx, tt = idx;
                    op[n] = {i, j, k + 'A'};
                    add(hh, tt, n, i * 16 + j + 1);
                    add(hh, tt, n, 256 + i * 16 + k + 1);
                    add(hh, tt, n, 256 * 2 + j * 16 + k + 1);
                    add(hh, tt, n, 256 * 3 + (i / 4 * 4 + j / 4) * 16 + k + 1);
                }
            }

        dfs();
        for (int i = 1; i &lt;= top; i ++ )
        {
            auto t = op[ans[i]];
            g[t.x][t.y] = t.z;
        }

        for (int i = 0; i &lt; 16; i ++ ) puts(g[i]);
        puts(&quot;&quot;);
    }

    return 0;
}
</code></pre>
<h6 id="2-19-2-重复覆盖问题">2.19.2 重复覆盖问题</h6>
<p>给定一个01矩阵A，找到一个行的集合，使得这些行中，每一列都包含数字1，且集合中包含的行数尽可能少。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010;

int n, m;
int l[N], r[N], u[N], d[N], col[N], row[N], s[N], idx;
int ans[N];
bool st[110];

void init()
{
    for (int i = 0; i &lt;= m; i ++ )
    {
        l[i] = i - 1, r[i] = i + 1;
        col[i] = u[i] = d[i] = i;
        s[i] = 0;
    }
    l[0] = m, r[m] = 0;
    idx = m + 1;
}

void add(int&amp; hh, int&amp; tt, int x, int y)
{
    row[idx] = x, col[idx] = y, s[y] ++ ;
    u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx;
    r[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh;
    tt = idx ++ ;
}

int h()
{
    int cnt = 0;
    memset(st, 0, sizeof st);
    for (int i = r[0]; i; i = r[i])
    {
        if (st[col[i]]) continue;
        cnt ++ ;
        st[col[i]] = true;
        for (int j = d[i]; j != i; j = d[j])
            for (int k = r[j]; k != j; k = r[k])
                st[col[k]] = true;
    }
    return cnt;
}

void remove(int p)
{
    for (int i = d[p]; i != p; i = d[i])
    {
        r[l[i]] = r[i];
        l[r[i]] = l[i];
    }
}

void resume(int p)
{
    for (int i = u[p]; i != p; i = u[i])
    {
        r[l[i]] = i;
        l[r[i]] = i;
    }
}

bool dfs(int k, int depth)
{
    if (k + h() &gt; depth) return false;
    if (!r[0]) return true;
    int p = r[0];
    for (int i = r[0]; i; i = r[i])
        if (s[p] &gt; s[i])
            p = i;

    for (int i = d[p]; i != p; i = d[i])
    {
        ans[k] = row[i];
        remove(i);
        for (int j = r[i]; j != i; j = r[j]) remove(j);
        if (dfs(k + 1, depth)) return true;
        for (int j = l[i]; j != i; j = l[j]) resume(j);
        resume(i);
    }
    return false;
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    init();
    for (int i = 1; i &lt;= n; i ++ )
    {
        int hh = idx, tt = idx;
        for (int j = 1; j &lt;= m; j ++ )
        {
            int x;
            scanf(&quot;%d&quot;, &amp;x);
            if (x) add(hh, tt, i, j);
        }
    }

    int depth = 0;
    while (!dfs(0, depth)) depth ++ ;
    printf(&quot;%d\n&quot;, depth);
    for (int i = 0; i &lt; depth; i ++ ) printf(&quot;%d &quot;, ans[i]);
    return 0;
}
</code></pre>
<h4 id="2-20-左偏树">2.20 左偏树</h4>
<pre><code class="language-cpp">/*
维护一个小根堆，支持以下操作：
1. `1 a`，在集合中插入一个新堆，堆中只包含一个数 a。
2. `2 x y`，将第 x 个插入的数和第 y 个插入的数所在的小根堆合并。数据保证两个数均未被删除。若两数已在同一堆中，则忽略此操作。
3. `3 x`，输出第 x 个插入的数所在小根堆的最小值。数据保证该数未被删除。
4. `4 x`，删除第 x 个插入的数所在小根堆的最小值（若最小值不唯一，则优先删除先插入的数）。数据保证该数未被删除。
*/
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 200010;

int n;
int v[N], dist[N], l[N], r[N], idx;
int p[N];

bool cmp(int x, int y)
{
    if (v[x] != v[y]) return v[x] &lt; v[y];
    return x &lt; y;
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int merge(int x, int y)
{
    if (!x || !y) return x + y;
    if (cmp(y, x)) swap(x, y);
    r[x] = merge(r[x], y);
    if (dist[r[x]] &gt; dist[l[x]]) swap(l[x], r[x]);
    dist[x] = dist[r[x]] + 1;
    return x;
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    v[0] = 2e9;
    while (n -- )
    {
        int t, x, y;
        scanf(&quot;%d%d&quot;, &amp;t, &amp;x);
        if (t == 1)
        {
            v[ ++ idx] = x;
            dist[idx] = 1;
            p[idx] = idx;
        }
        else if (t == 2)
        {
            scanf(&quot;%d&quot;, &amp;y);
            x = find(x), y = find(y);
            if (x != y)
            {
                if (cmp(y, x)) swap(x, y);
                p[y] = x;
                merge(x, y);
            }
        }
        else if (t == 3)
        {
            printf(&quot;%d\n&quot;, v[find(x)]);
        }
        else
        {
            x = find(x);
            if (cmp(r[x], l[x])) swap(l[x], r[x]);
            p[x] = l[x], p[l[x]] = l[x];
            merge(l[x], r[x]);
        }
    }

    return 0;
}
</code></pre>
<h6 id="给定一个整数序列a-求一个递增序列b-使得a-i-和b-i-的各项之差的绝对值之和最小">给定一个整数序列a，求一个递增序列b，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的各项之差的绝对值之和最小</h6>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;
const int N = 1000010;

int n;
int v[N], dist[N], l[N], r[N];
struct Segment
{
    int end, root, size;
}stk[N];
int ans[N];

int merge(int x, int y)
{
    if (!x || !y) return x + y;
    if (v[x] &lt; v[y]) swap(x, y);
    r[x] = merge(r[x], y);
    if (dist[r[x]] &gt; dist[l[x]]) swap(r[x], l[x]);
    dist[x] = dist[r[x]] + 1;
    return x;
}

int pop(int x)
{
    return merge(l[x], r[x]);
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i ++ )
    {
        scanf(&quot;%d&quot;, &amp;v[i]);
        v[i] -= i;
    }
    int tt = 0;
    for (int i = 1; i &lt;= n; i ++ )
    {
        auto cur = Segment({i, i, 1});
        dist[i] = 1;
        while (tt &amp;&amp; v[cur.root] &lt; v[stk[tt].root])
        {
            cur.root = merge(cur.root, stk[tt].root);
            if (cur.size % 2 &amp;&amp; stk[tt].size % 2)
                cur.root = pop(cur.root);
            cur.size += stk[tt].size;
            tt -- ;
        }
        stk[ ++ tt] = cur;
    }

    for (int i = 1, j = 1; i &lt;= tt; i ++ )
    {
        while (j &lt;= stk[i].end)
            ans[j ++ ] = v[stk[i].root];
    }

    LL res = 0;
    for (int i = 1; i &lt;= n; i ++ ) res += abs(v[i] - ans[i]);
    printf(&quot;%lld\n&quot;, res);
    for (int i = 1; i &lt;= n; i ++ )
        printf(&quot;%d &quot;, ans[i] + i);

    return 0;
}
</code></pre>
<h4 id="2-21-后缀数组">2.21 后缀数组</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1000010;

int n, m;
char s[N];
int sa[N], x[N], y[N], c[N], rk[N], height[N];

void get_sa()
{
    for (int i = 1; i &lt;= n; i ++ ) c[x[i] = s[i]] ++ ;
    for (int i = 2; i &lt;= m; i ++ ) c[i] += c[i - 1];
    for (int i = n; i; i -- ) sa[c[x[i]] -- ] = i;
    for (int k = 1; k &lt;= n; k &lt;&lt;= 1)
    {
        int num = 0;
        for (int i = n - k + 1; i &lt;= n; i ++ ) y[ ++ num] = i;
        for (int i = 1; i &lt;= n; i ++ )
            if (sa[i] &gt; k)
                y[ ++ num] = sa[i] - k;
        for (int i = 1; i &lt;= m; i ++ ) c[i] = 0;
        for (int i = 1; i &lt;= n; i ++ ) c[x[i]] ++ ;
        for (int i = 2; i &lt;= m; i ++ ) c[i] += c[i - 1];
        for (int i = n; i; i -- ) sa[c[x[y[i]]] -- ] = y[i], y[i] = 0;
        swap(x, y);
        x[sa[1]] = 1, num = 1;
        for (int i = 2; i &lt;= n; i ++ )
            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++ num;
        if (num == n) break;
        m = num;
    }
}

void get_height()
{
    for (int i = 1; i &lt;= n; i ++ ) rk[sa[i]] = i;
    for (int i = 1, k = 0; i &lt;= n; i ++ )
    {
        if (rk[i] == 1) continue;
        if (k) k -- ;
        int j = sa[rk[i] - 1];
        while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) k ++ ;
        height[rk[i]] = k;
    }
}

int main()
{
    scanf(&quot;%s&quot;, s + 1);
    n = strlen(s + 1), m = 122;
    get_sa();
    get_height();

    for (int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, sa[i]);
    puts(&quot;&quot;);
    for (int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, height[i]);
    puts(&quot;&quot;);
    return 0;
}
</code></pre>
<h4 id="2-22-后缀自动机">2.22 后缀自动机</h4>
<h6 id="给定一个长度为n的小写字母字符串s-对于所有s的出现次数不为1的子串-设value的值为子串出现的次数-子串的长度-求value的最大值">给定一个长度为n的小写字母字符串S，对于所有S的出现次数不为1的子串，设value的值为子串出现的次数×子串的长度，求value的最大值</h6>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 2000010;

int tot = 1, last = 1;
struct Node
{
    int len, fa;
    int ch[26];
}node[N];
char str[N];
LL f[N], ans;
int h[N], e[N], ne[N], idx;

void extend(int c)
{
    int p = last, np = last = ++ tot;
    f[tot] = 1;
    node[np].len = node[p].len + 1;
    for (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np;
    if (!p) node[np].fa = 1;
    else
    {
        int q = node[p].ch[c];
        if (node[q].len == node[p].len + 1) node[np].fa = q;
        else
        {
            int nq = ++ tot;
            node[nq] = node[q], node[nq].len = node[p].len + 1;
            node[q].fa = node[np].fa = nq;
            for (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq;
        }
    }
}

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        dfs(e[i]);
        f[u] += f[e[i]];
    }
    if (f[u] &gt; 1) ans = max(ans, f[u] * node[u].len);
}

int main()
{
    scanf(&quot;%s&quot;, str);
    for (int i = 0; str[i]; i ++ ) extend(str[i] - 'a');
    memset(h, -1, sizeof h);
    for (int i = 2; i &lt;= tot; i ++ ) add(node[i].fa, i);
    dfs(1);
    printf(&quot;%lld\n&quot;, ans);

    return 0;
}
</code></pre>
<h6 id="后缀自动机求最长公共子串">后缀自动机求最长公共子串</h6>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 20010;

int n;
int tot = 1, last = 1;
char str[N];
struct Node
{
    int len, fa;
    int ch[26];
}node[N];
int ans[N], now[N];
int h[N], e[N], ne[N], idx;

void extend(int c)
{
    int p = last, np = last = ++ tot;
    node[np].len = node[p].len + 1;
    for (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np;
    if (!p) node[np].fa = 1;
    else
    {
        int q = node[p].ch[c];
        if (node[q].len == node[p].len + 1) node[np].fa = q;
        else
        {
            int nq = ++ tot;
            node[nq] = node[q], node[nq].len = node[p].len + 1;
            node[q].fa = node[np].fa = nq;
            for (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq;
        }
    }
}

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        dfs(e[i]);
        now[u] = max(now[u], now[e[i]]);
    }
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    scanf(&quot;%s&quot;, str);
    for (int i = 0; str[i]; i ++ ) extend(str[i] - 'a');
    for (int i = 1; i &lt;= tot; i ++ ) ans[i] = node[i].len;
    memset(h, -1, sizeof h);
    for (int i = 2; i &lt;= tot; i ++ ) add(node[i].fa, i);

    for (int i = 0; i &lt; n - 1; i ++ )
    {
        scanf(&quot;%s&quot;, str);
        memset(now, 0, sizeof now);
        int p = 1, t = 0;
        for (int j = 0; str[j]; j ++ )
        {
            int c = str[j] - 'a';
            while (p &gt; 1 &amp;&amp; !node[p].ch[c]) p = node[p].fa, t = node[p].len;
            if (node[p].ch[c]) p = node[p].ch[c], t ++ ;
            now[p] = max(now[p], t);
        }
        dfs(1);
        for (int j = 1; j &lt;= tot; j ++ ) ans[j] = min(ans[j], now[j]);
    }

    int res = 0;
    for (int i = 1; i &lt;= tot; i ++ ) res = max(res, ans[i]);
    printf(&quot;%d\n&quot;, res);

    return 0;
}
</code></pre>
<h4 id="2-23-点分树">2.23 点分树</h4>
<pre><code>//待补充
</code></pre>
<h4 id="2-24-cdq分治">2.24 CDQ分治</h4>
<pre><code>//待补充
</code></pre>
<h6 id="cdq分治求动态逆序对">CDQ分治求动态逆序对</h6>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 100010;

int n, m;
struct Data
{
    int a, t, res;
}q[N], w[N];
int tr[N], pos[N];
LL ans[N];

int lowbit(int x)
{
    return x &amp; -x;
}

void add(int x, int v)
{
    for (int i = x; i &lt; N; i += lowbit(i)) tr[i] += v;
}

int query(int x)
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

void merge_sort(int l, int r)
{
    if (l &gt;= r) return;
    int mid = l + r &gt;&gt; 1;
    merge_sort(l, mid), merge_sort(mid + 1, r);
    int i = mid, j = r;
    while (i &gt;= l &amp;&amp; j &gt; mid)
        if (q[i].a &gt; q[j].a) add(q[i].t, 1), i -- ;
        else q[j].res += query(q[j].t - 1), j -- ;
    while (j &gt; mid) q[j].res += query(q[j].t - 1), j -- ;
    for (int k = i + 1; k &lt;= mid; k ++ ) add(q[k].t, -1);

    j = l, i = mid + 1;
    while (j &lt;= mid &amp;&amp; i &lt;= r)
        if (q[i].a &lt; q[j].a) add(q[i].t, 1), i ++ ;
        else q[j].res += query(q[j].t - 1), j ++ ;
    while (j &lt;= mid) q[j].res += query(q[j].t - 1), j ++ ;
    for (int k = mid + 1; k &lt; i; k ++ ) add(q[k].t, -1);

    i = l, j = mid + 1;
    int k = 0;
    while (i &lt;= mid &amp;&amp; j &lt;= r)
        if (q[i].a &lt;= q[j].a) w[k ++ ] = q[i ++ ];
        else w[k ++ ] = q[j ++ ];
    while (i &lt;= mid) w[k ++ ] = q[i ++ ];
    while (j &lt;= r) w[k ++ ] = q[j ++ ];

    for (i = l, j = 0; j &lt; k; i ++, j ++ ) q[i] = w[j];
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 0; i &lt; n; i ++ )
    {
        scanf(&quot;%d&quot;, &amp;q[i].a);
        pos[q[i].a] = i;
    }
    for (int i = 0, j = n; i &lt; m; i ++ )
    {
        int a;
        scanf(&quot;%d&quot;, &amp;a);
        q[pos[a]].t = j -- ;
        pos[a] = -1;
    }

    for (int i = 1, j = n - m; i &lt;= n; i ++ )
        if (pos[i] != -1)
            q[pos[i]].t = j -- ;

    merge_sort(0, n - 1);

    for (int i = 0; i &lt; n; i ++ ) ans[q[i].t] = q[i].res;
    for (int i = 2; i &lt;= n; i ++ ) ans[i] += ans[i - 1];
    for (int i = 0, j = n; i &lt; m; i ++, j -- ) printf(&quot;%lld\n&quot;, ans[j]);

    return 0;
}
</code></pre>
<h4 id="2-25-笛卡尔树">2.25 笛卡尔树</h4>
<pre><code class="language-cpp">//求区间最值
#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int N = 1e6 + 10;

int a[N];
int l[N], r[N];
int n;
int ans[N], tot;

void dfs(int u)
{
	ans[u] = ++ tot;
	if(l[u])	dfs(l[u]);
	if(r[u])	dfs(r[u]);
}

void build()
{
	stack&lt;int&gt; st;
	int root = 0;
	for(int i = 1; i &lt;= n; i ++)
	{
		int last = 0;
		while(!st.empty() &amp;&amp; a[st.top()] &gt; a[i])
		{
			last = st.top();
			st.pop();
		}
		if(!st.empty())	r[st.top()] = i;
		else	root = i;
		l[i] = last;
		st.push(i);
	}
	dfs(root);
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	cin &gt;&gt; n;
	for(int i = 1; i &lt;= n; i ++)
		cin &gt;&gt; a[i];
	build();
	for(int i = 1; i &lt;= n; i ++)
		cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;
}
</code></pre>
<h1>3. 数学</h1>
<h4 id="3-1-分解质因数">3.1 分解质因数</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using  namespace std;


void device(int a)
{
    for(int i = 2; i &lt;= a / i; i ++)
    {
        if(a % i == 0)              //如果该语句成立，那么i一定是质数

            int s = 0;
            while(a % i == 0)
            {
                a /= i;
                s ++;
            } 
            printf(&quot;%d %d\n&quot;, i, s);
        }

    }
    if(a &gt; 1)   cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt;endl;
    cout  &lt;&lt; endl;

}

int main()
{
    int n;
    cin &gt;&gt; n;
    while (n -- )
    {
        int a;
        cin &gt;&gt; a;
        device(a);

    }

    return 0;
}
</code></pre>
<h4 id="3-2-筛质数">3.2 筛质数</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
const int N = 1e6 + 10;
int prime[N],cnt;
int st[N];

void getprime(int n)
{
    for(int i = 2; i &lt;= n; i ++)
    {
      if(!st[i])    prime[cnt ++] = i;              //如果i是一个质数，那么就把i加入到质数表里
      for(int j = 0; prime[j] &lt;= n / i; j ++)       //枚举质数表中小于n/i的质因子
      {
          st[prime[j] * i] = true;                  //将所有最小质因子为prime[j]的合数筛掉
          if(i % prime[j] == 0) break;              //如果i%prime[j]成立，那么prime[j]是i的最小质因子，并且也是prime[j] * i的最小质因子
          //如果不成立，那么prime[j]也是prime[j] * i的最小质因子
      }
    }
}

int main()
{
    int n;
    cin &gt;&gt; n;

    getprime(n);

    cout &lt;&lt; cnt ;
    return 0;
}
</code></pre>
<h4 id="3-3-试除法求约数">3.3 试除法求约数</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

void ddd(int a)
{
    vector&lt;int&gt; res;
    for(int i = 1; i &lt;= a / i; i ++)
    {
        if(a % i == 0)
        {
            res.push_back(i);
            if(i != a / i)  res.push_back(a / i);
        }
    }

    sort(res.begin(), res.end());
    for(auto t : res)
    cout &lt;&lt; t  &lt;&lt; &quot; &quot;;

    cout &lt;&lt; endl;
}

int main()
{
    int n;
    cin &gt;&gt; n;
    while(n --)
    {
        int a;
        cin &gt;&gt; a;
        ddd(a);
    }


    return 0;
}
</code></pre>
<h4 id="3-4-求n个数乘积的约数个数">3.4 求n个数乘积的约数个数</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;unordered_map&gt;
typedef long long LL;
using namespace std;
const int mod = 1e9 + 7;

int main()
{
    int n;
    cin &gt;&gt; n;
    unordered_map&lt;int, int&gt; primes;
    while(n --)
    {
        int x;
        cin &gt;&gt; x;
        for(int i = 2; i &lt;= x / i; i ++)
        {
            while(x % i == 0)
            {
                x /= i;
                primes[i] ++;
            }
        }
        if(x &gt; 1)   primes[x] ++;
    }
    LL res = 1;
    for(auto prime : primes)
        res = res * (prime.second + 1) % mod;

    cout &lt;&lt; res &lt;&lt; endl;

    return 0;
}
</code></pre>
<h4 id="3-5-求n个数乘积的约数之和">3.5 求n个数乘积的约数之和</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;unordered_map&gt;
typedef long long LL;
using namespace std;
const int mod = 1e9 + 7;

int main()
{
    int n;
    cin &gt;&gt; n;
    unordered_map&lt;int, int&gt; primes;
    while(n --)
    {
        int x;
        cin &gt;&gt; x;
        for(int i = 2; i &lt;= x / i; i ++)
        {
            while(x % i == 0)
            {
                x /= i;
                primes[i] ++;
            }
        }
        if(x &gt; 1)   primes[x] ++;
    }
    LL res = 1;
    for(auto prime : primes)
    {
        int p = prime.first, a = prime.second;
        LL t = 1;
        while(a --)
            t = (t * p + 1) % mod;
        res = res * t % mod;
    }

    cout &lt;&lt; res &lt;&lt; endl;

    return 0;
}
</code></pre>
<h4 id="3-6-线性筛求欧拉函数">3.6 线性筛求欧拉函数</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N = 1e6 + 10;

int primes[N], cnt;
int phi[N];
bool st[N];

LL get_eulers(int n)
{
    phi[1] = 1;
    for(int i = 2; i &lt;= n; i ++)
    {
        if(!st[i])
        {
            primes[cnt ++] = i;
            phi[i] = i - 1;
        }
        for(int j = 0; primes[j] * i &lt;= n; j ++)
        {
            st[primes[j] * i] = true;
            if(i % primes[j] == 0)
            {
                phi[primes[j] * i] = primes[j] * phi[i];
                break;
            }
            phi[primes[j] * i] = phi[i] * (primes[j] - 1);
        }
    }
    LL res = 0;
    for(int i = 1; i &lt;= n; i ++)
        res += phi[i];
    return res;
}

int main()
{
    int n;
    cin &gt;&gt; n;
    cout &lt;&lt; get_eulers(n) &lt;&lt; endl;

    return 0;
}
</code></pre>
<h4 id="3-7-快速幂">3.7 快速幂</h4>
<pre><code class="language-cpp">int qmi(int a, int b, int p)
{
    int res = 1 % p;
    for(; b; b &gt;&gt;= 1)
    {
        if(b &amp; 1)    res = (long long)res * a % p;
        a = (long long)a * a % p;
    }
    return res;
}
</code></pre>
<h4 id="3-8-扩展欧几里得算法-exgcd">3.8 扩展欧几里得算法(EXGCD)</h4>
<p>给定 n 对正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，对于每对数，求出一组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，使其满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>×<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=gcd(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

int exgcd(int a, int b, int &amp;x, int &amp;y)
{
    if(!b)
    {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main()
{
    int n;
    cin &gt;&gt; n;

    while(n --)
    {
        int a, b, x, y;
        cin &gt;&gt; a &gt;&gt; b;
        exgcd(a, b, x, y);

        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h6 id="求解线性同余方程组">求解线性同余方程组</h6>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
typedef long long LL;
using namespace std;

int exgcd(int a, int b, int &amp;x, int &amp;y)
{
    if(!b)
    {
        x = 1, y = 0;
        return a;
    }

    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main()
{
    int n;
    cin &gt;&gt; n;
    while(n --)
    {
        int a, b, m;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; m;
        int x, y;
        int d = exgcd(a, m, x ,y);
        if(b % d)   cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;
        else
        cout &lt;&lt; (LL)x * (b / d) % m &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h4 id="3-9-高斯消元求解线性方程组">3.9 高斯消元求解线性方程组</h4>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 110;
const double eps = 1e-6;
int n;
double a[N][N];

int gauss()
{
    int c, r;
    for(c = 0, r = 0; c &lt; n; c ++)
    {
        int t = r;
        for(int i = r; i &lt; n; i ++)
            if(fabs(a[i][c] &gt; fabs(a[t][c])))
                t = i;
        if(fabs(a[t][c]) &lt; eps)   continue;
        for(int i = c; i &lt;= n; i ++)
            swap(a[t][i], a[r][i]);
        for(int i = n; i &gt;= c; i --)
            a[r][i] /= a[r][c];
        for(int i = r + 1; i &lt; n; i ++)
            if(fabs(a[i][c]) &gt; eps)
                for(int j = n; j &gt;= c; j --)
                    a[i][j] -= a[r][j] * a[i][c];
        r ++;
    }

    if(r &lt; n)
    {
        for(int i = r; i &lt; n; i ++)
            if(fabs(a[i][n]) &gt; eps)
                return 2;
        return 1;
    }
    for(int i = n - 1; i &gt;= 0; i --)
        for(int j = i + 1; j &lt; n; j ++)
            a[i][n] -= a[i][j] * a[j][n];
    return 0;
}

int main()
{
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i ++)
        for(int j = 0; j &lt; n + 1; j ++)
            cin &gt;&gt; a[i][j];

    int t = gauss();
    if(t == 0)
    {
        for(int i = 0; i &lt; n; i ++)
        {
            if (fabs(a[i][n]) &lt; eps) a[i][n] = 0;
            printf(&quot;%.2lf\n&quot;, a[i][n]);
        }
    }
    else if(t == 1) cout &lt;&lt; &quot;Infinite group solutions&quot; &lt;&lt; endl;
    else puts(&quot;No solution&quot;);
    return 0;
}
</code></pre>
<h4 id="3-10-组合数大全">3.10 组合数大全</h4>
<h6 id="3-10-1-求c-a-b-其中1-b-a-2000">3.10.1 求C(a, b)，其中1 ≤ b ≤ a ≤ 2000</h6>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 2010, mod = 1e9 + 7;

int c[N][N];

void init()
{
    for(int i = 0; i &lt; N; i ++)
        for(int j = 0; j &lt;= i; j ++)
            if(!j)  c[i][j] = 1;
            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
}

int main()
{
    init();
    int n;
    cin &gt;&gt; n;
    while(n --)
    {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        cout &lt;&lt; c[a][b] &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h6 id="3-10-2-求c-a-b-其中1-b-a-100000">3.10.2 求C(a, b)，其中1 ≤ b ≤ a ≤ 100000</h6>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N = 100010, mod = 1e9 + 7;

int fact[N], infact[N];

int qmi(int a, int k, int p)
{
    int res = 1;
    for(; k; k &gt;&gt;= 1)
    {
        if(k &amp; 1)   res = (LL)res * a % p;
        a = (LL)a * a % p;
    }

    return res;
}

int main()
{
    fact[0] = infact[0] = 1;
    for(int i = 1; i &lt; N; i ++)
    {
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
    }

    int n;
    cin &gt;&gt; n;
    while(n --)
    {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        cout &lt;&lt; (LL)fact[a] * infact[b] % mod * infact[a - b] % mod &lt;&lt; endl;
    }
}
</code></pre>
<h6 id="3-10-3-求c-a-b-mod-p-其中-1-b-a-10-18-且p为质数">3.10.3 求C(a, b) mod p，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>b</mi><mo>≤</mo><mi>a</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">1 ≤ b ≤ a ≤ 10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>，且p为质数</h6>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
int p;

int qmi(int a, int k)
{
    int res = 1;
    for(; k; k &gt;&gt;= 1)
    {
        if(k &amp; 1)   res = (LL)res * a % p;
        a = (LL)a * a % p;
    }

    return res;
}

int C(LL a, LL b)
{
    int res = 1;
    for(int i = 1, j = a; i &lt;= b; i ++, j --)
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i ,p - 2) % p;
    }

    return res;
}

LL lucas(LL a, LL b)
{
    if(a &lt; p &amp; b &lt; p)   return C(a, b);
    return C(a % p, b % p) * lucas(a / p, b / p) % p;
}

int main()
{
    int n;
    cin &gt;&gt; n;
    while(n --)
    {
        LL a, b;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;
        cout &lt;&lt; lucas(a, b) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h6 id="3-10-4-求c-a-b-其中1-b-a-5000-高精度不取模">3.10.4 求C(a, b)，其中1 ≤ b ≤ a ≤ 5000 (高精度不取模)</h6>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int N = 5010;
int primes[N], cnt;
bool st[N];
int sum[N];

void init(int n)
{
    for(int i = 2; i &lt;= n; i ++)
    {
        if(!st[i])  primes[cnt ++] = i;
        for(int j = 0; primes[j] * i &lt;= n; j ++)
        {
            st[primes[j] * i] = true;
            if(i % primes[j] == 0)  break;
        }
    }
}

int get(int n, int p)  //*n的阶乘里包含的p的个数
{
    int res = 0;
    while(n)
    {
        res += n / p;
        n /= p;
    }
    return res;
}

vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)
{
    vector&lt;int&gt; c;
    int t = 0;
    for(int i = 0; i &lt; a.size(); i ++)
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }

    while(t)
    {
        c.push_back(t % 10);
        t /= 10;
    }
    return c;
}

int main()
{
    int a, b;
    cin &gt;&gt; a &gt;&gt; b;
    init(a);
    for(int i = 0; i &lt; cnt; i ++)
    {
        int p = primes[i];
        sum[i] = get(a, p) - get(b, p) - get(a - b, p);
    }

    vector&lt;int&gt; res;
    res.push_back(1);

    for(int i = 0; i &lt; cnt; i ++)
        for(int j = 0; j &lt; sum[i]; j ++)
            res = mul(res, primes[i]);

    for(int i = res.size() - 1; i &gt;= 0; i --)
        cout &lt;&lt; res[i] ;

    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<h6 id="3-10-5-卡特兰数">3.10.5 卡特兰数</h6>
<pre><code>给定01序列，求任意前缀序列中0的个数不少于1的个数的序列有多少个
</code></pre>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
typedef long long LL;
using namespace std;
const int mod = 1e9 + 7;

int qmi(int a, int k, int p)
{
    int res = 1;
    for(; k; k &gt;&gt;= 1)
    {
        if(k &amp; 1)   res = (LL)res * a % p;
        a=  (LL)a * a % p;
    }

    return res;
}

int main()
{
    int n;
    cin &gt;&gt; n;
    int a = 2 * n, b = n;
    int res = 1;
    for(int i = a; i &gt; a - b; i --)
        res = (LL)res * i % mod;
    for(int i = 1; i &lt;= b; i ++)
        res = (LL)res * qmi(i, mod - 2, mod) % mod;
    res = (LL)res * qmi(n + 1, mod - 2, mod) % mod;

    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="3-11-容斥原理">3.11 容斥原理</h4>
<h6 id="给定n和m个不同的质数p-求1-n中能被p中至少一个数整除的整数有多少个">给定n和m个不同的质数p，求1-n中能被p中至少一个数整除的整数有多少个</h6>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 20;
typedef long long LL;

int n, m;
int p[N];

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; m; i ++)
        cin &gt;&gt; p[i];
    int res = 0;
    for(int i = 1; i &lt; 1 &lt;&lt; m; i ++)
    {
        int t = 1, cnt = 0;
        for(int j = 0; j &lt; m; j ++)
            if(i &gt;&gt; j &amp; 1)
            {
                cnt ++;
                if((LL)t * p[j] &gt; n)
                {
                    t = -1;
                    break;
                }
                t *= p[j];
            }
        if(t != -1)
        {
            if(cnt % 2) res += n / t;
            else res -= n / t;
        }
    }
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}
</code></pre>
<h6 id="n个盒子放a-i枝花-同一个盒子内的花的颜色相同-不同盒子内的画的颜色不同-选出m枝花共有多少种方案">n个盒子放<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>枝花，同一个盒子内的花的颜色相同，不同盒子内的画的颜色不同，选出M枝花共有多少种方案</h6>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;string&gt;
#define int long long
using namespace std;
const int N = 20, mod = 1e9 + 7;
int A[N];
int down = 1;

int qmi(int a, int b, int k)
{
    int res = 1;
    for(; b; b &gt;&gt;= 1)
    {
        if(b &amp; 1)   res = (long long)res * a % k;
        a = (long long)a * a % k;
    }
    return res;
}

int C(int a, int b)
{
    if(a &lt; b)   return 0;
    int up = 1;
    for(int i = a; i &gt; a - b; i --)
        up = i % mod * up % mod;
    return (up * down) % mod;
}

signed main()
{
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    int n, m;
    int res = 0;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; n; i ++) cin &gt;&gt; A[i];
    for(int j = 1; j &lt;= n - 1; j ++)
        down = j * down % mod;
    down = qmi(down, mod - 2, mod);

    for(int i = 0; i &lt; 1 &lt;&lt; n; i ++)
    {
        int a = m + n - 1, b = n - 1;
        int p = 1;
        for(int j = 0; j &lt; n; j ++)
            if(i &gt;&gt; j &amp; 1)
            {
                p *= -1;
                a -= A[j] + 1;
            }
        res = (res + C(a, b) * p) % mod;
    }

    cout &lt;&lt; (res + mod) % mod &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="3-12-博弈论">3.12 博弈论</h4>
<h6 id="3-12-1-nim博弈">3.12.1 NIM博弈</h6>
<p>给定 n 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。</p>
<p>问如果两人都采用最优策略，先手是否必胜。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

int main()
{
    int n;
    int res = 0;
    cin &gt;&gt; n;
    while(n --)
    {
        int x;
        cin &gt;&gt; x;
        res ^= x;
    }

    if(res) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
    else
    cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
}
</code></pre>
<h6 id="3-12-2-台阶-nim游戏">3.12.2 台阶-NIM游戏</h6>
<p>有一个 n 级台阶的楼梯，每级台阶上都有若干个石子，其中第 i 级台阶上有 ai 个石子(i≥1)。</p>
<p>两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。</p>
<p>已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。</p>
<p>问如果两人都采用最优策略，先手是否必胜。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int main()
{
    int n;
    scanf(&quot;%d&quot;, &amp;n);

    int res = 0;
    for (int i = 1; i &lt;= n; i ++ )
    {
        int x;
        scanf(&quot;%d&quot;, &amp;x);
        if (i &amp; 1) res ^= x;
    }

    if (res) puts(&quot;Yes&quot;);
    else puts(&quot;No&quot;);

    return 0;
}
</code></pre>
<h6 id="3-12-3-集合-nim游戏">3.12.3 集合-NIM游戏</h6>
<p>给定 n 堆石子以及一个由 k 个不同正整数构成的数字集合 S。</p>
<p>现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合 S，最后无法进行操作的人视为失败。</p>
<p>问如果两人都采用最优策略，先手是否必胜。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;unordered_set&gt;
using namespace std;
const int N = 110, M = 10010;
int n, m;
int s[N], f[M];

int sg(int x)
{
    if(f[x] != -1)  return f[x];
    unordered_set&lt;int&gt; S;
    for(int i = 0; i &lt; m; i ++)
    {
        int sum = s[i];
        if(x &gt;= sum)    S.insert(sg(x - sum));
    }
    for(int i = 0; ; i ++)
    {
        if(!S.count(i))
            return f[x] = i;
    }
}

int main()
{
    cin &gt;&gt; m;
    for(int i = 0; i &lt; m; i ++)
        cin &gt;&gt; s[i];
    cin &gt;&gt; n;
    memset(f, -1, sizeof f);
    int res = 0;
    for(int i = 0; i &lt; n; i ++)
    {
        int x;
        cin &gt;&gt; x;
        res ^= sg(x);
    }

    if(res) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
    else
    cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    return 0;
}
</code></pre>
<h6 id="3-12-4-拆分-nim游戏">3.12.4 拆分-NIM游戏</h6>
<p>给定 n 堆石子，两位玩家轮流操作，每次操作可以取走其中的一堆石子，然后放入两堆<strong>规模更小</strong>的石子（新堆规模可以为 0，且两个新堆的石子总数可以大于取走的那堆石子数），最后无法进行操作的人视为失败。</p>
<p>问如果两人都采用最优策略，先手是否必胜。</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_set&gt;

using namespace std;

const int N = 110;


int n;
int f[N];


int sg(int x)
{
    if (f[x] != -1) return f[x];

    unordered_set&lt;int&gt; S;
    for (int i = 0; i &lt; x; i ++ )
        for (int j = 0; j &lt;= i; j ++ )
            S.insert(sg(i) ^ sg(j));

    for (int i = 0;; i ++ )
        if (!S.count(i))
            return f[x] = i;
}


int main()
{
    cin &gt;&gt; n;

    memset(f, -1, sizeof f);

    int res = 0;
    while (n -- )
    {
        int x;
        cin &gt;&gt; x;
        res ^= sg(x);
    }

    if (res) puts(&quot;Yes&quot;);
    else puts(&quot;No&quot;);

    return 0;
}
</code></pre>
<h4 id="3-13-矩阵乘法">3.13 矩阵乘法</h4>
<h6 id="求斐波那契数列的前n项和">求斐波那契数列的前n项和</h6>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 3;
typedef long long LL;
int n, m;
void mul(int c[], int a[], int b[][N])
{
    int temp[N] = {0};
    for(int i = 0; i &lt; N; i ++)
        for(int j = 0; j &lt; N; j ++)
            temp[i] = (temp[i] + (LL)a[j] * b[j][i]) % m;
    memcpy(c, temp, sizeof temp);
}

void mul(int c[][N], int a[][N], int b[][N])
{
    int temp[N][N] = {0};
    for(int i = 0; i &lt; N; i ++)
        for(int j = 0; j &lt; N; j ++)
            for(int k = 0; k &lt; N; k ++)
                temp[i][j] = (temp[i][j] + (LL)a[i][k] * b[k][j]) % m;
    memcpy(c, temp, sizeof temp);
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    int f1[N] = {1, 1, 1};
    int a[N][N] = {
        {0, 1, 0},
        {1, 1, 1},
        {0, 0, 1}
    };

    n --;
    for(; n; n &gt;&gt;= 1)
    {
        if(n &amp; 1)   mul(f1, f1, a);
        mul(a, a, a);
    }

    cout &lt;&lt; f1[2] &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>用 T(n)=(F1+2F2+3F3+…+nFn)modm 表示 Fibonacci 数列前 n 项变形后的和 mod m 的值，求出 T(n) 的值。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int N = 4;
int n, m;

void mul(int c[][N], int a[][N], int b[][N])    //*c = a * b
{
    static int t[N][N];
    memset(t, 0, sizeof t);
    for(int i = 0; i &lt; N; i ++)
        for(int j = 0; j &lt; N; j ++)
            for(int k = 0; k &lt; N; k ++)
                t[i][j] = (t[i][j] + (LL)a[i][k] * b[k][j]) % m;
    memcpy(c, t, sizeof t);
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    int f1[N][N] = {1, 1, 1, 0};
    int a[N][N] = {
        {0, 1, 0, 0},
        {1, 1, 1, 0},
        {0, 0, 1, 1},
        {0, 0, 0, 1},
    };

    int k = n - 1;
    for(; k; k &gt;&gt;= 1)
    {
        if(k &amp; 1)   mul(f1, f1, a);
        mul(a, a, a);
    }

    cout &lt;&lt; (((LL)n * f1[0][2] - f1[0][3]) % m + m) % m &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="3-14-莫比乌斯函数与莫比乌斯反演与积性函数">3.14 莫比乌斯函数与莫比乌斯反演与积性函数</h4>
<pre><code class="language-cpp">//待补充
</code></pre>
<h1>4. 动态规划</h1>
<h2 id="数字三角形模型">数字三角形模型</h2>
<h3 id="4-1-一条路径点权和最大-摘花生">4.1 一条路径点权和最大(摘花生)</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110;

int n, m;
int w[N][N];
int f[N][N];

int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T -- )
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 1; i &lt;= n; i ++ )
            for (int j = 1; j &lt;= m; j ++ )
                scanf(&quot;%d&quot;, &amp;w[i][j]);

        for (int i = 1; i &lt;= n; i ++ )
            for (int j = 1; j &lt;= m; j ++ )
                f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j];

        printf(&quot;%d\n&quot;, f[n][m]);
    }

    return 0;
}
</code></pre>
<h3 id="4-2-一条路径点权和最小">4.2 一条路径点权和最小</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110, INF = 1e9;

int n;
int w[N][N];
int f[N][N];

int main()
{
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 1; i &lt;= n; i ++ )
        for (int j = 1; j &lt;= n; j ++ )
            scanf(&quot;%d&quot;, &amp;w[i][j]);

    for (int i = 1; i &lt;= n; i ++ )
        for (int j = 1; j &lt;= n; j ++ )
            if (i == 1 &amp;&amp; j == 1) f[i][j] = w[i][j];    // 特判左上角
            else
            {
                f[i][j] = INF;
                if (i &gt; 1) f[i][j] = min(f[i][j], f[i - 1][j] + w[i][j]);// 只有不在第一行的时候，才可以从上面过来
                if (j &gt; 1) f[i][j] = min(f[i][j], f[i][j - 1] + w[i][j]);// 只有不在第一列的时候，才可以从左边过来
            }

    printf(&quot;%d\n&quot;, f[n][n]);

    return 0;
}
</code></pre>
<h3 id="4-3-两条路径点权和最大">4.3 两条路径点权和最大</h3>
<p>该类问题满足：左上走到右下走两次，格点数被取过第二次就<strong>不会</strong>再取(坐标和相加相等即被走了两次)</p>
<pre><code class="language-cpp">// 两条路径都是：左上到右下
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 15;

int n;
int w[N][N];
int f[N * 2][N][N];

int main()
{
    scanf(&quot;%d&quot;, &amp;n);

    int a, b, c;
    while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c) w[a][b] = c;

    for (int k = 2; k &lt;= n + n; k ++ )
        for (int i1 = 1; i1 &lt;= n; i1 ++ )
            for (int i2 = 1; i2 &lt;= n; i2 ++ )
            {
                int j1 = k - i1, j2 = k - i2;
                if (j1 &gt;= 1 &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= 1 &amp;&amp; j2 &lt;= n)
                {
                    int t = w[i1][j1];
                    if (i1 != i2) t += w[i2][j2];
                    int &amp;x = f[k][i1][i2];
                    x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);
                    x = max(x, f[k - 1][i1 - 1][i2] + t);
                    x = max(x, f[k - 1][i1][i2 - 1] + t);
                    x = max(x, f[k - 1][i1][i2] + t);
                }
            }

    printf(&quot;%d\n&quot;, f[n + n][n][n]);
    return 0;
}
</code></pre>
<pre><code class="language-cpp">// 先左上到右下，再右下到左上
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1e5 + 10;

int n, m;
int g[55][55], f[110][55][55];
int main() {
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1;i &lt;= n;i ++)
		for(int j = 1;j &lt;= m;j ++)
			cin &gt;&gt; g[i][j];
	for(int k = 2; k &lt;= n + m;k ++) {
		for(int i1 = max(1, k - m);i1 &lt;= min(k - 1, n);i1 ++) {
			for(int i2 = max(1, k - m);i2 &lt;= min(k - 1, n);i2 ++) {
				int j1 = k - i1, j2 = k - i2;
				int t = g[i1][j1];
				if(i1 != i2) t += g[i2][j2];
				int &amp;x = f[k][i1][i2];
				x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);
				x = max(x, f[k - 1][i1 - 1][i2] + t);
				x = max(x, f[k - 1][i1][i2 - 1] + t);
				x = max(x, f[k - 1][i1][i2] + t);
			}
		}  
	}
	cout &lt;&lt; f[n + m][n][n] &lt;&lt; endl;
	return 0;
}
</code></pre>
<h2 id="最长上升子序列模型-lis">最长上升子序列模型（LIS）</h2>
<h3 id="4-4-基本转换模型">4.4 基本转换模型</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
const int N = 1e5 + 10;
int n, q[N], a[N];
int ask(int s,int t) {
	q[0] = -2e9;
	int len = 0;
    for(int i = s;i &lt; t;i ++) {
        int l = 0, r = len;
        while(l &lt; r) {
            int mid = l + r + 1 &gt;&gt; 1;
            if(q[mid] &lt; a[i]) l = mid;
            else r = mid - 1;
        }
        len = max(len, r + 1);
        q[r + 1] = a[i];
    }
	return len;
}

int main() {
	int n;
	cin &gt;&gt; n;
	for(int i = 0;i &lt; n;i ++) cin &gt;&gt;  a[i];
	cout &lt;&lt; ask(0, n) &lt;&lt; endl; // 左闭右开
	return 0;
}

</code></pre>
<h3 id="4-5上下模型">4.5上下模型</h3>
<p>先上升再下降，一旦下降就不再上升，<strong>中间高两边矮</strong>的最长子序列</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

const int N = 1e3 + 10;
int f[N][2], n, a[N];
int main () {
	cin &gt;&gt; n;
	for(int i = 0;i &lt; n;i ++ ) cin &gt;&gt; a[i];
	
	for(int i = 0;i &lt; n;i ++) {
		f[i][1] = f[i][0] = 1;
		for(int k = 0;k &lt; i;k ++) {
			if(a[i] &gt; a[k]) f[i][0] = max(f[i][0], f[k][0] + 1);
			if(a[i] &lt; a[k]) f[i][1] = max(f[i][1], max(f[k][0], f[k][1]) + 1);
		}
	}
	int res = 0;
	for(int i = 0;i &lt; n;i ++) res = max(res, max(f[i][1], f[i][0]));
	cout &lt;&lt; res &lt;&lt; endl;
	return 0;
}
</code></pre>
<h3 id="4-6-最大上升子序列和">4.6 最大上升子序列和</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1010;
int a[N], n, f[N];
int main () {
    cin &gt;&gt; n;
    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];
    for(int i = 1;i &lt;= n;i ++) {
        f[i] = a[i];
        for(int k = 1;k &lt; i;k ++) {
            if(a[k] &lt; a[i]) f[i] = max(f[i], f[k] + a[i]);
        }
    }
    int res = 0;
    for(int i = 1;i &lt;= n;i ++) res = max(res, f[i]);
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="4-7-dilworth定理-最少下降子序列数等于最长上升子序列长度">4.7 Dilworth定理（最少下降子序列数等于最长上升子序列长度）</h3>
<h2 id="最长公共子序列">最长公共子序列</h2>
<h3 id="4-8-最长公共上升子序列-lics和lcs">4.8 最长公共上升子序列（LICS和LCS）</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 3010;

int n, f[N][N], a[N], b[N];
int main () {
	cin &gt;&gt; n;
	for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];
	for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; b[i];
	for(int i = 1;i &lt;= n;i ++) {
		int res = 0;
		if(b[1] &lt; a[i]) res = f[i - 1][1];
		for(int j = 1;j &lt;= n;j ++) {
			if(a[i] == b[j]) f[i][j] = res + 1;
			else f[i][j] = f[i - 1][j];
			if(b[j] &lt; a[i]) res = max(res, f[i - 1][j]);
		}
	}
	int ans = 0;
	for(int i = 1;i &lt;= n;i ++) ans = max(ans, f[n][i]);
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
<h3 id="4-9-最长公共子序列">4.9 最长公共子序列</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 1010;

int n, m;
char a[N], b[N];
int f[N][N];

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    scanf(&quot;%s%s&quot;, a + 1, b + 1);
    for (int i = 1; i &lt;= n; i ++ )
        for (int j = 1; j &lt;= m; j ++ ) {
            f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
        }
    printf(&quot;%d\n&quot;, f[n][m]);
    return 0;
}
</code></pre>
<h2 id="4-10-最短编辑距离">4.10 最短编辑距离</h2>
<p>A到B最少操作次数</p>
<p>操作：</p>
<ol>
<li>删除–将字符串 A 中的某个字符删除。</li>
<li>插入–在字符串 A 的某个位置插入某个字符。</li>
<li>替换–将字符串 A 中的某个字符替换为另一个字符。</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;

using namespace std;

int n,m;
char a[1010],b[1010];
int f[1010][1010];
int main()
{
    scanf(&quot;%d%s&quot;,&amp;n, a + 1);
    scanf(&quot;%d%s&quot;,&amp;m, b + 1);
    for(int i = 0;i &lt;= m;i ++) f[0][i] = i;
    for(int i = 0;i &lt;= n;i ++) f[i][0] = i;
    for(int i = 1;i &lt;= n;i ++)
    {
        for(int j = 1;j &lt;= m;j ++)
        {
            f[i][j] = min(f[i][j - 1], f[i - 1][j]) + 1;
            if(a[i] != b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1);
            else f[i][j] = min(f[i][j], f[i - 1][j - 1]);
        }
    }
    cout &lt;&lt; f[n][m] &lt;&lt; endl;
    return 0;
}
</code></pre>
<h2 id="背包">背包</h2>
<h3 id="4-11-01背包问题">4.11 01背包问题</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int M = 20010;

int n, m;
int f[M];

int main()
{
    cin &gt;&gt; m &gt;&gt; n;
    for (int i = 0; i &lt; n; i ++ )
    {
        int v;
        cin &gt;&gt; v;
        for (int j = m; j &gt;= v; j -- )
            f[j] = max(f[j], f[j - v] + v);
    }

    cout &lt;&lt; m - f[m] &lt;&lt; endl;

    return 0;
}
</code></pre>
<h4 id="01背包求方案数">01背包求方案数</h4>
<pre><code class="language-cpp">//数字组合方案，非最优最大价值方案数
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 10010;

int n, m;
int f[N];
int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    f[0] = 1;
    for (int i = 0; i &lt; n; i ++ )
    {
        int v;
        cin &gt;&gt; v;
        for (int j = m; j &gt;= v; j -- )
            f[j] += f[j - v];
    }
    cout &lt;&lt; f[m] &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="4-12-完全背包问题">4.12 完全背包问题</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];

    for (int i = 1; i &lt;= n; i ++ )
        for (int j = v[i]; j &lt;= m; j ++ )
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout &lt;&lt; f[m] &lt;&lt; endl;

    return 0;
}
</code></pre>
<h4 id="完全背包求方案数">完全背包求方案数</h4>
<pre><code class="language-cpp">//数字组合方案，非最优最大价值方案数
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

typedef long long LL;
const LL mod=2147483648LL;//默认数字为int类型，因此数字后要加LL
int n;
long long f[4005];

int main() {
    scanf(&quot;%d&quot;,&amp;n);
    f[0]=1;
    for(int i = 1;i &lt; n;i ++)
        for(int j = i;j &lt;= n;j ++)
            f[j] = (f[j] + f[j - i]) % mod;
    printf(&quot;%d&quot;,f[n]);
}
</code></pre>
<h3 id="4-13-多重背包问题">4.13 多重背包问题</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
const int N = 1e5+10;

int n, m;
struct node {
	int v, w;
};
vector&lt;node&gt; nodes;
int f[N];
int main() {
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1;i &lt;= n;i ++) {
		int v, w ,s;
		cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;
		for(int k = 1;k &lt;= s;k &lt;&lt;= 1) nodes.push_back({v*k, w*k}), s -= k;
		if(s) nodes.push_back({v*s, w*s});
	}
	for(auto t : nodes) {
		for(int j = m;j &gt;= t.v;j -- ) {
			f[j] = max(f[j], f[j - t.v] + t.w);
		}
	}
	cout &lt;&lt; f[m] &lt;&lt; endl;
	return 0;
}
</code></pre>
<p><strong>单调队列优化</strong></p>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 100010;

int n, m;
int f[N], g[N], q[N];

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; i ++ )
    {
        int v, w, s;
        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;
        memcpy(g, f, sizeof f);
        for (int j = 0; j &lt; v; j ++ )
        {
            int hh = 0, tt = -1;
            for (int k = j; k &lt;= m; k += v)
            {
                if (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh ++ ;
                while (hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt -- ;
                q[ ++ tt] = k;
                f[k] = g[q[hh]] + (k - q[hh]) / v * w;
            }
        }
    }
    cout &lt;&lt; f[m] &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="4-14-混合背包问题">4.14 混合背包问题</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
const int N = 1010;

int n, m;
int f[N];
int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; i ++ )
    {
        int v, w, s;
        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;
        if (!s)
        {
            for (int j = v; j &lt;= m; j ++ )
                f[j] = max(f[j], f[j - v] + w);
        }
        else
        {
            if (s == -1) s = 1;
            for (int k = 1; k &lt;= s; k *= 2)
            {
                for (int j = m; j &gt;= k * v; j -- )
                    f[j] = max(f[j], f[j - k * v] + k * w);
                s -= k;
            }
            if (s)
            {
                for (int j = m; j &gt;= s * v; j -- )
                    f[j] = max(f[j], f[j - s * v] + s * w);
            }
        }
    }
    cout &lt;&lt; f[m] &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="4-15-二维费用的背包问题">4.15 二维费用的背包问题</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
const int N = 110;

int n, V, M;
int f[N][N];

int main()
{
    cin &gt;&gt; n &gt;&gt; V &gt;&gt; M;
    for (int i = 0; i &lt; n; i ++ )
    {
        int v, m, w;
        cin &gt;&gt; v &gt;&gt; m &gt;&gt; w;
        for (int j = V; j &gt;= v; j -- )
            for (int k = M; k &gt;= m; k -- )
                f[j][k] = max(f[j][k], f[j - v][k - m] + w);
    }
    cout &lt;&lt; f[V][M] &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="4-16-分组背包问题">4.16 分组背包问题</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 110;

int n, m;
int v[N][N], w[N][N], s[N];
int f[N];

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i ++ )
    {
        cin &gt;&gt; s[i];
        for (int j = 0; j &lt; s[i]; j ++ )
            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];
    }
    for (int i = 1; i &lt;= n; i ++ )
        for (int j = m; j &gt;= 0; j -- )
            for (int k = 0; k &lt; s[i]; k ++ )
                if (v[i][k] &lt;= j)
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
    cout &lt;&lt; f[m] &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="4-17-有依赖的背包问题">4.17 有依赖的背包问题</h3>
<p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 110;

int n, m;
int v[N], w[N];
int h[N], e[N], ne[N], idx;
int f[N][N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    for (int i = h[u]; ~i; i = ne[i])   // 循环物品组
    {
        int son = e[i];
        dfs(e[i]);

        // 分组背包
        for (int j = m - v[u]; j &gt;= 0; j -- )  // 循环体积
            for (int k = 0; k &lt;= j; k ++ )  // 循环决策
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
    }

    // 将物品u加进去
    for (int i = m; i &gt;= v[u]; i -- ) f[u][i] = f[u][i - v[u]] + w[u];
    for (int i = 0; i &lt; v[u]; i ++ ) f[u][i] = 0;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;

    memset(h, -1, sizeof h);
    int root;
    for (int i = 1; i &lt;= n; i ++ )
    {
        int p;
        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p;
        if (p == -1) root = i;
        else add(p, i);
    }
    dfs(root);
    cout &lt;&lt; f[root][m] &lt;&lt; endl;
    return 0;
}
/*
5 7
2 3 -1
2 2 1
3 5 1
4 7 2
3 6 2

11
*/
</code></pre>
<h3 id="4-18-最优最大价值方案数">4.18 最优最大价值方案数</h3>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
using namespace std;
const int N = 1010, mod = 1e9 + 7;

int n, m;
int f[N], g[N];
int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    memset(f, -0x3f, sizeof f);
    f[0] = 0;
    g[0] = 1;

    for (int i = 0; i &lt; n; i ++ )
    {
        int v, w;
        cin &gt;&gt; v &gt;&gt; w;
        for (int j = m; j &gt;= v; j -- )
        {
            int maxv = max(f[j], f[j - v] + w);
            int s = 0;
            if (f[j] == maxv) s = g[j];
            if (f[j - v] + w == maxv) s = (s + g[j - v]) % mod;
            f[j] = maxv, g[j] = s;
        }
    }
    
    int res = 0;
    for (int i = 1; i &lt;= m; i ++ )
        if (f[i] &gt; f[res])
            res = i;
    
    int sum = 0;
    for (int i = 0; i &lt;= m; i ++ )
        if (f[i] == f[res])
            sum = (sum + g[i]) % mod;
    cout &lt;&lt; sum &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="4-19-背包问题求具体方案">4.19 背包问题求具体方案</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];

    for (int i = n; i &gt;= 1; i -- )
        for (int j = 0; j &lt;= m; j ++ )
        {
            f[i][j] = f[i + 1][j];
            if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);
        }

    int j = m;
    for (int i = 1; i &lt;= n; i ++ )
        if (j &gt;= v[i] &amp;&amp; f[i][j] == f[i + 1][j - v[i]] + w[i])
        {
            cout &lt;&lt; i &lt;&lt; ' ';
            j -= v[i];
        }

    return 0;
}
</code></pre>
<h2 id="状态机模型">状态机模型</h2>
<p><strong>大盗阿福</strong></p>
<p>阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n;
int w[N], f[N][2];

int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T -- )
    {
        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);

        for (int i = 1; i &lt;= n; i ++ )
        {
            f[i][0] = max(f[i - 1][0], f[i - 1][1]);
            f[i][1] = f[i - 1][0] + w[i];
        }

        printf(&quot;%d\n&quot;, max(f[n][0], f[n][1]));
    }

    return 0;
}
/*
2
3
1 8 2
4
10 7 6 14

8
24
*/
</code></pre>
<p><strong>股票买卖 IV</strong></p>
<p>给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i天的价格。设计一个算法来计算你所能获取的最大利润，你最多可以完成 k笔交易。<br>
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。一次买入卖出合为一笔交易。</p>
<pre><code class="language-cpp">// 输出一个整数，表示最大利润。
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010, M = 110, INF = 0x3f3f3f3f;

int n, m;
int w[N];
int f[N][M][2];

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);

    memset(f, -0x3f, sizeof f);
    for (int i = 0; i &lt;= n; i ++ ) f[i][0][0] = 0;

    for (int i = 1; i &lt;= n; i ++ )
        for (int j = 1; j &lt;= m; j ++ )
        {
            f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + w[i]);
            f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - w[i]);
        }

    int res = 0;
    for (int i = 0; i &lt;= m; i ++ ) res = max(res, f[n][i][0]);

    printf(&quot;%d\n&quot;, res);

    return 0;
}
</code></pre>
<p><strong>股票买卖 V</strong><br>
给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。<br>
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<pre><code class="language-cpp">// 算出最大利润
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010, INF = 0x3f3f3f3f;

int n;
int w[N];
int f[N][3];

int main()
{
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]);

    f[0][0] = f[0][1] = -INF, f[0][2] = 0;
    for (int i = 1; i &lt;= n; i ++ )
    {
        f[i][0] = max(f[i - 1][0], f[i - 1][2] - w[i]);
        f[i][1] = f[i - 1][0] + w[i];
        f[i][2] = max(f[i - 1][2], f[i - 1][1]);
    }

    printf(&quot;%d\n&quot;, max(f[n][1], f[n][2]));

    return 0;
}
</code></pre>
<p><strong>设计密码</strong><br>
你现在需要设计一个密码 S，S需要满足：</p>
<ul>
<li>S 的长度是 N；</li>
<li>S 只包含小写英文字母；</li>
<li>S 不包含子串 T；<br>
例如：abc 和 abcde 是 abcde 的子串，abd 不是 abcde的子串。<br>
请问共有多少种不同的密码满足要求？ 由于答案会非常大，请输出答案模 109+7的余数。</li>
</ul>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 55, mod = 1e9 + 7;

int n, m;
char str[N];
int nxt[N];
int f[N][N];

int main()
{
    cin &gt;&gt; n &gt;&gt; str + 1;

    m = strlen(str + 1);

    for (int i = 2, j = 0; i &lt;= m; i ++ )
    {
        while (j &amp;&amp; str[i] != str[j + 1]) j = nxt[j];
        if (str[i] == str[j + 1]) j ++ ;
        nxt[i] = j;
    }

    f[0][0] = 1;
    for (int i = 0; i &lt; n; i ++ )
        for (int j = 0; j &lt; m; j ++ )
            for (char k = 'a'; k &lt;= 'z'; k ++ )
            {
                int u = j;
                while (u &amp;&amp; k != str[u + 1]) u = nxt[u];
                if (k == str[u + 1]) u ++ ;
                if (u &lt; m) f[i + 1][u] = (f[i + 1][u] + f[i][j]) % mod;
            }

    int res = 0;
    for (int i = 0; i &lt; m; i ++ ) res = (res + f[n][i]) % mod;

    cout &lt;&lt; res &lt;&lt; endl;

    return 0;
}
</code></pre>
<p><strong>修复DNA</strong></p>
<p>生物学家终于发明了修复DNA的技术，能够将包含各种遗传疾病的DNA片段进行修复。为了简单起见，DNA看作是一个由’A’, ‘G’ , ‘C’ , ‘T’构成的字符串。修复技术就是通过改变字符串中的一些字符，从而消除字符串中包含的致病片段。需注意，被修复的DNA片段中，仍然只能包含字符’A’, ‘G’ , ‘C’ , ‘T’。</p>
<p>请你帮助生物学家修复给定的DNA片段，并且修复过程中改变的字符数量要尽可能的少。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1010;

int n, m;
int tr[N][4], dar[N], idx;
int q[N], ne[N];
char str[N];

int f[N][N];

int get(char c)
{
    if (c == 'A') return 0;
    if (c == 'T') return 1;
    if (c == 'G') return 2;
    return 3;
}

void insert()
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int t = get(str[i]);
        if (tr[p][t] == 0) tr[p][t] = ++ idx;
        p = tr[p][t];
    }
    dar[p] = 1;
}

void build()
{
    int hh = 0, tt = -1;
    for (int i = 0; i &lt; 4; i ++ )
        if (tr[0][i])
            q[ ++ tt] = tr[0][i];

    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = 0; i &lt; 4; i ++ )
        {
            int p = tr[t][i];
            if (!p) tr[t][i] = tr[ne[t]][i];
            else
            {
                ne[p] = tr[ne[t]][i];
                q[ ++ tt] = p;
                dar[p] |= dar[ne[p]];
            }
        }
    }
}

int main()
{
    int T = 1;
    while (scanf(&quot;%d&quot;, &amp;n), n)
    {
        memset(tr, 0, sizeof tr);
        memset(dar, 0, sizeof dar);
        memset(ne, 0, sizeof ne);
        idx = 0;

        for (int i = 0; i &lt; n; i ++ )
        {
            scanf(&quot;%s&quot;, str);
            insert();
        }

        build();

        scanf(&quot;%s&quot;, str + 1);
        m = strlen(str + 1);

        memset(f, 0x3f, sizeof f);
        f[0][0] = 0;
        for (int i = 0; i &lt; m; i ++ )
            for (int j = 0; j &lt;= idx; j ++ )
                for (int k = 0; k &lt; 4; k ++ )
                {
                    int t = get(str[i + 1]) != k;
                    int p = tr[j][k];
                    if (!dar[p]) f[i + 1][p] = min(f[i + 1][p], f[i][j] + t);
                }

        int res = 0x3f3f3f3f;
        for (int i = 0; i &lt;= idx; i ++ ) res = min(res, f[m][i]);

        if (res == 0x3f3f3f3f) res = -1;
        printf(&quot;Case %d: %d\n&quot;, T ++, res);
    }

    return 0;
}
/*
2
AAA
AAG
AAAG    
2
A
TG
TGAATG
4
A
G
C
T
AGT
0

Case 1: 1
Case 2: 4
Case 3: -1
*/
</code></pre>
<h2 id="状态压缩dp">状态压缩DP</h2>
<p><strong>小国王</strong></p>
<pre><code class="language-cpp">// 在 n×n 的棋盘上放 k 个国王，国王可攻击相邻的 8 个格子，求使它们无法互相攻击的方案总数。
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

typedef long long LL;

const int N = 12, M = 1 &lt;&lt; 10, K = 110;

int n, m;
vector&lt;int&gt; state;
int cnt[M];
vector&lt;int&gt; head[M];
LL f[N][K][M];

bool check(int state)
{
    for (int i = 0; i &lt; n; i ++ )
        if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; i + 1 &amp; 1))
            return false;
    return true;
}

int count(int state)
{
    int res = 0;
    for (int i = 0; i &lt; n; i ++ ) res += state &gt;&gt; i &amp; 1;
    return res;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;

    for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )
        if (check(i))
        {
            state.push_back(i);
            cnt[i] = count(i);
        }

    for (int i = 0; i &lt; state.size(); i ++ )
        for (int j = 0; j &lt; state.size(); j ++ )
        {
            int a = state[i], b = state[j];
            if ((a &amp; b) == 0 &amp;&amp; check(a | b))
                head[i].push_back(j);
        }

    f[0][0][0] = 1;
    for (int i = 1; i &lt;= n + 1; i ++ )
        for (int j = 0; j &lt;= m; j ++ )
            for (int a = 0; a &lt; state.size(); a ++ )
                for (int b : head[a])
                {
                    int c = cnt[state[a]];
                    if (j &gt;= c)
                        f[i][j][a] += f[i - 1][j - c][b];
                }

    cout &lt;&lt; f[n + 1][m][0] &lt;&lt; endl;

    return 0;
}
/*
3 2

16
*/
</code></pre>
<p><strong>玉米田</strong></p>
<p>农夫约翰的土地由 M×N 个小方格组成，现在他要在土地里种植玉米。非常遗憾，部分土地是不育的，无法种植。<br>
而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。<br>
现在给定土地的大小，请你求出共有多少种种植方法。土地上什么都不种也算一种方法。</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

const int N = 14, M = 1 &lt;&lt; 12, mod = 1e8;

int n, m;
int w[N];
vector&lt;int&gt; state;
vector&lt;int&gt; head[M];
int f[N][M];

bool check(int state)
{
    for (int i = 0; i + 1 &lt; m; i ++ )
        if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; i + 1 &amp; 1))
            return false;
    return true;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i ++ )
        for (int j = 0; j &lt; m; j ++ )
        {
            int t;
            cin &gt;&gt; t;
            w[i] += !t * (1 &lt;&lt; j);
        }

    for (int i = 0; i &lt; 1 &lt;&lt; m; i ++ )
        if (check(i))
            state.push_back(i);

    for (int i = 0; i &lt; state.size(); i ++ )
        for (int j = 0; j &lt; state.size(); j ++ )
        {
            int a = state[i], b = state[j];
            if (!(a &amp; b))
                head[i].push_back(j);
        }

    f[0][0] = 1;
    for (int i = 1; i &lt;= n + 1; i ++ )
        for (int j = 0; j &lt; state.size(); j ++ )
            if (!(state[j] &amp; w[i]))
                for (int k : head[j])
                    f[i][j] = (f[i][j] + f[i - 1][k]) % mod;

    cout &lt;&lt; f[n + 1][0] &lt;&lt; endl;

    return 0;
}
/*
2 3
1 1 1
0 1 0

9
*/
</code></pre>
<h2 id="区间dp">区间DP</h2>
<p><strong>环形石子合并</strong></p>
<p>求：</p>
<ul>
<li>选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。</li>
<li>选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。</li>
</ul>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 410, INF = 0x3f3f3f3f;

int n;
int w[N], s[N];
int f[N][N], g[N][N];

int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i ++ )
    {
        cin &gt;&gt; w[i];
        w[i + n] = w[i];
    }

    for (int i = 1; i &lt;= n * 2; i ++ ) s[i] = s[i - 1] + w[i];

    memset(f, 0x3f, sizeof f);
    memset(g, -0x3f, sizeof g);

    for (int len = 1; len &lt;= n; len ++ )
        for (int l = 1; l + len - 1 &lt;= n * 2; l ++ )
        {
            int r = l + len - 1;
            if (l == r) f[l][r] = g[l][r] = 0;
            else
            {
                for (int k = l; k &lt; r; k ++ )
                {
                    f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
                    g[l][r] = max(g[l][r], g[l][k] + g[k + 1][r] + s[r] - s[l - 1]);
                }
            }
        }

    int minv = INF, maxv = -INF;
    for (int i = 1; i &lt;= n; i ++ )
    {
        minv = min(minv, f[i][i + n - 1]);
        maxv = max(maxv, g[i][i + n - 1]);
    }

    cout &lt;&lt; minv &lt;&lt; endl &lt;&lt; maxv &lt;&lt; endl;

    return 0;
}
</code></pre>
<p><strong>加分二叉树</strong><br>
设一个 n 个节点的二叉树 tree 的中序遍历为（1,2,3,…,n），其中数字 1,2,3,…,n 为节点编号。<br>
每个节点都有一个分数（均为正整数），记第 i 个节点的分数为 di，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下：     <br>
subtree的左子树的加分 × subtree的右子树的加分 ＋ subtree的根的分数 <br>
若某个子树为空，规定其加分为 1。<br>
叶子的加分就是叶节点本身的分数，不考虑它的空子树。<br>
试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树 tree。</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 30;

int n;
int w[N];
int f[N][N], g[N][N];

void dfs(int l, int r)
{
    if (l &gt; r) return;
    int k = g[l][r];
    cout &lt;&lt; k &lt;&lt; ' ';
    dfs(l, k - 1);
    dfs(k + 1, r);
}

int main()
{
    cin &gt;&gt; n;

    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; w[i];

    for (int len = 1; len &lt;= n; len ++ )
        for (int l = 1; l + len - 1 &lt;= n; l ++ )
        {
            int r = l + len - 1;
            if (len == 1) f[l][r] = w[l], g[l][r] = l;
            else
            {
                for (int k = l; k &lt;= r; k ++ )
                {
                    int left = k == l ? 1 : f[l][k - 1];
                    int right = k == r ? 1 : f[k + 1][r];
                    int score = left * right + w[k];
                    if (f[l][r] &lt; score)
                    {
                        f[l][r] = score;
                        g[l][r] = k;
                    }
                }
            }
        }

    cout &lt;&lt; f[1][n] &lt;&lt; endl;
    dfs(1, n);
    return 0;
}
</code></pre>
<p><strong>凸多边形的划分</strong></p>
<p>给定一个具有 N 个顶点的凸多边形，将顶点从 1 至 N 标号，每个顶点的权值都是一个正整数。<br>
将这个凸多边形划分成 N−2 个互不相交的三角形，对于每个三角形，其三个顶点的权值相乘都可得到一个权值乘积，试求所有三角形的顶点权值乘积之和至少为多少。</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 55, M = 35, INF = 1e9;

int n;
int w[N];
LL f[N][N][M];

void add(LL a[], LL b[])
{
    static LL c[M];
    memset(c, 0, sizeof c);
    for (int i = 0, t = 0; i &lt; M; i ++ )
    {
        t += a[i] + b[i];
        c[i] = t % 10;
        t /= 10;
    }
    memcpy(a, c, sizeof c);
}

void mul(LL a[], LL b)
{
    static LL c[M];
    memset(c, 0, sizeof c);
    LL t = 0;
    for (int i = 0; i &lt; M; i ++ )
    {
        t += a[i] * b;
        c[i] = t % 10;
        t /= 10;
    }
    memcpy(a, c, sizeof c);
}

int cmp(LL a[], LL b[])
{
    for (int i = M - 1; i &gt;= 0; i -- )
        if (a[i] &gt; b[i]) return 1;
        else if (a[i] &lt; b[i]) return -1;
    return 0;
}

void print(LL a[])
{
    int k = M - 1;
    while (k &amp;&amp; !a[k]) k -- ;
    while (k &gt;= 0) cout &lt;&lt; a[k -- ];
    cout &lt;&lt; endl;
}

int main()
{
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; w[i];

    LL temp[M];
    for (int len = 3; len &lt;= n; len ++ )
        for (int l = 1; l + len - 1 &lt;= n; l ++ )
        {
            int r = l + len - 1;
            f[l][r][M - 1] = 1;
            for (int k = l + 1; k &lt; r; k ++ )
            {
                memset(temp, 0, sizeof temp);
                temp[0] = w[l];
                mul(temp, w[k]);
                mul(temp, w[r]);
                add(temp, f[l][k]);
                add(temp, f[k][r]);
                if (cmp(f[l][r], temp) &gt; 0)
                    memcpy(f[l][r], temp, sizeof temp);
            }
        }
    print(f[1][n]);
    return 0;
}
</code></pre>
<h2 id="数位dp">数位DP</h2>
<p><strong>数字游戏</strong><br>
科协里最近很流行数字游戏。<br>
某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。<br>
现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

const int N = 15;

int f[N][N];    // f[i, j]表示一共有i位，且最高位填j的数的个数

void init()
{
    for (int i = 0; i &lt;= 9; i ++ ) f[1][i] = 1;

    for (int i = 2; i &lt; N; i ++ )
        for (int j = 0; j &lt;= 9; j ++ )
            for (int k = j; k &lt;= 9; k ++ )
                f[i][j] += f[i - 1][k];
}

int dp(int n)
{
    if (!n) return 1;

    vector&lt;int&gt; nums;
    while (n) nums.push_back(n % 10), n /= 10;

    int res = 0;
    int last = 0;
    for (int i = nums.size() - 1; i &gt;= 0; i -- )
    {
        int x = nums[i];
        for (int j = last; j &lt; x; j ++ )
            res += f[i + 1][j];

        if (x &lt; last) break;
        last = x;

        if (!i) res ++ ;
    }

    return res;
}

int main()
{
    init();
    int l, r;
    while (cin &gt;&gt; l &gt;&gt; r) cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl;
    return 0;
}
/*
1 9
1 19

9
18
*/
</code></pre>
<p><strong>数字游戏 II</strong><br>
由于科协里最近真的很流行数字游戏。<br>
某人又命名了一种取模数，这种数字必须满足各位数字之和 mod N 为 0。<br>
现在大家又要玩游戏了，指定一个整数闭区间 [a.b]，问这个区间内有多少个取模数。</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

const int N = 11, M = 110;

int P;
int f[N][10][M];

int mod(int x, int y)
{
    return (x % y + y) % y;
}

void init()
{
    memset(f, 0, sizeof f);

    for (int i = 0; i &lt;= 9; i ++ ) f[1][i][i % P] ++ ;

    for (int i = 2; i &lt; N; i ++ )
        for (int j = 0; j &lt;= 9; j ++ )
            for (int k = 0; k &lt; P; k ++ )
                for (int x = 0; x &lt;= 9; x ++ )
                    f[i][j][k] += f[i - 1][x][mod(k - j, P)];
}

int dp(int n)
{
    if (!n) return 1;

    vector&lt;int&gt; nums;
    while (n) nums.push_back(n % 10), n /= 10;

    int res = 0;
    int last = 0;
    for (int i = nums.size() - 1; i &gt;= 0; i -- )
    {
        int x = nums[i];
        for (int j = 0; j &lt; x; j ++ )
            res += f[i + 1][j][mod(-last, P)];

        last += x;

        if (!i &amp;&amp; last % P == 0) res ++ ;
    }

    return res;
}

int main()
{
    int l, r;
    while (cin &gt;&gt; l &gt;&gt; r &gt;&gt; P)
    {
        init();

        cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl;
    }

    return 0;
}
/*
1 19 9

2
*/
</code></pre>
<p><strong>不要62</strong><br>
不吉利的数字为所有含有 4 或 62 的号码。例如：62315,73418,88914 都属于不吉利号码。但是，61152 虽然含有 6 和 2，但不是 连号，所以不属于不吉利数字之列。<br>
你的任务是，对于每次给出的一个牌照号区间 [n,m]，推断出交管局今后又要实际上给多少辆新的士车上牌照了。</p>
<pre><code class="language-cpp">/*
每组数据包含一个整数对 n 和 m。
当输入一行为“0 0”时，表示输入结束。
*/
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

const int N = 35;

int f[N][10];

void init()
{
    for (int i = 0; i &lt;= 9; i ++ )
        if (i != 4)
            f[1][i] = 1;

    for (int i = 1; i &lt; N; i ++ )
        for (int j = 0; j &lt;= 9; j ++ )
        {
            if (j == 4) continue;
            for (int k = 0; k &lt;= 9; k ++ )
            {
                if (k == 4 || j == 6 &amp;&amp; k == 2) continue;
                f[i][j] += f[i - 1][k];
            }
        }
}

int dp(int n)
{
    if (!n) return 1;

    vector&lt;int&gt; nums;
    while (n) nums.push_back(n % 10), n /= 10;

    int res = 0;
    int last = 0;
    for (int i = nums.size() - 1; i &gt;= 0; i -- )
    {
        int x = nums[i];
        for (int j = 0; j &lt; x; j ++ )
        {
            if (j == 4 || last == 6 &amp;&amp; j == 2) continue;
            res += f[i + 1][j];
        }

        if (x == 4 || last == 6 &amp;&amp; x == 2) break;
        last = x;

        if (!i) res ++ ;
    }

    return res;
}

int main()
{
    init();
    int l, r;
    while (cin &gt;&gt; l &gt;&gt; r, l || r)
    {
        cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl;
    }
    return 0;
}
/*
1 100
0 0

80
*/
</code></pre>
<h2 id="斜率优化dp">斜率优化DP</h2>
<p><strong>任务安排3</strong><br>
有 N 个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。<br>
机器会把这 N 个任务分成若干批，每一批包含连续的若干个任务。<br>
从时刻 0 开始，任务被分批加工，执行第 i 个任务所需的时间是 Ti。<br>
另外，在每批任务开始前，机器需要 S 的启动时间，故执行一批任务所需的时间是启动时间 S 加上每个任务所需时间之和。<br>
一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。<br>
也就是说，同一批任务将在同一时刻完成。<br>
每个任务的费用是它的完成时刻乘以一个费用系数 Ci。<br>
请为机器规划一个分组方案，使得总费用最小。</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 300010;

int n, s;
LL t[N], c[N];
LL f[N];
int q[N];

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;s);
    for (int i = 1; i &lt;= n; i ++ )
    {
        scanf(&quot;%lld%lld&quot;, &amp;t[i], &amp;c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    }

    int hh = 0, tt = 0;
    q[0] = 0;

    for (int i = 1; i &lt;= n; i ++ )
    {
        int l = hh, r = tt;
        while (l &lt; r)
        {
            int mid = l + r &gt;&gt; 1;
            if (f[q[mid + 1]] - f[q[mid]] &gt; (t[i] + s) * (c[q[mid + 1]] - c[q[mid]])) r = mid;
            else l = mid + 1;
        }

        int j = q[r];
        f[i] = f[j] -   (t[i] + s) * c[j] + t[i] * c[i] + s * c[n];
        while (hh &lt; tt &amp;&amp; (double)(f[q[tt]] - f[q[tt - 1]]) * (c[i] - c[q[tt - 1]]) &gt;= (double)(f[i] - f[q[tt - 1]]) * (c[q[tt]] - c[q[tt - 1]])) tt -- ;
        q[ ++ tt] = i;
    }

    printf(&quot;%lld\n&quot;, f[n]);

    return 0;
}
/*
5 1
1 3
3 2
4 3
2 3
1 4

153
*/
</code></pre>
<h1>5. 搜索</h1>
<h2 id="5-1-bfs求连通块-flood-fill">5.1 BFS求连通块(FLood Fill)</h2>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 1010, M = N * N;

int n, m;
char g[N][N];
PII q[M];
bool st[N][N];

void bfs(int sx, int sy)
{
    int hh = 0, tt = 0;
    q[0] = {sx, sy};
    st[sx][sy] = true;

    while (hh &lt;= tt)
    {
        PII t = q[hh ++ ];

        for (int i = t.x - 1; i &lt;= t.x + 1; i ++ )
            for (int j = t.y - 1; j &lt;= t.y + 1; j ++ )
            {
                if (i == t.x &amp;&amp; j == t.y) continue;
                if (i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= m) continue;
                if (g[i][j] == '.' || st[i][j]) continue;

                q[ ++ tt] = {i, j};
                st[i][j] = true;
            }
    }
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%s&quot;, g[i]);

    int cnt = 0;
    for (int i = 0; i &lt; n; i ++ )
        for (int j = 0; j &lt; m; j ++ )
            if (g[i][j] == 'W' &amp;&amp; !st[i][j])
            {
                bfs(i, j);
                cnt ++ ;
            }

    printf(&quot;%d\n&quot;, cnt);

    return 0;
}
</code></pre>
<h2 id="5-2-矩阵最短路模型">5.2 矩阵最短路模型</h2>
<p>经典迷宫问题，左上到右下找到一条最短路径(并输出)</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 1010, M = N * N;

int n;
int g[N][N];
PII q[M];
PII pre[N][N];

void bfs(int sx, int sy)
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    int hh = 0, tt = 0;
    q[0] = {sx, sy};

    memset(pre, -1, sizeof pre);
    pre[sx][sy] = {0, 0};
    while (hh &lt;= tt)
    {
        PII t = q[hh ++ ];

        for (int i = 0; i &lt; 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n) continue;
            if (g[a][b]) continue;
            if (pre[a][b].x != -1) continue;

            q[ ++ tt] = {a, b};
            pre[a][b] = t;
        }
    }
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 0; i &lt; n; i ++ )
        for (int j = 0; j &lt; n; j ++ )
            scanf(&quot;%d&quot;, &amp;g[i][j]);

    bfs(n - 1, n - 1);

    PII end(0, 0);

    while (true)
    {
        printf(&quot;%d %d\n&quot;, end.x, end.y);
        if (end.x == n - 1 &amp;&amp; end.y == n - 1) break;
        end = pre[end.x][end.y];
    }

    return 0;
}
</code></pre>
<p><strong>象棋马走日，象走田最短路径等</strong>只需要稍微修改一下dx，dy数组</p>
<h2 id="5-3-双向bfs">5.3 双向BFS</h2>
<p><strong>字符串变换</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;unordered_map&gt;

using namespace std;

const int N = 6;

int n;
string A, B;
string a[N], b[N];

int extend(queue&lt;string&gt;&amp; q, unordered_map&lt;string, int&gt;&amp;da, unordered_map&lt;string, int&gt;&amp; db, 
    string a[N], string b[N])
{
    int d = da[q.front()];
    while (q.size() &amp;&amp; da[q.front()] == d)
    {
        auto t = q.front();
        q.pop();

        for (int i = 0; i &lt; n; i ++ )
            for (int j = 0; j &lt; t.size(); j ++ )
                if (t.substr(j, a[i].size()) == a[i])
                {
                    string r = t.substr(0, j) + b[i] + t.substr(j + a[i].size());
                    if (db.count(r)) return da[t] + db[r] + 1;
                    if (da.count(r)) continue;
                    da[r] = da[t] + 1;
                    q.push(r);
                }
    }

    return 11;
}

int bfs()
{
    if (A == B) return 0;
    queue&lt;string&gt; qa, qb;
    unordered_map&lt;string, int&gt; da, db;

    qa.push(A), qb.push(B);
    da[A] = db[B] = 0;

    int step = 0;
    while (qa.size() &amp;&amp; qb.size())
    {
        int t;
        if (qa.size() &lt; qb.size()) t = extend(qa, da, db, a, b);
        else t = extend(qb, db, da, b, a);

        if (t &lt;= 10) return t;
        if ( ++ step == 10) return -1;
    }

    return -1;
}

int main()
{
    cin &gt;&gt; A &gt;&gt; B;
    while (cin &gt;&gt; a[n] &gt;&gt; b[n]) n ++ ;

    int t = bfs();
    if (t == -1) puts(&quot;NO ANSWER!&quot;);
    else cout &lt;&lt; t &lt;&lt; endl;

    return 0;
}
</code></pre>
<h2 id="5-4-双端队列广搜">5.4 双端队列广搜</h2>
<p>边权只有01的图适用</p>
<pre><code class="language-cpp">// 电路维修
/*
联通的边权为0，不连通的边权为0
*/
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;deque&gt;

#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 510, M = N * N;

int n, m;
char g[N][N];
int dist[N][N];
bool st[N][N];

int bfs()
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    dist[0][0] = 0;
    deque&lt;PII&gt; q;
    q.push_back({0, 0});

    char cs[] = &quot;\\/\\/&quot;;
    int dx[4] = {-1, -1, 1, 1}, dy[4] = {-1, 1, 1, -1};
    int ix[4] = {-1, -1, 0, 0}, iy[4] = {-1, 0, 0, -1};

    while (q.size())
    {
        PII t = q.front();
        q.pop_front();

        if (st[t.x][t.y]) continue;
        st[t.x][t.y] = true;

        for (int i = 0; i &lt; 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a &lt; 0 || a &gt; n || b &lt; 0 || b &gt; m) continue;

            int ca = t.x + ix[i], cb = t.y + iy[i];
            int d = dist[t.x][t.y] + (g[ca][cb] != cs[i]);

            if (d &lt; dist[a][b])
            {
                dist[a][b] = d;

                if (g[ca][cb] != cs[i]) q.push_back({a, b}); // 如果边权为1则放到队尾
                else q.push_front({a, b}); // 如果边权为0则放到对头
            }
        }
    }

    return dist[n][m];
}

int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T -- )
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%s&quot;, g[i]);

        int t = bfs();

        if (t == 0x3f3f3f3f) puts(&quot;NO SOLUTION&quot;);
        else printf(&quot;%d\n&quot;, t);
    }

    return 0;
}
</code></pre>
<h2 id="5-5-a">5.5 A*</h2>
<h3 id="第k短路">第K短路</h3>
<pre><code class="language-cpp">// 给定一张 N 个点（编号 1,2…N），M 条边的有向图，求从起点 S 到终点 T 的第 K 短路的长度，路径允许重复经过点或边。
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;

#define x first
#define y second

using namespace std;

typedef pair&lt;int, int&gt; PII;
typedef pair&lt;int, PII&gt; PIII;

const int N = 1010, M = 200010;

int n, m, S, T, K;
int h[N], rh[N], e[M], w[M], ne[M], idx;
int dist[N], cnt[N];
bool st[N];

void add(int h[], int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dijkstra()
{
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;
    heap.push({0, T});

    memset(dist, 0x3f, sizeof dist);
    dist[T] = 0;

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.y;
        if (st[ver]) continue;
        st[ver] = true;

        for (int i = rh[ver]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] &gt; dist[ver] + w[i])
            {
                dist[j] = dist[ver] + w[i];
                heap.push({dist[j], j});
            }
        }
    }
}

int astar()
{
    priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt;&gt; heap;
    heap.push({dist[S], {0, S}});

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.y.y, distance = t.y.x;
        cnt[ver] ++ ;
        if (cnt[T] == K) return distance;

        for (int i = h[ver]; ~i; i = ne[i])
        {
            int j = e[i];
            if (cnt[j] &lt; K)
                heap.push({distance + w[i] + dist[j], {distance + w[i], j}});
        }
    }

    return -1;
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    memset(h, -1, sizeof h);
    memset(rh, -1, sizeof rh);

    for (int i = 0; i &lt; m; i ++ )
    {
        int a, b, c;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
        add(h, a, b, c);
        add(rh, b, a, c);
    }
    scanf(&quot;%d%d%d&quot;, &amp;S, &amp;T, &amp;K);
    if (S == T) K ++ ;

    dijkstra();
    printf(&quot;%d\n&quot;, astar());

    return 0;
}
</code></pre>
<h2 id="5-6-双向dfs">5.6 双向DFS</h2>
<p>达达帮翰翰给女生送礼物，翰翰一共准备了 N 个礼物，其中第 i 个礼物的重量是 G[i]。<br>
达达的力气很大，他一次可以搬动重量之和不超过 W 的任意多个物品。<br>
达达希望一次搬掉尽量重的一些物品，请你告诉达达在他的力气范围内一次性能搬动的最大重量是多少。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

typedef long long LL;

const int N = 1 &lt;&lt; 24;

int n, m, k;
int g[50], weights[N];
int cnt = 0;
int ans;

void dfs(int u, int s)
{
    if (u == k)
    {
        weights[cnt ++ ] = s;
        return;
    }

    if ((LL)s + g[u] &lt;= m) dfs(u + 1, s + g[u]);
    dfs(u + 1, s);
}

void dfs2(int u, int s)
{
    if (u == n)
    {
        int l = 0, r = cnt - 1;
        while (l &lt; r)
        {
            int mid = l + r + 1 &gt;&gt; 1;
            if (weights[mid] + (LL)s &lt;= m) l = mid;
            else r = mid - 1;
        }
        if (weights[l] + (LL)s &lt;= m) ans = max(ans, weights[l] + s);

        return;
    }

    if ((LL)s + g[u] &lt;= m) dfs2(u + 1, s + g[u]);
    dfs2(u + 1, s);
}

int main()
{
    cin &gt;&gt; m &gt;&gt; n;
    for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; g[i];

    sort(g, g + n);
    reverse(g, g + n);

    k = n / 2;  // 防止 n = 1时，出现死循环
    dfs(0, 0);

    sort(weights, weights + cnt);
    int t = 1;
    for (int i = 1; i &lt; cnt; i ++ )
        if (weights[i] != weights[i - 1])
            weights[t ++ ] = weights[i];
    cnt = t;

    dfs2(k, 0);

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
/*
20 5
7
5
4
18
1

19
*/
</code></pre>
<h2 id="5-7-ida">5.7 IDA*</h2>
<h3 id="排书">排书</h3>
<p>给定 n 本书，编号为 1∼n。<br>
在初始状态下，书是任意排列的。<br>
在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。<br>
我们的目标状态是把书按照 1∼n 的顺序依次排列。<br>
求最少需要多少次操作。</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 15;

int n;
int q[N];
int w[5][N];

int f()
{
    int cnt = 0;
    for (int i = 0; i + 1 &lt; n; i ++ )
        if (q[i + 1] != q[i] + 1)
            cnt ++ ;
    return (cnt + 2) / 3;
}

bool check()
{
    for (int i = 0; i + 1 &lt; n; i ++ )
        if (q[i + 1] != q[i] + 1)
            return false;
    return true;
}

bool dfs(int depth, int max_depth)
{
    if (depth + f() &gt; max_depth) return false;
    if (check()) return true;

    for (int len = 1; len &lt;= n; len ++ )
        for (int l = 0; l + len - 1 &lt; n; l ++ )
        {
            int r = l + len - 1;
            for (int k = r + 1; k &lt; n; k ++ )
            {
                memcpy(w[depth], q, sizeof q);
                int x, y;
                for (x = r + 1, y = l; x &lt;= k; x ++, y ++ ) q[y] = w[depth][x];
                for (x = l; x &lt;= r; x ++, y ++ ) q[y] = w[depth][x];
                if (dfs(depth + 1, max_depth)) return true;
                memcpy(q, w[depth], sizeof q);
            }
        }

    return false;
}

int main()
{
    int T;
    cin &gt;&gt; T;
    while (T -- )
    {
        cin &gt;&gt; n;
        for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; q[i];

        int depth = 0;
        while (depth &lt; 5 &amp;&amp; !dfs(0, depth)) depth ++ ;
        if (depth &gt;= 5) puts(&quot;5 or more&quot;);
        else cout &lt;&lt; depth &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h1>6. 图论</h1>
<h2 id="6-1-存边">6.1 存边</h2>
<ul>
<li>
<p>邻接矩阵</p>
</li>
<li>
<p>邻接表</p>
</li>
</ul>
<pre><code class="language-cpp">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;
// 添加一条边a-&gt;b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
// 初始化
idx = 0;
memset(h, -1, sizeof h);
</code></pre>
<h2 id="6-2-树与图的遍历">6.2 树与图的遍历</h2>
<p>时间复杂度 O(n+m)，n 表示点数，m 表示边数</p>
<ul>
<li><strong>深度优先遍历</strong></li>
</ul>
<pre><code class="language-cpp">int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
</code></pre>
<ul>
<li><strong>宽度优先遍历</strong></li>
</ul>
<pre><code class="language-cpp">queue&lt;int&gt; q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
</code></pre>
<h2 id="6-3-拓扑排序">6.3 拓扑排序</h2>
<p>时间复杂度 O(n+m)，n 表示点数，m 表示边数</p>
<pre><code class="language-cpp">bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i &lt;= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
</code></pre>
<h2 id="6-4-图论最短路模型-dj-spfa">6.4 图论最短路模型(DJ, SPFA…)</h2>
<h3 id="堆优化的dijkstra">堆优化的Dijkstra</h3>
<p><strong>时间复杂度 O(mlogn), n 表示点数，m 表示边数</strong></p>
<pre><code class="language-cpp">typedef pair&lt;int, int&gt; PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] &gt; distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
</code></pre>
<h3 id="bellman-ford算法">Bellman-Ford算法</h3>
<p><strong>时间复杂度 O(nm), n 表示点数，m 表示边数</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1e4 + 10;

struct Edge
{
    int a, b, w;
}edge[N];

int n, m, k;
int dist[N], backup[N];

void bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for(int i = 1;i &lt;= k;i ++)
    {
        memcpy(backup, dist, sizeof dist);
        for(int j = 0;j &lt;= m;j ++)
        {
            int a = edge[j].a,b = edge[j].b,w = edge[j].w;
            dist[b] = min(dist[b], backup[a] + w);
        }
    }
    if(dist[n] &gt; 0x3f3f3f3f / 2)    printf(&quot;impossible\n&quot;);
    else    printf(&quot;%d\n&quot;, dist[n]);
}

int main()
{
    scanf(&quot;%d%d%d&quot;,&amp;n, &amp;m, &amp;k);
    for(int i = 1;i &lt;= m;i ++)
    {
        Edge &amp;x = edge[i];
        scanf(&quot;%d%d%d&quot;,&amp;x.a, &amp;x.b, &amp;x.w);
    }
    bellman_ford();
    return 0;
}
</code></pre>
<h3 id="spfa算法">SPFA算法</h3>
<p><strong>时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数, m 表示边数</strong></p>
<pre><code class="language-cpp">int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue&lt;int&gt; q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] &gt; dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
</code></pre>
<h3 id="spfa判断图中是否存在负环">spfa判断图中是否存在负环</h3>
<p><strong>时间复杂度是 O(nm), n 表示点数，m 表示边数</strong></p>
<pre><code class="language-cpp">int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     // 存储每个点是否在队列中

// 如果存在负环，则返回true，否则返回false。
bool spfa()
{
    // 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。

    queue&lt;int&gt; q;
    for (int i = 1; i &lt;= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] &gt; dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}
</code></pre>
<h3 id="floyd算法">floyd算法</h3>
<p><strong>时间复杂度是 O(n3), n 表示点数</strong></p>
<pre><code class="language-cpp">初始化：
    for (int i = 1; i &lt;= n; i ++ )
        for (int j = 1; j &lt;= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k &lt;= n; k ++ )
        for (int i = 1; i &lt;= n; i ++ )
            for (int j = 1; j &lt;= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
</code></pre>
<h2 id="6-5-最小生成树">6.5 最小生成树</h2>
<h3 id="朴素版prim算法">朴素版prim算法</h3>
<p><strong>时间复杂度是 O(n^2+m), n 表示点数，m 表示边数</strong></p>
<pre><code class="language-cpp">int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中

// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i &lt; n; i ++ )
    {
        int t = -1;
        for (int j = 1; j &lt;= n; j ++ )
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))
                t = j;

        if (i &amp;&amp; dist[t] == INF) return INF;

        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}
</code></pre>
<h3 id="kruskal算法">Kruskal算法</h3>
<p><strong>时间复杂度是 O(mlogm), n 表示点数，m 表示边数</strong></p>
<pre><code class="language-cpp">int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组

struct Edge     // 存储边
{
    int a, b, w;

    bool operator&lt; (const Edge &amp;W)const
    {
        return w &lt; W.w;
    }
}edges[M];

int find(int x)     // 并查集核心操作
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i &lt; m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt &lt; n - 1) return INF;
    return res;
}
</code></pre>
<h2 id="6-6-染色法判别二分图">6.6 染色法判别二分图</h2>
<p><strong>时间复杂度是 O(n+m), n 表示点数，m 表示边数</strong></p>
<pre><code class="language-cpp">int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i &lt;= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
</code></pre>
<h2 id="6-7-二分图的最大匹配-匈牙利算法">6.7 二分图的最大匹配（匈牙利算法）</h2>
<p><strong>时间复杂度是 O(nm), n 表示点数，m 表示边数</strong></p>
<pre><code class="language-cpp">int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i &lt;= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
</code></pre>
<h2 id="6-8-树的直径">6.8 树的直径</h2>
<p>树上最长的路径</p>
<ul>
<li><strong>树形DP求树的直径</strong></li>
</ul>
<pre><code class="language-cpp">void dp(int x) {
    st[x] = 1;
    for(int i = h[x]; i != -1; i = ne[i]) {
        int j = e[i];
        if(st[j]) continue;
        dp(j);
        ans = max(ans, d[x] + d[j] + w[i]);
        d[x] = max(d[x], d[j] + w[i]);
    }
}
</code></pre>
<ul>
<li><strong>两次BFS求出树的直径（边权非负）</strong><br>
（1）从任意一个节点出发，跑一遍BFS，找到最远的p<br>
（2）再从p出发，跑一遍BFS，找到距离p最远的q<br>
p, q即为两个端点。</li>
</ul>
<h2 id="6-9-欧拉回路与欧拉路径">6.9  欧拉回路与欧拉路径</h2>
<p>存在欧拉回路与欧拉路径的充要条件：</p>
<ul>
<li>
<p>无向图</p>
<ul>
<li>存在<strong>欧拉路径</strong>的充要条件 : 度数为奇数的点只能有0或2个</li>
<li>存在<strong>欧拉回路</strong>的充要条件 : 度数为奇数的点只能有0个</li>
</ul>
</li>
<li>
<p>有向图</p>
<ul>
<li>
<p>存在<strong>欧拉路径</strong>的充要条件 :</p>
<ul>
<li>
<p>要么所有点的出度均==入度；</p>
</li>
<li>
<p>要么除了两个点之外，其余所有点的出度==入度 剩余的两个点:一个满足<strong>出度-入度==1</strong>(起点) 一个满足<strong>入度-出度</strong>==1(终点)</p>
</li>
</ul>
</li>
<li>
<p>存在<strong>欧拉回路</strong>的充要条件 : 所有点的出度均等于入度</p>
</li>
</ul>
</li>
</ul>
<h2 id="6-10-最近公共祖先-lca">6.10 最近公共祖先（LCA）</h2>
<h3 id="祖孙询问"><strong>祖孙询问</strong></h3>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 40010, M = N * 2;

int n, m;
int h[N], e[M], ne[M], idx;
int depth[N], fa[N][16];
int q[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void bfs(int root)
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[root] = 1;
    int hh = 0, tt = 0;
    q[0] = root;
    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] &gt; depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k &lt;= 15; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] &lt; depth[b]) swap(a, b);
    for (int k = 15; k &gt;= 0; k -- )
        if (depth[fa[a][k]] &gt;= depth[b])
            a = fa[a][k];
    if (a == b) return a;
    for (int k = 15; k &gt;= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    int root = 0;
    memset(h, -1, sizeof h);

    for (int i = 0; i &lt; n; i ++ )
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        if (b == -1) root = a;
        else add(a, b), add(b, a);
    }

    bfs(root);

    scanf(&quot;%d&quot;, &amp;m);
    while (m -- )
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        int p = lca(a, b);
        if (p == a) puts(&quot;1&quot;);
        else if (p == b) puts(&quot;2&quot;);
        else puts(&quot;0&quot;);
    }

    return 0;
}
</code></pre>
<h3 id="次小生成树">次小生成树</h3>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 100010, M = 300010, INF = 0x3f3f3f3f;

int n, m;
struct Edge
{
    int a, b, w;
    bool used;
    bool operator&lt; (const Edge &amp;t) const
    {
        return w &lt; t.w;
    }
}edge[M];
int p[N];
int h[N], e[M], w[M], ne[M], idx;
int depth[N], fa[N][17], d1[N][17], d2[N][17];
int q[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

LL kruskal()
{
    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;
    sort(edge, edge + m);
    LL res = 0;
    for (int i = 0; i &lt; m; i ++ )
    {
        int a = find(edge[i].a), b = find(edge[i].b), w = edge[i].w;
        if (a != b)
        {
            p[a] = b;
            res += w;
            edge[i].used = true;
        }
    }

    return res;
}

void build()
{
    memset(h, -1, sizeof h);
    for (int i = 0; i &lt; m; i ++ )
        if (edge[i].used)
        {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w;
            add(a, b, w), add(b, a, w);
        }
}

void bfs()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    q[0] = 1;
    int hh = 0, tt = 0;
    while (hh &lt;= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] &gt; depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                d1[j][0] = w[i], d2[j][0] = -INF;
                for (int k = 1; k &lt;= 16; k ++ )
                {
                    int anc = fa[j][k - 1];
                    fa[j][k] = fa[anc][k - 1];
                    int distance[4] = {d1[j][k - 1], d2[j][k - 1], d1[anc][k - 1], d2[anc][k - 1]};
                    d1[j][k] = d2[j][k] = -INF;
                    for (int u = 0; u &lt; 4; u ++ )
                    {
                        int d = distance[u];
                        if (d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d;
                        else if (d != d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d;
                    }
                }
            }
        }
    }
}

int lca(int a, int b, int w)
{
    static int distance[N * 2];
    int cnt = 0;
    if (depth[a] &lt; depth[b]) swap(a, b);
    for (int k = 16; k &gt;= 0; k -- )
        if (depth[fa[a][k]] &gt;= depth[b])
        {
            distance[cnt ++ ] = d1[a][k];
            distance[cnt ++ ] = d2[a][k];
            a = fa[a][k];
        }
    if (a != b)
    {
        for (int k = 16; k &gt;= 0; k -- )
            if (fa[a][k] != fa[b][k])
            {
                distance[cnt ++ ] = d1[a][k];
                distance[cnt ++ ] = d2[a][k];
                distance[cnt ++ ] = d1[b][k];
                distance[cnt ++ ] = d2[b][k];
                a = fa[a][k], b = fa[b][k];
            }
        distance[cnt ++ ] = d1[a][0];
        distance[cnt ++ ] = d1[b][0];
    }

    int dist1 = -INF, dist2 = -INF;
    for (int i = 0; i &lt; cnt; i ++ )
    {
        int d = distance[i];
        if (d &gt; dist1) dist2 = dist1, dist1 = d;
        else if (d != dist1 &amp;&amp; d &gt; dist2) dist2 = d;
    }

    if (w &gt; dist1) return w - dist1;
    if (w &gt; dist2) return w - dist2;
    return INF;
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 0; i &lt; m; i ++ )
    {
        int a, b, c;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
        edge[i] = {a, b, c};
    }

    LL sum = kruskal();
    build();
    bfs();

    LL res = 1e18;
    for (int i = 0; i &lt; m; i ++ )
        if (!edge[i].used)
        {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w;
            res = min(res, sum + lca(a, b, w));
        }
    printf(&quot;%lld\n&quot;, res);

    return 0;
}
</code></pre>
<h2 id="6-11-树上两点距离">6.11 树上两点距离</h2>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 10010, M = N * 2;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int dist[N];
int p[N];
int res[M];
int st[N];
vector&lt;PII&gt; query[N];   // first存查询的另外一个点，second存查询编号

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u, int fa)
{
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j == fa) continue;
        dist[j] = dist[u] + w[i];
        dfs(j, u);
    }
}

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void tarjan(int u)
{
    st[u] = 1;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            tarjan(j);
            p[j] = u;
        }
    }

    for (auto item : query[u])
    {
        int y = item.first, id = item.second;
        if (st[y] == 2)
        {
            int anc = find(y);
            res[id] = dist[u] + dist[y] - dist[anc] * 2;
        }
    }

    st[u] = 2;
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    memset(h, -1, sizeof h);
    for (int i = 0; i &lt; n - 1; i ++ )
    {
        int a, b, c;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
        add(a, b, c), add(b, a, c);
    }

    for (int i = 0; i &lt; m; i ++ )
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        if (a != b)
        {
            query[a].push_back({b, i});
            query[b].push_back({a, i});
        }
    }

    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;

    dfs(1, -1);
    tarjan(1);

    for (int i = 0; i &lt; m; i ++ ) printf(&quot;%d\n&quot;, res[i]);

    return 0;
}
</code></pre>
<h2 id="6-12-有向图的强联通分量">6.12 有向图的强联通分量</h2>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010, M = 50010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, Size[N];
int dout[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            Size[scc_cnt] ++ ;
        } while (y != u);
    }
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        add(a, b);
    }

    for (int i = 1; i &lt;= n; i ++ )
        if (!dfn[i])
            tarjan(i);

    for (int i = 1; i &lt;= n; i ++ )
        for (int j = h[i]; ~j; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];
            if (a != b) dout[a] ++ ;
        }

    int zeros = 0, sum = 0;
    for (int i = 1; i &lt;= scc_cnt; i ++ )
        if (!dout[i])
        {
            zeros ++ ;
            sum += Size[i];
            if (zeros &gt; 1)
            {
                sum = 0;
                break;
            }
        }

    printf(&quot;%d\n&quot;, sum);

    return 0;
}
</code></pre>
<h2 id="6-13-无向图的双联通分量">6.13 无向图的双联通分量</h2>
<p><strong>冗余路径</strong></p>
<p>为了从 FF 个草场中的一个走到另一个，奶牛们有时不得不路过一些她们讨厌的可怕的树。</p>
<p>奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择。</p>
<p>每对草场之间已经有至少一条路径。</p>
<p>给出所有 RR 条双向路的描述，每条路连接了两个不同的草场，请计算最少的新建道路的数量，路径由若干道路首尾相连而成。</p>
<p>两条路径相互分离，是指两条路径没有一条重合的道路。</p>
<p>但是，两条分离的路径上可以有一些相同的草场。</p>
<p>对于同一对草场之间，可能已经有两条不同的道路，你也可以在它们之间再建一条道路，作为另一条不同的道路。</p>
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 5010, M = 20010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
int id[N], dcc_cnt;
bool is_bridge[M];
int d[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u, int from)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j, i);
            low[u] = min(low[u], low[j]);
            if (dfn[u] &lt; low[j])
                is_bridge[i] = is_bridge[i ^ 1] = true;
        }
        else if (i != (from ^ 1))
            low[u] = min(low[u], dfn[j]);
    }

    if (dfn[u] == low[u])
    {
        ++ dcc_cnt;
        int y;
        do {
            y = stk[top -- ];
            id[y] = dcc_cnt;
        } while (y != u);
    }
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b), add(b, a);
    }

    tarjan(1, -1);

    for (int i = 0; i &lt; idx; i ++ )
        if (is_bridge[i])
            d[id[e[i]]] ++ ;

    int cnt = 0;
    for (int i = 1; i &lt;= dcc_cnt; i ++ )
        if (d[i] == 1)
            cnt ++ ;

    printf(&quot;%d\n&quot;, (cnt + 1) / 2);

    return 0;
}
</code></pre>

        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="https://cdn.jsdelivr.net/gh/memsetray/cdn@latest/img/custom/donate/AliPayQR.jpg"></li>
                <li class="wechat-code"><img src="https://cdn.jsdelivr.net/gh/memsetray/cdn@latest/img/custom/donate/WeChanQR.jpg"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2022/11/03/每日一题2022-11-3/" rel="prev">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://s3.bmp.ovh/imgs/2022/10/18/0cbab9d4bf2b4b77.jpg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://s3.bmp.ovh/imgs/2022/10/18/0cbab9d4bf2b4b77.jpg">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                每日一题2022-11-3</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2022/10/18/线段树/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://s3.bmp.ovh/imgs/2022/10/18/4b26fcd037c3c646.jpg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://s3.bmp.ovh/imgs/2022/10/18/4b26fcd037c3c646.jpg">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                线段树</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      


    <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
    <div id="waline"></div>
    <style>
    #waline textarea {
        box-sizing: border-box;
        background: url("https://gitee.com/cungudafa/source/raw/master/img/gif/Sitich/Sitich2.gif") 100% 100% no-repeat;
    }
    </style>
    <script>
        Waline({
              el: '#waline',
              serverURL: 'waline-ten-pied.vercel.app',
              pageSize: '10',
              lang: 'zh-CN',
              requiredFields: ['nick','mail'], //设置必填项
              placeholder: '快来发送评论吐槽吧~',
              visitor: 'true',
	      locale: {
    		level0: 'Level 1',
    		level1: 'Level 2',
    		level2: 'Level 3',
    		level3: 'Level 4',
    		level4: 'Level 5',
    		level5: 'Level 6',
 		 },
              emoji: [
                  'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba',
                  'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili',
                  'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/weibo',
              ],
              avatar: 'mp',
              dark: 'false',

            });
    </script>
<style>
/*设置 Waline 的主题色*/
:root{
--waline-badge-color: #FF0000;
}
</style>



      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="sakana.icu" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/memsetray/cdn/img/custom/avatar.jpg" itemprop="image" alt="Ray" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="sakana.icu" itemprop="url" rel="author">Ray</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>一个蒟蒻ACMer</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Ray<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2022</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
  var now = new Date(); 
  function createtime() { 
    var grt= new Date("09/04/2022 16:44:00");//此处修改你的建站时间或者网站上线时间 
    now.setTime(now.getTime()+250); 
    days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
    hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
    if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
    mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
    snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
    document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
  } 
  setInterval("createtime()",250);
</script>
        <span style="color: #b9b9b9;">Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/memsetray/cdn@latest/img/custom/avatar.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">某不科学のBlog by Ray</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="http://github.com/MemsetRay" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
        <a href="https://wpa.qq.com/msgrd?v=3&uin=392745055&site=qq&menu=yes" class="fa fa-qq" target="_blank" style="color: #25c6fe; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/题解/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  题解
                </a>
              </li>
            
              <li>
                <a href="/categories/随想/">
                  <i class="fa fa-commenting-o" aria-hidden="true"></i>
                  随想
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            清单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/bangumi/">
                  <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                  番组
                </a>
              </li>
            
              <li>
                <a href="/music/">
                  <i class="fa fa-headphones" aria-hidden="true"></i>
                  歌单
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/links/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
            友人帐
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我？
                </a>
              </li>
            
              <li>
                <a href="/lab/">
                  <i class="fa fa-cogs" aria-hidden="true"></i>
                  Lab
                </a>
              </li>
            
          </ul>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="172424842"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
</body>
</html>