{"meta":{"title":"Ray's Blog","subtitle":null,"description":"å°‘å¥³ç¥ˆç¥·ä¸­...","author":"Ray","url":"https://memsetray.github.io"},"pages":[{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"comment/index.html","permalink":"https://memsetray.github.io/comment/index.html","excerpt":"","text":"å¿µä¸¤å¥è¯— å™åˆ«æ¢¦ã€æ‰¬å·ä¸€è§‰ã€‚ ã€å®‹ä»£ã€‘å´æ–‡è‹±ã€Šå¤œæ¸¸å®«Â·äººå»è¥¿æ¥¼é›æ³ã€‹","keywords":"ç•™è¨€æ¿"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"client/index.html","permalink":"https://memsetray.github.io/client/index.html","excerpt":"","text":"ç›´æ¥ä¸‹è½½ or æ‰«ç ä¸‹è½½ï¼š","keywords":"Androidå®¢æˆ·ç«¯"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"donate/index.html","permalink":"https://memsetray.github.io/donate/index.html","excerpt":"","text":"","keywords":"è°¢è°¢é¥²ä¸»äº†å–µ~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2022-09-07T06:28:38.365Z","comments":false,"path":"lab/index.html","permalink":"https://memsetray.github.io/lab/index.html","excerpt":"","text":"Blogæ›´æ–°æ—¥å¿— 2022å¹´9æœˆ4æ—¥ï¼šåšå®¢æ­å»ºå®Œæˆï¼Œæ­£å¼å¼€å§‹ä½¿ç”¨ 2022å¹´9æœˆ5æ—¥ï¼šä¿®å¤äº†ä¸ªäººä»‹ç»ï¼Œæ·»åŠ äº†Walineè¯„è®ºç³»ç»Ÿï¼Œä¿®å¤äº†å„ç§å›¾ç‰‡è£‚å¼€é—®é¢˜ 2022å¹´9æœˆ6æ—¥ï¼šä¿®å¤äº†è¯„è®ºç³»ç»Ÿå¯¼è‡´ç½‘é¡µæŒ‚æ‰çš„é—®é¢˜ï¼Œå®Œå–„äº†è¯„è®ºç³»ç»Ÿï¼Œä¿®å¤äº†æ‰“èµäºŒç»´ç ï¼Œä¿®å¤äº†ç¤¾äº¤é“¾æ¥ 2022å¹´9æœˆ7æ—¥ï¼šæ·»åŠ äº†Live2dçœ‹æ¿å¨˜ ToDo å®Œå–„æ¸…å•ï¼šç•ªç»„ä¸å›¾é›† æ·»åŠ è¯´è¯´ æ·»åŠ è§†é¢‘ â€¦","keywords":"Labå®éªŒå®¤"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2022-09-05T05:22:49.110Z","comments":false,"path":"about/index.html","permalink":"https://memsetray.github.io/about/index.html","excerpt":"","text":"[Rayçš„ä¸ªäººä»‹ç»] ä¸&nbsp; Ray&nbsp; ï¼ˆ èœ ï¼‰ å¯¹è¯ä¸­... bot_ui_ini()","keywords":"å…³äº"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"tags/index.html","permalink":"https://memsetray.github.io/tags/index.html","excerpt":"","text":""},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2022-09-07T11:12:50.613Z","comments":true,"path":"bangumi/index.html","permalink":"https://memsetray.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2022-09-04T13:36:18.224Z","comments":false,"path":"music/index.html","permalink":"https://memsetray.github.io/music/index.html","excerpt":"","text":"","keywords":"å–œæ¬¢çš„éŸ³ä¹"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2022-09-07T03:42:02.561Z","comments":true,"path":"links/index.html","permalink":"https://memsetray.github.io/links/index.html","excerpt":"","text":"","keywords":"å‹äººå¸"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"rss/index.html","permalink":"https://memsetray.github.io/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://memsetray.github.io/theme-sakura/index.html","excerpt":"","text":"Hexoä¸»é¢˜Sakuraä¿®æ”¹è‡ªWordPressä¸»é¢˜Sakuraï¼Œæ„Ÿè°¢åŸä½œè€…Mashiro","keywords":"Hexo ä¸»é¢˜ Sakura ğŸŒ¸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"video/index.html","permalink":"https://memsetray.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: 'æœèŠ±å¤•èª“â€”â€”äºç¦»åˆ«ä¹‹æœæŸèµ·çº¦å®šä¹‹èŠ±', status: 'å·²è¿½å®Œ', progress: 100, jp: 'ã•ã‚ˆãªã‚‰ã®æœã«ç´„æŸã®èŠ±ã‚’ã‹ã–ã‚ã†', time: 'æ”¾é€æ—¶é—´: 2018-02-24 SUN.', desc: ' ä½åœ¨è¿œç¦»å°˜åš£çš„åœŸåœ°ï¼Œä¸€è¾¹å°†æ¯å¤©çš„äº‹æƒ…ç¼–ç»‡æˆåä¸ºå¸Œæ¯”æ¬§çš„å¸ƒï¼Œä¸€è¾¹é™é™ç”Ÿæ´»çš„ä¼Šæ¬§å¤«äººæ°‘ã€‚åœ¨15å²å·¦å³å¤–è¡¨å°±åœæ­¢æˆé•¿ï¼Œæ‹¥æœ‰æ•°ç™¾å¹´å¯¿å‘½çš„ä»–ä»¬ï¼Œè¢«ç§°ä¸ºâ€œç¦»åˆ«çš„ä¸€æ—â€ï¼Œå¹¶è¢«è§†ä¸ºæ´»ç€çš„ä¼ è¯´ã€‚æ²¡æœ‰åŒäº²çš„ä¼Šæ¬§å¤«å°‘å¥³ç›å¥‡äºšï¼Œè¿‡ç€è¢«ä¼™ä¼´åŒ…å›´çš„å¹³ç¨³æ—¥å­ï¼Œå´æ€»æ„Ÿè§‰â€œå­¤èº«ä¸€äººâ€ã€‚ä»–ä»¬çš„è¿™ç§æ—¥å¸¸ï¼Œä¸€ç¬é—´å°±å´©æºƒæ¶ˆå¤±ã€‚è¿½æ±‚ä¼Šæ¬§å¤«çš„é•¿å¯¿ä¹‹è¡€ï¼Œæ¢…è¨è’‚å†›ä¹˜åç€åä¸ºé›·çº³ç‰¹çš„å¤ä»£å…½å‘åŠ¨äº†è¿›æ”»ã€‚åœ¨ç»æœ›ä¸æ··ä¹±ä¹‹ä¸­ï¼Œä¼Šæ¬§å¤«çš„ç¬¬ä¸€ç¾å¥³è•¾è‰äºšè¢«æ¢…è¨è’‚å¸¦èµ°ï¼Œè€Œç›å¥‡äºšæš—æ‹çš„å°‘å¹´å…‹é‡Œå§†ä¹Ÿå¤±è¸ªäº†ã€‚ç›å¥‡äºšè™½ç„¶æ€»ç®—é€ƒè„±äº†ï¼Œå´å¤±å»äº†ä¼™ä¼´å’Œå½’å»ä¹‹åœ°â€¦â€¦ã€‚' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: 'æœèŠ±å¤•èª“â€”â€”äºç¦»åˆ«ä¹‹æœæŸèµ·çº¦å®šä¹‹èŠ±', status: 'å·²è¿½å®Œ', progress: 100, jp: 'ã•ã‚ˆãªã‚‰ã®æœã«ç´„æŸã®èŠ±ã‚’ã‹ã–ã‚ã†', time: '2018-02-24 SUN.', desc: ' ä½åœ¨è¿œç¦»å°˜åš£çš„åœŸåœ°ï¼Œä¸€è¾¹å°†æ¯å¤©çš„äº‹æƒ…ç¼–ç»‡æˆåä¸ºå¸Œæ¯”æ¬§çš„å¸ƒï¼Œä¸€è¾¹é™é™ç”Ÿæ´»çš„ä¼Šæ¬§å¤«äººæ°‘ã€‚åœ¨15å²å·¦å³å¤–è¡¨å°±åœæ­¢æˆé•¿ï¼Œæ‹¥æœ‰æ•°ç™¾å¹´å¯¿å‘½çš„ä»–ä»¬ï¼Œè¢«ç§°ä¸ºâ€œç¦»åˆ«çš„ä¸€æ—â€ï¼Œå¹¶è¢«è§†ä¸ºæ´»ç€çš„ä¼ è¯´ã€‚æ²¡æœ‰åŒäº²çš„ä¼Šæ¬§å¤«å°‘å¥³ç›å¥‡äºšï¼Œè¿‡ç€è¢«ä¼™ä¼´åŒ…å›´çš„å¹³ç¨³æ—¥å­ï¼Œå´æ€»æ„Ÿè§‰â€œå­¤èº«ä¸€äººâ€ã€‚ä»–ä»¬çš„è¿™ç§æ—¥å¸¸ï¼Œä¸€ç¬é—´å°±å´©æºƒæ¶ˆå¤±ã€‚è¿½æ±‚ä¼Šæ¬§å¤«çš„é•¿å¯¿ä¹‹è¡€ï¼Œæ¢…è¨è’‚å†›ä¹˜åç€åä¸ºé›·çº³ç‰¹çš„å¤ä»£å…½å‘åŠ¨äº†è¿›æ”»ã€‚åœ¨ç»æœ›ä¸æ··ä¹±ä¹‹ä¸­ï¼Œä¼Šæ¬§å¤«çš„ç¬¬ä¸€ç¾å¥³è•¾è‰äºšè¢«æ¢…è¨è’‚å¸¦èµ°ï¼Œè€Œç›å¥‡äºšæš—æ‹çš„å°‘å¹´å…‹é‡Œå§†ä¹Ÿå¤±è¸ªäº†ã€‚ç›å¥‡äºšè™½ç„¶æ€»ç®—é€ƒè„±äº†ï¼Œå´å¤±å»äº†ä¼™ä¼´å’Œå½’å»ä¹‹åœ°â€¦â€¦ã€‚' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} ç•ªç»„è®¡åˆ’ è¿™é‡Œå°†æ˜¯æ°¸è¿œçš„å›å¿† window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} æ”¾é€æ—¶é—´: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"Bç«™"}],"posts":[{"title":"ç½‘ç»œæµåŸºç¡€","slug":"ç½‘ç»œæµåŸºç¡€","date":"2022-12-26T14:07:36.000Z","updated":"2022-12-26T14:09:10.297Z","comments":true,"path":"2022/12/26/ç½‘ç»œæµåŸºç¡€/","link":"","permalink":"https://memsetray.github.io/2022/12/26/ç½‘ç»œæµåŸºç¡€/","excerpt":"","text":"ç½‘ç»œæµ 1. åŸºæœ¬æ¦‚å¿µ 1.1 æœ€å¤§æµæœ€å°å‰²å®šç†ï¼š â€‹ ï¼ˆ1ï¼‰æµfffæ˜¯æœ€å¤§æµ â€‹ ï¼ˆ2ï¼‰æµfffçš„æ®‹ç•™ç½‘ç»œä¸­ä¸å­˜åœ¨å¢å¹¿è·¯ â€‹ ï¼ˆ3ï¼‰å­˜åœ¨æŸä¸ªå‰²[S,T],âˆ£fâˆ£=c(S,T)[S,T],|f| = c(S,T)[S,T],âˆ£fâˆ£=c(S,T) â€‹ ä»¥ä¸Šæ¡ä»¶æ»¡è¶³ä»»ä½•ä¸€ä¸ªï¼Œå…¶ä½™æ¡ä»¶å‡æˆç«‹ â€‹ è¯æ˜ï¼šç”±ï¼ˆ1ï¼‰æ¨ç†ï¼ˆ2ï¼‰ï¼Œå‡è®¾æµfffçš„æ®‹ç•™ç½‘ç»œä¸­å­˜åœ¨å¢å¹¿è·¯fâ€²f&#x27;fâ€²ï¼Œåˆ™å¯ä»¥æ ¹æ®fâ€²f&#x27;fâ€²ä¸æµfffæ„é€ æ›´å¤§çš„æµï¼Œä¸fffæ˜¯æœ€å¤§æµçŸ›ç›¾ï¼Œæ•…ï¼ˆ1ï¼‰å¯ä»¥æ¨å‡ºï¼ˆ2ï¼‰ ç”±ï¼ˆ2ï¼‰æ¨ï¼ˆ3ï¼‰ï¼Œè®¾SSSï¼šåœ¨æ®‹ç•™ç½‘ç»œGfG_fGfâ€‹ä¸­ï¼Œä»ssså‡ºå‘æ²¿ç€å®¹é‡å¤§äº0çš„è¾¹èµ°ï¼Œæ‰€æœ‰èƒ½èµ°åˆ°çš„ç‚¹ã€‚ è®¾T=Vâˆ’ST = V - ST=Vâˆ’Sï¼Œå¾—åˆ°ä¸€ä¸ªåˆæ³•çš„å‰²ã€‚ å¯¹äºåŸç½‘ç»œæµä¸­ä»»æ„ç”±SSSåˆ°TTTçš„è¾¹(x,y)(x,y)(x,y)ï¼Œä¸€å®šæ»¡è¶³f(x,y)=c(x,y)f(x,y) = c(x,y)f(x,y)=c(x,y)ï¼Œå¦åˆ™å…¶æ®‹ç•™ç½‘ç»œçš„å€¼ä¸ä¸º0ï¼Œä¸SSSå’ŒTTTçš„å®šä¹‰çŸ›ç›¾ å¯¹äºåŸç½‘ç»œæµä¸­ä»»æ„ç”±TTTåˆ°SSSçš„è¾¹(a,b)(a, b)(a,b)ï¼Œä¸€å®šæ»¡è¶³f(a,b)=0f(a,b) = 0f(a,b)=0ï¼Œå¦åˆ™å…¶æ®‹ç•™ç½‘ç»œä¼šäº§ç”Ÿä¸€æ¡ç”±SSSåˆ°TTTçš„åå‘è¾¹ï¼Œå€¼ä¸ºåŸç½‘ç»œæµä¸­TTTåˆ°SSSçš„å®¹é‡ï¼Œä¸SSSå’ŒTTTçš„å®šä¹‰çŸ›ç›¾ã€‚ äºæ˜¯æœ‰âˆ£fâˆ£=f(S,T)=âˆ‘uâˆˆSâˆ‘vâˆˆTf(u,v)âˆ’0=âˆ‘uâˆˆSâˆ‘vâˆˆTc(u,v)=c(S,T)|f| = f(S,T) = \\sum_{u\\in S} \\sum_{v \\in T}f(u,v) - 0 = \\sum_{u\\in S} \\sum_{v \\in T}c(u,v) = c(S,T)âˆ£fâˆ£=f(S,T)=âˆ‘uâˆˆSâ€‹âˆ‘vâˆˆTâ€‹f(u,v)âˆ’0=âˆ‘uâˆˆSâ€‹âˆ‘vâˆˆTâ€‹c(u,v)=c(S,T) ç”±ï¼ˆ3ï¼‰æ¨ï¼ˆ1ï¼‰ï¼Œå› ä¸ºâˆ£fâˆ£â‰¤c(S,T)|f| \\leq c(S,T)âˆ£fâˆ£â‰¤c(S,T)ï¼Œè®¾æœ€å¤§æµä¸ºfâ€²f&#x27;fâ€²ï¼Œåˆ™âˆ£fâ€²âˆ£â‰¤c(S,T)|f&#x27;| \\leq c(S,T)âˆ£fâ€²âˆ£â‰¤c(S,T)ï¼Œä¹‹åè¯æ˜âˆ£fâˆ£=âˆ£fâ€²âˆ£|f| = |f&#x27;|âˆ£fâˆ£=âˆ£fâ€²âˆ£ï¼Œæ ¹æ®å®šä¹‰æ˜¾ç„¶âˆ£fâ€²âˆ£â‰¥âˆ£fâˆ£|f&#x27;| \\geq |f|âˆ£fâ€²âˆ£â‰¥âˆ£fâˆ£ï¼Œç”±äºå­˜åœ¨æŸä¸ªå‰²ä½¿å¾—âˆ£fâˆ£=c(S,T)|f|=c(S,T)âˆ£fâˆ£=c(S,T)ï¼Œè€Œâˆ£fâ€²âˆ£â‰¤c(S,T)|f&#x27;| \\leq c(S,T)âˆ£fâ€²âˆ£â‰¤c(S,T)ï¼Œå› æ­¤âˆ£fâˆ£â‰¥âˆ£fâ€²âˆ£|f| \\geq |f&#x27;|âˆ£fâˆ£â‰¥âˆ£fâ€²âˆ£ï¼Œç”±æ­¤å¯å¾—âˆ£fâˆ£=âˆ£fâ€²âˆ£|f| = |f&#x27;|âˆ£fâˆ£=âˆ£fâ€²âˆ£ï¼Œå³æµfffæ˜¯æœ€å¤§æµ è¯æ¯•ã€‚ 2. EKç®—æ³•æ±‚æœ€å¤§æµ ç»´æŠ¤ä¸€ä¸ªæ®‹ç•™ç½‘ç»œï¼Œæ¯æ¬¡å°è¯•ä»SSSæ‰¾åˆ°ä¸€æ¡åˆ°è¾¾TTTçš„å¢å¹¿è·¯å¾„ï¼Œå°†å…¶æµé‡ä»åŸç½‘ç»œæµä¸­ç§»é™¤ï¼ŒåŒæ—¶ç»´æŠ¤æ–°çš„æ®‹ç•™ç½‘ç»œï¼Œå°†è¿™æ¡è·¯å¾„ä¸Šçš„æœ€å°æ®‹ç•™é‡ï¼ˆæµé‡ï¼‰ç´¯åŠ åˆ°resresresä¸­ï¼Œç›´åˆ°æ— æ³•æ‰¾åˆ°å¢å¹¿è·¯å¾„ï¼Œæ­¤æ—¶resresreså³ä¸ºæœ€å¤§æµ æ—¶é—´å¤æ‚åº¦O(nm2)O(nm^2)O(nm2) æ¨¡æ¿ #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 1010, M = 2e5 + 10, INF = 1e8; int h[N], e[M], ne[M], f[M], idx; int d[N], pre[N]; int res; bool st[N]; int n, m, S, T; void add(int a, int b, int c) { e[idx] = b, ne[idx] = h[a], f[idx] = c, h[a] = idx ++; e[idx] = a, ne[idx] = h[b], f[idx] = 0, h[b] = idx ++; } bool bfs() { queue&lt;int&gt; q; memset(st, 0, sizeof st); q.push(S); d[S] = INF; st[S] = true; while(q.size()) { int t = q.front(); q.pop(); for(int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if(!st[j] &amp;&amp; f[i]) { st[j] = true; d[j] = min(d[t], f[i]); pre[j] = i; if(j == T) return true; q.push(j); } } } return false; } void EK() { while(bfs()) { res += d[T]; for(int i = T; i != S; i = e[pre[i] ^ 1]) { f[pre[i]] -= d[T]; f[pre[i] ^ 1] += d[T]; } } } int main() { memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T; while(m --) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); } EK(); cout &lt;&lt; res &lt;&lt; endl; return 0; } 3.Dinicç®—æ³•æ±‚æœ€å¤§æµ å¯¹EKEKEKç®—æ³•çš„ä¼˜åŒ–ï¼Œä¸»è¦é‡‡ç”¨åˆ†å±‚å›¾+å½“å‰å¼§ä¼˜åŒ–çš„æ–¹å¼ï¼Œåœ¨æ±‚å¢å¹¿è·¯å¾„æ—¶å¯ä»¥ä¸€æ¬¡æ±‚å‡ºå¤šæ¡å¢å¹¿è·¯ä»è€Œé™ä½æ—¶é—´å¤æ‚åº¦ï¼ŒDinicç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n2m)O(n^2m)O(n2m) å½“å‰å¼§ä¼˜åŒ–ï¼šåœ¨é€šè¿‡DFSDFSDFSéå†å½“å‰ç‚¹åˆ°ç»ˆç‚¹çš„æµé‡æ—¶ï¼Œå¦‚æœæŸæ¡è·¯å¾„å·²ç»è¢«éå†è¿‡ä¸”æµé‡å·²æ»¡ï¼Œåˆ™è·³è¿‡å¯¹è¿™æ¡è·¯å¾„çš„DFSDFSDFSï¼Œç›´æ¥ä»ç¬¬ä¸€ä¸ªæœªæ»¡çš„è·¯å¾„æœç´¢ï¼Œé¿å…äº†é‡å¤æœç´¢ æ¨¡æ¿ #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 10010, M = 2e5 + 10, INF = 1e9; int h[N], e[M], ne[M], f[M], idx; int d[N], cur[N]; int res, flow; int n, m, S, T; void add(int a, int b, int c) { e[idx] = b, ne[idx] = h[a], f[idx] = c, h[a] = idx ++; e[idx] = a, ne[idx] = h[b], f[idx] = 0, h[b] = idx ++; } bool bfs() { queue&lt;int&gt; q; memset(d, -1, sizeof d); q.push(S); d[S] = 0; cur[S] = h[S]; //å½“å‰å¼§ä»ç¬¬ä¸€ä¸ªç‚¹å¼€å§‹ while(q.size()) { int t = q.front(); q.pop(); for(int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if(d[j] == -1 &amp;&amp; f[i]) { d[j] = d[t] + 1; cur[j] = h[j]; //å½“å‰ç‚¹çš„å½“å‰å¼§æ˜¯å½“å‰ç‚¹çš„ç¬¬ä¸€æ¡è¾¹ if(j == T) return true; q.push(j); } } } return false; } int dfs(int u, int l) { if(u == T) return l; int flow = 0; for(int i = cur[u]; ~i &amp;&amp; flow &lt; l; i = ne[i]) { cur[u] = i; //å½“å‰å¼§ä¼˜åŒ– int j = e[i]; if(d[j] == d[u] + 1 &amp;&amp; f[i]) { int t = dfs(j, min(f[i], l - flow)); if(!t) d[j] = -1; //ä¸å­˜åœ¨å¢å¹¿è·¯ï¼Œå°†è¿™ä¸ªç‚¹åˆ æ‰ f[i] -= t, f[i ^ 1] += t, flow += t; } } return flow; } void dinic() { while(bfs()) { while(flow = dfs(S, INF)) res += flow; } } int main() { memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T; while(m --) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); } dinic(); cout &lt;&lt; res &lt;&lt; endl; return 0; }","categories":[],"tags":[],"keywords":[]},{"title":"å•ç‰‡æœºå¤ä¹ ç¬”è®°","slug":"å•ç‰‡æœºå¤ä¹ ç¬”è®°","date":"2022-11-21T15:10:36.000Z","updated":"2022-12-26T14:09:34.737Z","comments":true,"path":"2022/11/21/å•ç‰‡æœºå¤ä¹ ç¬”è®°/","link":"","permalink":"https://memsetray.github.io/2022/11/21/å•ç‰‡æœºå¤ä¹ ç¬”è®°/","excerpt":"","text":"å•ç‰‡æœºå¤ä¹  ç¬¬ä¸€èŠ‚ 16ä½ç¨‹åºè®¡æ•°å™¨(PC)ï¼šç”¨äºæŒ‡ç¤ºä¸‹ä¸€æ—¶åˆ»CPUå°†è¦æ‰§è¡Œçš„ç¨‹åºåœ¨ROMç©ºé—´ä¸­çš„åœ°å€ä½ç½®ï¼Œå› æ­¤ç¨‹åºå­˜å‚¨å™¨ç©ºé—´å¤§å°64KBï¼Œæœ€å¤§åœ°å€0000-FFFFH EA = 1(5V)æ—¶ï¼ŒPCå¤§äºæŸå€¼ä¸ºè®¿é—®å¤–éƒ¨ç¨‹åº å­˜å‚¨å™¨ï¼ŒPCå€¼å°äºæŸå€¼ä¸ºè®¿é—®å†…éƒ¨ç¨‹åºå­˜å‚¨å™¨ EA = 0(0V)æ—¶ï¼Œå†…éƒ¨å­˜å‚¨å™¨å°†è¢«å¿½ç•¥ã€‚ EAæ¥+5Væ—¶ï¼ŒPC çš„æœ‰æ•ˆåœ°å€èŒƒå›´åœ¨0000H ~ 0FFFHï¼ˆæ²¡æœ‰å¤–æ¥ROMï¼‰ï¼Œ0000H ~ FFFFHï¼ˆå¤–æ¥ROMï¼‰ ç¨‹åºå­˜å‚¨å™¨çš„0000Hå•å…ƒåœ°å€æ˜¯ç³»ç»Ÿç¨‹åºçš„å¯åŠ¨åœ°å€ï¼Œä¸€èˆ¬æ”¾ä¸€æ¡ç»å¯¹è½¬ç§»æŒ‡ä»¤ 00H - 1FHå•å…ƒä¸ºå·¥ä½œå¯„å­˜å™¨(é€šç”¨å¯„å­˜å™¨)ç»„åŒºï¼Œ32å­—èŠ‚ï¼Œæ¯ç»„ç”¨R0-R7è¡¨ç¤ºã€‚ 20H - 2FHä¸ºä½å¯»å€åŒºï¼Œ16å­—èŠ‚128ä½ï¼Œä½åœ°å€èŒƒå›´00H - 7FH 30H - 7FHä¸ºä¸€èˆ¬RAMåŒº(ç”¨æˆ·RAMåŒº)ï¼Œå…±80å­—èŠ‚ å †æ ˆæ˜¯ç”¨ç‰‡å†…æ•°æ®å­˜å‚¨å™¨çš„ä¸€æ®µåŒºåŸŸï¼Œä¸€èˆ¬åœ¨2FHä»¥åçš„å•å…ƒï¼Œè®¾ç½®äº†ä¸€ä¸ªå †æ ˆæŒ‡é’ˆSP ç‰¹æ®ŠåŠŸèƒ½å¯„å­˜å™¨ï¼šä¸“é—¨ç”¨äºæ§åˆ¶ï¼Œç®¡ç†ç‰‡å†…ç®—æ•°é€»è¾‘éƒ¨ä»¶ï¼Œå¹¶è¡ŒIOå£ï¼Œä¸²è¡Œå£ï¼Œå®šæ—¶å™¨è®¡æ•°å™¨ï¼Œä¸­æ–­ç³»ç»Ÿç­‰æ¨¡å—çš„å·¥ä½œï¼Œç¼–ç¨‹æ—¶å¯ä»¥ç»™å…¶è®¾å®šå€¼ï¼Œä½†æ˜¯ä¸èƒ½ç§»ä½œä»–ç”¨ï¼Œåˆ†å¸ƒåœ¨80H - FFHåœ°å€ç©ºé—´ å•ç‰‡æœºä¸­çš„CPUä¸»è¦ç”±è¿ç®—å™¨å’Œæ§åˆ¶å™¨ç»„æˆ 8051å•ç‰‡æœºæ²¡æœ‰å®šæ—¶å™¨/è®¡æ•°å™¨T2 DPTRå…·æœ‰16ä½å­—é•¿ ALEå¼•è„šï¼šåœ°å€é”å­˜å’Œä½¿èƒ½è¾“å‡ºç«¯å¼•è„š å“ˆä½›ç»“æ„çš„å†…éƒ¨åŒ…æ‹¬ï¼š4ä¸ªç‰©ç†ç©ºé—´å’Œ3ä¸ªé€»è¾‘ç©ºé—´ å•ç‰‡æœºè¦ä½¿ç”¨ç‰‡å†…å­˜å‚¨å™¨ï¼ŒEAå¼•è„šæ²¡æœ‰é™å®šï¼ˆæ‚¬ç©ºæˆ–æ¥5Vï¼‰ å•ç‰‡æœºå†…éƒ¨ç¨‹åºå­˜å‚¨å™¨å®¹é‡ä¸º4KB ç¬¬äºŒèŠ‚ P0å£ï¼šåŒå‘è¾“å…¥/è¾“å‡ºå£ P2å£ï¼šå‡†åŒå‘å£ï¼Œé€šç”¨IOæ¥å£å’Œé«˜8ä½åœ°å€çº¿ P3å£ï¼šå…·æœ‰ç¬¬äºŒåŠŸèƒ½ å››ä¸ª8ä½å¹¶è¡ŒIOå£ï¼Œæ—¢å¯ä»¥ä½œè¾“å…¥ï¼Œä¹Ÿå¯ä»¥åšè¾“å‡ºï¼Œæ—¢å¯ä»¥æŒ‰8ä½å¤„ç†ï¼Œä¹Ÿå¯ä»¥æŒ‰ä½æ–¹å¼ä½¿ç”¨ï¼Œè¾“å‡ºæ—¶å…·æœ‰é”å­˜èƒ½åŠ›ï¼Œè¾“å…¥æ—¶å…·æœ‰ç¼“å†²åŠŸèƒ½ã€‚ åœ¨é€šç”¨I/Oæ–¹å¼ä¸‹ï¼Œæ¬²ä»P1å£è¯»å–å¼•è„šç”µå¹³å‰åº”å½“å…ˆå‘P1å£å†™1 ç¨‹åºçŠ¶æ€å¯„å­˜å™¨ä¸­åæ˜ è¿›ä½æˆ–å€Ÿä½çŠ¶æ€çš„æ ‡å¿—ä½ç¬¦å·æ˜¯ï¼šCY ç¬¬ä¸‰èŠ‚ å¤ä½æ–¹å¼ï¼šå½“å¤–éƒ¨ç”µè·¯ä½¿å¾—RSTç«¯å‡ºç°ä¸¤ä¸ªæœºå™¨å‘¨æœŸä»¥ä¸Šçš„é«˜ç”µå¹³ï¼Œç³»ç»Ÿå†…éƒ¨å¤ä½ï¼Œå¤ä½æœ‰ä¸¤ç§æ–¹å¼ï¼šä¸Šç”µè‡ªåŠ¨å¤ä½å’Œæ‰‹åŠ¨æŒ‰é’®å¤ä½ æœºå™¨å‘¨æœŸï¼šæœºå™¨å‘¨æœŸæ˜¯å•ç‰‡æœºçš„åŸºæœ¬æ“ä½œå‘¨æœŸï¼Œæ¯ä¸ªæœºå™¨å‘¨æœŸåŒ…å«6ä¸ªçŠ¶æ€ï¼Œæ¯ä¸ªçŠ¶æ€åŒ…å«ä¸¤æ‹ï¼Œæ¯ä¸€æ‹ä¸ºä¸€ä¸ªä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸ(æŒ¯è¡å‘¨æœŸ)æœºå™¨å‘¨æœŸåŒ…å«12ä¸ªæ—¶é’Ÿå‘¨æœŸ å³ï¼šæ—¶é’Ÿå‘¨æœŸ = æŒ¯è¡å‘¨æœŸï¼Œä¸€ä¸ªæœºå™¨å‘¨æœŸ = 12ä¸ªæ—¶é’Ÿå‘¨æœŸ æŒ‡ä»¤å‘¨æœŸï¼šè®¡ç®—æœºå–ä¸€æ¡æŒ‡ä»¤è‡³æ‰§è¡Œå®Œè¯¥æŒ‡ä»¤éœ€è¦çš„æ—¶é—´ä¸ºæŒ‡ä»¤å‘¨æœŸï¼Œä¸åŒçš„æŒ‡ä»¤æŒ‡ä»¤å‘¨æœŸä¸åŒã€‚ å¤§éƒ¨åˆ†æŒ‡ä»¤ä¸ºä¸€ä¸ªæœºå™¨å‘¨æœŸæˆ–ä¸¤ä¸ªæœºå™¨å‘¨æœŸï¼Œåªæœ‰ä¹˜æ³•é™¤æ³•æŒ‡ä»¤è¦å››ä¸ªæœºå™¨å‘¨æœŸ å•ç‰‡æœºä¸Šç”µå¤ä½åï¼ŒPCçš„å†…å®¹å’ŒSPçš„å†…å®¹ä¸ºï¼š0000Hï¼Œ07H å•ç‰‡æœºä¸Šç”µå¤ä½åï¼ŒPSWçš„åˆå§‹å€¼ä¸º0 å•ç‰‡æœºçš„XTAL1å’ŒXTAL2å¼•è„šæ˜¯å¤–æ¥æ™¶æŒ¯å¼•è„šï¼ŒVss(20)V_{ss}(20)Vssâ€‹(20)å¼•è„šæ˜¯æ¥åœ°å¼•è„š PSWä¸­çš„RS1å’ŒRS0ç”¨æ¥ï¼šé€‰æ‹©å·¥ä½œå¯„å­˜å™¨ç»„å· PSWä¸­çš„R0å’ŒR1åˆ†åˆ«ä¸º0å’Œ1æ—¶ï¼Œç³»ç»Ÿé€‰ç”¨çš„å·¥ä½œå¯„å­˜å™¨ç»„ä¸ºç»„2 è‹¥å•ç‰‡æœºçš„æœºå™¨å‘¨æœŸä¸º12Î¼sï¼Œåˆ™å…¶æ™¶æŒ¯é¢‘ç‡ä¸º1MHz å•ç‰‡æœºå…·æœ‰å¤ä½åŠŸèƒ½çš„å¼•è„šæ˜¯RST å•ç‰‡æœºå†…éƒ¨åæ˜ è¿è¡ŒçŠ¶æ€æˆ–è¿ç®—ç»“æœç‰¹å¾çš„å¯„å­˜å™¨æ˜¯PSW å½“PSWä¸º18Hæ—¶ï¼Œåˆ™å½“å‰å·¥ä½œå¯„å­˜å™¨æ˜¯ï¼šç¬¬3ç»„ 18H -&gt; 00011000 RS1 = 1ï¼ŒRS0 = 1ï¼Œç¬¬ä¸‰ç»„","categories":[],"tags":[],"keywords":[]},{"title":"æ•´é™¤åˆ†å—","slug":"æ•´é™¤åˆ†å—","date":"2022-11-12T11:32:16.000Z","updated":"2022-11-12T11:36:38.780Z","comments":true,"path":"2022/11/12/æ•´é™¤åˆ†å—/","link":"","permalink":"https://memsetray.github.io/2022/11/12/æ•´é™¤åˆ†å—/","excerpt":"","text":"æ•´é™¤åˆ†å— æ•´é™¤åˆ†å—å¯ä»¥å¿«é€Ÿè®¡ç®—å«æœ‰ä¸‹å–æ•´é™¤æ³•çš„å’Œå¼ï¼Œæ—¶é—´å¤æ‚åº¦O(n)O(\\sqrt n)O(nâ€‹) ç»“è®ºï¼š å¯¹äºå¸¸æ•°nnnï¼Œä½¿å¾—å¼å­âŒŠniâŒ‹=âŒŠnjâŒ‹\\lfloor \\frac{n}{i} \\rfloor = \\lfloor \\frac{n}{j} \\rfloorâŒŠinâ€‹âŒ‹=âŒŠjnâ€‹âŒ‹æˆç«‹çš„æœ€å¤§çš„æ»¡è¶³iâ‰¤jâ‰¤ni \\leq j \\leq niâ‰¤jâ‰¤nçš„å€¼ä¸º âŒŠnâŒŠniâŒ‹âŒ‹\\lfloor \\frac{n}{\\lfloor \\frac{n}{i} \\rfloor} \\rfloor âŒŠâŒŠinâ€‹âŒ‹nâ€‹âŒ‹ è¯æ˜ç•¥ï¼Œæœ‰æ—¶é—´çš„è¯å†è¡¥ä¸€ä¸‹å§ã€‚ã€‚ å³å¯¹äºå·¦ç«¯ç‚¹lllï¼Œæ»¡è¶³å€¼ç­‰äºnl\\frac{n}{l}lnâ€‹çš„æœ€å¤§å³ç«¯ç‚¹rrrçš„å€¼ä¸ºä¸Šå¼ æ•°è®ºåˆ†å—çš„è¿‡ç¨‹ï¼š å¯¹äºå’Œå¼âˆ‘i=1nf(i)âŒŠniâŒ‹\\sum_{i = 1}^{n}f(i)\\lfloor \\frac{n}{i} \\rfloorâˆ‘i=1nâ€‹f(i)âŒŠinâ€‹âŒ‹ å…ˆè®¡ç®—å‡ºf(i)f(i)f(i)çš„å‰ç¼€å’Œï¼Œç„¶åæ¯æ¬¡è¿›è¡Œåˆ†å—ï¼Œå°†åˆ†å—æ±‚å‡ºçš„ç»“æœç´¯åŠ ã€‚ ä»£ç å®ç°ï¼š int H(int n) { int res = 0; int l = 1, r = 0; while(l &lt;= n) { r = n / (n / l); res += (r - l + 1) * 1ll * (n / l); l = r + 1; } return res; }","categories":[],"tags":[],"keywords":[]},{"title":"æ¯æ—¥ä¸¤é¢˜2022-11-7","slug":"æ¯æ—¥ä¸¤é¢˜2022-11-7","date":"2022-11-07T13:16:22.000Z","updated":"2022-11-07T13:17:13.192Z","comments":true,"path":"2022/11/07/æ¯æ—¥ä¸¤é¢˜2022-11-7/","link":"","permalink":"https://memsetray.github.io/2022/11/07/æ¯æ—¥ä¸¤é¢˜2022-11-7/","excerpt":"","text":"æ¯æ—¥ä¸¤é¢˜2022-11-6 ABC130D -Enough Array ç»™å‡ºnnnä¸ªæ•°ï¼Œæ±‚è¿™äº›æ•°ä¸­æœ‰å¤šå°‘ä¸ªè¿ç»­å­åºåˆ—çš„å’Œå¤§äºç­‰äºkkk æ•°æ®èŒƒå›´ï¼š 1â‰¤aiâ‰¤1051 \\leq a_i \\leq 10^51â‰¤aiâ€‹â‰¤105 1â‰¤nâ‰¤1051 \\leq n \\leq 10^51â‰¤nâ‰¤105 1â‰¤kâ‰¤10101 \\leq k \\leq 10^{10}1â‰¤kâ‰¤1010 æ€è·¯ å‰ç¼€å’Œ+åŒæŒ‡é’ˆ é¦–å…ˆå¯ä»¥å‘ç°ä¸€ä¸ªç»“è®ºï¼šå¯¹äºä¸€ä¸ªè¿ç»­å­åºåˆ—ï¼Œå¦‚æœå…¶å’Œå¤§äºç­‰äºkkkï¼Œé‚£ä¹ˆåœ¨å…¶åŠ å…¥å…¶ä»–ä»»æ„éè´Ÿæ•´æ•°æ—¶ä¹Ÿä¸€å®šæ»¡è¶³å¤§äºç­‰äºkkk å¦‚æœæˆ‘ä»¬ç”¨åŒæŒ‡é’ˆæšä¸¾å·¦ç«¯ç‚¹ï¼Œè€ƒè™‘å³ç«¯ç‚¹çš„ä½ç½®åœ¨ä½•å¤„å¤§äºç­‰äºkkkï¼Œè®¾è¯¥ä½ç½®ä¸ºrrrï¼Œåˆ™åœ¨rrrä¹‹å‰çš„æ‰€æœ‰è¿ç»­å­åºåˆ—éƒ½ä¸æ»¡è¶³å¤§äºç­‰äºkkkï¼Œè€Œåœ¨rrrä¹‹åçš„æ‰€æœ‰è¿ç»­å­åºåˆ—éƒ½ä¸€å®šæ»¡è¶³å¤§äºç­‰äºkkkï¼Œè¿™ä¸ªå­åºåˆ—çš„ä¸ªæ•°å¯ä»¥O(1)O(1)O(1)åœ°è®¡ç®—å‡ºæ¥ï¼Œå³pppä¹‹åçš„å…ƒç´ ä¸ªæ•°nâˆ’r+1n - r + 1nâˆ’r+1 åœ¨éå†å®Œæ‰€æœ‰çš„å·¦ç«¯ç‚¹åï¼Œä¸Šé¢çš„ç­”æ¡ˆç´¯åŠ èµ·æ¥å³ä¸ºæœ€ç»ˆçš„ç­”æ¡ˆ AC ä»£ç  #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 1e5 + 10; int a[N]; int s[N]; int res; signed main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; s[i] = s[i - 1] + a[i]; } int l = 0, r = 0; while(r &lt;= n) { if(s[r] - s[l] &lt; k) r ++; else { res += (n - r + 1); l ++; } } cout &lt;&lt; res &lt;&lt; endl; return 0; } ABC130E - Common Subsequence ç»™å‡ºä¸¤ä¸ªé•¿åº¦ä¸ºnnnå’Œmmmçš„æ•´æ•°åºåˆ—SSSå’ŒTTTï¼Œæ±‚SSSä¸TTTçš„å…¬å…±å­åºåˆ—çš„ä¸ªæ•°å¯¹1e9+71e9+71e9+7å–æ¨¡çš„ç»“æœã€‚ æ•°æ®èŒƒå›´ï¼š 1â‰¤Si,Tiâ‰¤1051 \\leq S_i,T_i \\leq 10^51â‰¤Siâ€‹,Tiâ€‹â‰¤105 1â‰¤n,m,â‰¤20001 \\leq n,m, \\leq 20001â‰¤n,m,â‰¤2000 æ€è·¯ çº¿æ€§$DP$ï¼Œè®¾$dp[i][j]$è¡¨ç¤ºä»$S$çš„å‰$i$ä¸ªæ•°ä¸­é€‰ï¼Œ$T$çš„å‰$j$ä¸ªæ•°ä¸­é€‰çš„å…¬å…±å­åºåˆ—çš„ä¸ªæ•° è€ƒè™‘å½“å‰çš„çŠ¶æ€å¦‚ä½•è½¬ç§»è€Œæ¥ï¼š æ˜¾ç„¶dp[i][j]dp[i][j]dp[i][j]çš„çŠ¶æ€åº”è¯¥ç”±dp[iâˆ’1][j]dp[i - 1][j]dp[iâˆ’1][j]ä¸dp[i][jâˆ’1]dp[i][j - 1]dp[i][jâˆ’1]è½¬ç§»è€Œæ¥ ç„¶åè€ƒè™‘å½“å‰ä½æ˜¯å¦ç›¸åŒï¼Œå¦‚æœs[i]â‰ t[j]s[i] \\neq t[j]s[i]î€ â€‹=t[j]ï¼Œè¯´æ˜dp[iâˆ’1][j]+dp[i][jâˆ’1]dp[i - 1][j] + dp[i][j - 1]dp[iâˆ’1][j]+dp[i][jâˆ’1]ä¹‹åä¼šæœ‰è®¡ç®—é‡å¤çš„éƒ¨åˆ†(å› ä¸ºå½“å‰ä½ä¸å¯¹ç­”æ¡ˆæœ‰è´¡çŒ®)ã€‚å› æ­¤è¦å‡å»é‡å¤ç´¯åŠ çš„dp[iâˆ’1][jâˆ’1]dp[i - 1][j - 1]dp[iâˆ’1][jâˆ’1] å³s[i]â‰ t[i]s[i] \\neq t[i]s[i]î€ â€‹=t[i]æ—¶dp[i][j]=dp[iâˆ’1][j]+dp[i][jâˆ’1]âˆ’dp[iâˆ’1][jâˆ’1]dp[i][j] = dp[i - 1][j]+dp[i][j - 1]-dp[i - 1][j - 1]dp[i][j]=dp[iâˆ’1][j]+dp[i][jâˆ’1]âˆ’dp[iâˆ’1][jâˆ’1] å¦‚æœs[i]=t[i]s[i] = t[i]s[i]=t[i]åˆ™å½“å‰ä½å¯¹ç­”æ¡ˆå…·æœ‰è´¡çŒ®(å› ä¸ºäº§ç”Ÿäº†æ–°çš„å…¬å…±å­åºåˆ—)ï¼Œå› æ­¤ä¸éœ€è¦å‡å»é‡å¤çš„éƒ¨åˆ†ï¼Œå¦å¤–å†åŠ ä¸Šå½“å‰ä½å•ç‹¬äº§ç”Ÿçš„å­åºåˆ— å³s[i]=t[i]s[i] = t[i]s[i]=t[i]æ—¶dp[i][j]=dp[iâˆ’1][j]+dp[i][jâˆ’1]+1dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + 1dp[i][j]=dp[iâˆ’1][j]+dp[i][jâˆ’1]+1 ç­”æ¡ˆå³ä¸ºdp[n][m]dp[n][m]dp[n][m]ï¼Œæ³¨æ„å–æ¨¡å³å¯ã€‚ AC ä»£ç  #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 2010, mod = 1e9 + 7; int dp[N][N]; int a[N], b[N]; int n, m; signed main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= m; i ++) cin &gt;&gt; b[i]; for(int i = 1; i &lt;= n; i ++) { for(int j = 1; j &lt;= m; j ++) { if(a[i] != b[j]) dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + mod) % mod; else dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + 1) % mod; } } cout &lt;&lt; (dp[n][m] + 1) % mod &lt;&lt; endl; return 0; }","categories":[],"tags":[],"keywords":[]},{"title":"æ¯æ—¥ä¸€é¢˜2022-11-3","slug":"æ¯æ—¥ä¸€é¢˜2022-11-3","date":"2022-11-03T15:26:53.000Z","updated":"2022-11-03T15:28:36.415Z","comments":true,"path":"2022/11/03/æ¯æ—¥ä¸€é¢˜2022-11-3/","link":"","permalink":"https://memsetray.github.io/2022/11/03/æ¯æ—¥ä¸€é¢˜2022-11-3/","excerpt":"","text":"æ¯æ—¥ä¸¤é¢˜2022-11-3 ABC129C - Typical Stairs æœ‰nnnçº§å°é˜¶ï¼Œæœ‰mmmçº§å°é˜¶ä¸èƒ½èµ°ï¼Œåˆ†åˆ«ä¸ºa1,...ama_1,...a_ma1â€‹,...amâ€‹çº§å°é˜¶ã€‚ ç°åœ¨ä½ è¦ä»ç¬¬000çº§å°é˜¶å‡ºå‘ï¼Œæ¯æ¬¡å¯ä»¥å‘ä¸Šä¸€æ ¼æˆ–ä¸¤æ ¼ï¼Œæ±‚èµ°åˆ°ç¬¬nnnçº§å°é˜¶çš„æ–¹æ¡ˆæ•°ï¼Œç­”æ¡ˆå¯¹109+710^9+7109+7å–æ¨¡ã€‚ æ•°æ®èŒƒå›´ï¼š 1â‰¤nâ‰¤1051 \\leq n \\leq 10^51â‰¤nâ‰¤105 0â‰¤mâ‰¤nâˆ’10 \\leq m \\leq n - 10â‰¤mâ‰¤nâˆ’1 1â‰¤a1â‰¤a2â‰¤...â‰¤amâ‰¤nâˆ’11 \\leq a_1 \\leq a_2 \\leq ... \\leq a_m \\leq n - 11â‰¤a1â€‹â‰¤a2â€‹â‰¤...â‰¤amâ€‹â‰¤nâˆ’1 æ€è·¯ æ˜¾ç„¶çº¿æ€§$DP$ï¼Œè€ƒè™‘å½“å‰ç¬¬$i$çº§å°é˜¶çš„ç­”æ¡ˆç”±é‚£äº›æƒ…å†µé€’æ¨å‡ºæ¥ æœ¬é¢˜ä¸­æ¯æ¬¡å¯ä»¥èµ°ä¸€æ ¼æˆ–ä¸¤æ ¼ï¼Œå› æ­¤ç¬¬iiiçº§å°é˜¶å¯ä»¥ç”±ç¬¬iâˆ’1i - 1iâˆ’1çº§å°é˜¶æˆ–è€…ç¬¬iâˆ’2i - 2iâˆ’2çº§å°é˜¶èµ°ä¸Šæ¥ã€‚ è®¾dp[i]dp[i]dp[i]è¡¨ç¤ºä»èµ°åˆ°ç¬¬iiiçº§å°é˜¶çš„æ–¹æ¡ˆæ•°ï¼Œåˆ™çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š dp[i]=dp[iâˆ’1]+dp[iâˆ’2]dp[i] = dp[i - 1] + dp[i - 2]dp[i]=dp[iâˆ’1]+dp[iâˆ’2] ä¹‹åè€ƒè™‘ä¸èƒ½èµ°çš„å°é˜¶ï¼Œå¦‚æœå½“å‰æšä¸¾åˆ°çš„å°é˜¶ä¸èƒ½èµ°ï¼Œè·³è¿‡å³å¯ï¼Œå¦‚æœiâˆ’1i - 1iâˆ’1å’Œiâˆ’2i - 2iâˆ’2çº§å°é˜¶ä¸èƒ½èµ°ï¼Œæˆ‘ä»¬æ— éœ€é¢å¤–è€ƒè™‘ï¼ˆå› ä¸ºdpdpdpå€¼ä¸º0ï¼‰ æœ€åæ³¨æ„è¾¹ç•Œï¼šdp[1]dp[1]dp[1]çš„å€¼ä¸èƒ½ç›´æ¥åˆå§‹åŒ–ä¸º111ï¼Œè¦è€ƒè™‘åˆ°è¯¥å°é˜¶ä¸èƒ½èµ°çš„æƒ…å†µã€‚ AC ä»£ç  #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 1e5 + 10, mod = 1e9 + 7; int dp[N], v[N]; int n, k; signed main() { cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= k; i ++) { int x; cin &gt;&gt; x; v[x] = 1; } //dp[i] = dp[i - 1] + dp[i - 2]; dp[0] = 1, dp[1] = (v[1] == 1 ? 0 : 1); for(int i = 2; i &lt;= n; i ++) { if(!v[i]) dp[i] = (dp[i - 1] + dp[i - 2]) % mod; } cout &lt;&lt; dp[n] % mod &lt;&lt; endl; return 0; } ABC129E -Sum Equals Xor ä»¥äºŒè¿›åˆ¶å½¢å¼ç»™å‡ºä¸€ä¸ªæ•´æ•°LLLï¼Œé—®æœ‰å¤šå°‘ä¸ªéè´Ÿæ•´æ•°å¯¹(a,b)(a,b)(a,b)æ»¡è¶³ï¼š a+b=aâŠ•bâ‰¤La + b = a \\oplus b \\leq La+b=aâŠ•bâ‰¤L ç­”æ¡ˆå¯¹109+710^9 + 7109+7å–æ¨¡ æ€è·¯ æ˜¾ç„¶çº¿æ€§$DP$ï¼Œè€ƒè™‘å½“å‰ç¬¬$i$çº§å°é˜¶çš„ç­”æ¡ˆç”±é‚£äº›æƒ…å†µé€’æ¨å‡ºæ¥ æ•°ä½$DP$ï¼Œé¢˜ç›®ä¸­ç»™å®šçš„å·²ç»æ˜¯äºŒè¿›åˆ¶å½¢å¼ï¼Œæ˜¾ç„¶æŒ‰ç…§äºŒè¿›åˆ¶å½¢å¼çš„æ¯ä¸€ä½è¿›è¡Œè®¨è®ºã€‚ è§‚å¯Ÿå¯çŸ¥a+b=aâŠ•bâ‰¤La + b = a \\oplus b \\leq La+b=aâŠ•bâ‰¤Lç­‰ä»·äºa,ba,ba,bçš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸ŠåŒä¸€ä½ä¸Šä¸èƒ½åŒæ—¶ä¸º111ã€‚ è®¾dp[i][0]dp[i][0]dp[i][0]è¡¨ç¤ºaâŠ•ba \\oplus baâŠ•bçš„å‰iiiä½å°äºLLLçš„å‰iiiä¸ºçš„æ–¹æ¡ˆæ•°ï¼Œdp[i][1]dp[i][1]dp[i][1]è¡¨ç¤ºaâŠ•ba \\oplus baâŠ•bçš„å‰iiiä½ç­‰äºLLLçš„å‰iiiä½çš„æ–¹æ¡ˆæ•°ã€‚ è€ƒè™‘çŠ¶æ€å¦‚ä½•é€’æ¨è€Œæ¥ï¼š è‹¥LLLçš„ç¬¬iiiä½ä¸º1ï¼Œç¬¦åˆç­‰äºæ¡ä»¶çš„æƒ…å†µæœ‰ï¼šä¸Šä¸€ä½ç­‰äºLLLä¸”è¿™ä¸€ä½a=1,b=0a = 1,b = 0a=1,b=0æˆ–è€…a=0,b=1a = 0,b = 1a=0,b=1ï¼Œç¬¦åˆå°äºæ¡ä»¶çš„æƒ…å†µæœ‰ï¼šä¸Šä¸€ä½å°äºLLLï¼Œä¸”è¿™ä¸€ä½a=0,b=0a = 0,b = 0a=0,b=0æˆ–è€…a=1,b=0a = 1,b = 0a=1,b=0æˆ–è€…a=0,b=1a = 0,b = 1a=0,b=1ï¼Œä¸Šä¸€ä½ç­‰äºLLLä¸”a=0,b=0a = 0,b = 0a=0,b=0 å³ï¼šdp[i][0]=dp[iâˆ’1][0]âˆ—3+dp[iâˆ’1][1]dp[i][0] = dp[i - 1][0] * 3 + dp[i - 1][1]dp[i][0]=dp[iâˆ’1][0]âˆ—3+dp[iâˆ’1][1] dp[i][1]=dp[iâˆ’1][1]âˆ—2dp[i][1] = dp[i - 1][1] * 2dp[i][1]=dp[iâˆ’1][1]âˆ—2 è‹¥LLLçš„ç¬¬iiiä½ä¸º000ï¼Œç¬¦åˆç­‰äºæ¡ä»¶çš„æƒ…å†µæœ‰ï¼šä¸Šä¸€ä½ç­‰äºLLLä¸”a=0,b=0a = 0,b = 0a=0,b=0ï¼Œç¬¦åˆå°äºæ¡ä»¶çš„æƒ…å†µæœ‰ï¼šä¸Šä¸€ä½å°äºLLLï¼Œä¸”a=0,b=0a = 0,b = 0a=0,b=0æˆ–è€…a=0,b=1a = 0,b = 1a=0,b=1æˆ–è€…a=1,b=0a = 1,b = 0a=1,b=0 å³ï¼šdp[i][0]=(dp[iâˆ’1][0]âˆ—3)dp[i][0] = (dp[i - 1][0] * 3)dp[i][0]=(dp[iâˆ’1][0]âˆ—3) dp[i][1]=dp[iâˆ’1][1]dp[i][1] = dp[i - 1][1]dp[i][1]=dp[iâˆ’1][1] ç­”æ¡ˆå³ä¸ºdp[n][0]+dp[n][1]dp[n][0] + dp[n][1]dp[n][0]+dp[n][1] AC ä»£ç  #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 1e5 + 10, mod = 1e9 + 7; char s[N]; int dp[N][2]; signed main() { cin &gt;&gt; (s + 1); int n = strlen(s + 1); dp[0][1] = 1; for(int i = 1; i &lt;= n; i ++) { dp[i][0] = (dp[i - 1][0] * 3) % mod; if(s[i] == '1') { dp[i][0] = (dp[i][0] + dp[i - 1][1]) % mod; dp[i][1] = (dp[i - 1][1] * 2) % mod; } else dp[i][1] = dp[i - 1][1]; } cout &lt;&lt; (dp[n][1] + dp[n][0]) % mod; return 0; }","categories":[],"tags":[],"keywords":[]},{"title":"ACMç®—æ³•æ¨¡æ¿","slug":"ACMç®—æ³•æ¨¡æ¿","date":"2022-10-18T05:52:56.000Z","updated":"2022-10-18T05:56:22.974Z","comments":true,"path":"2022/10/18/ACMç®—æ³•æ¨¡æ¿/","link":"","permalink":"https://memsetray.github.io/2022/10/18/ACMç®—æ³•æ¨¡æ¿/","excerpt":"","text":"1. åŸºç¡€ç®—æ³• 1.1æ±‚é€†åºå¯¹æ•°é‡ long long m_sort(int l,int r) { if(l&gt;=r) return 0; int mid=l+r&gt;&gt;1; int i=l,j=mid+1; long long res=m_sort(l,mid)+m_sort(mid+1,r); int k=0; while(i&lt;=mid&amp;&amp;j&lt;=r) { if(q[i]&lt;=q[j]) temp[k++]=q[i++]; else { temp[k++]=q[j++]; res+=mid-i+1; } } while(i&lt;=mid) { temp[k++]=q[i++]; } while(j&lt;=r) temp[k++]=q[j++]; for(int i=l,j=0;i&lt;=r;i++,j++) q[i]=temp[j]; return res; } 1.2 äºŒåˆ† while(l&lt;r) { int mid=l+r&gt;&gt;1; if(q[mid]&gt;=k) r=mid; //äºŒåˆ†ï¼Œè‹¥å³åŒºé—´è¢«æ›¿æ¢ï¼Œåˆ™midä¸ºl+r&gt;&gt;1 else l=mid+1; } while(l&lt;r) { int mid=l+r+1 &gt;&gt; 1; if(q[mid]&lt;=k) l=mid; //è‹¥å·¦åŒºé—´è¢«æ›¿æ¢ï¼Œåˆ™midä¸ºl+r+1&gt;&gt;1 else r=mid-1; } 1.3 äºŒç»´å‰ç¼€å’Œä¸å·®åˆ†ä¸äºŒç»´å·®åˆ† /äºŒç»´å‰ç¼€å’Œ for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=m;j++) S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j]; //ä¸€ç»´å·®åˆ† void insert(int l,int r,int c) { b[l]+=c; b[r+1]-=c; } for(int i=1;i&lt;=n;i++) insert(i,i,a[i]); while (m -- ){ int l,r,c; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c; insert(l,r,c); } for(int i=1;i&lt;=n;i++) b[i]+=b[i-1]; //äºŒç»´å·®åˆ† void insert(int x1,int y1,int x2,int y2,int c) { b[x1][y1]+=c; b[x2+1][y1]-=c; b[x1][y2+1]-=c; b[x2+1][y2+1]+=c; } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) insert(i,j,i,j,a[i][j]); while (q -- ){ int x1,y1,x2,y2,c; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c; insert(x1,y1,x2,y2,c); } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1]; 1.4 åŒæŒ‡é’ˆå…¸ä¾‹ 1.4.1 æœ€é•¿è¿ç»­ä¸é‡å¤å­åºåˆ— int res=0; for(int i=0,j=0;i&lt;n;i++) { s[a[i]]++; while(s[a[i]]&gt;1) { s[a[j]]--; j++; } res=max(res,i-j+1); } 1.4.2 åˆ¤æ–­aæ˜¯å¦ä¸ºbçš„å­åºåˆ—ï¼ˆ1e5ï¼‰ int i=0,j=0; while( i&lt;n &amp;&amp;j &lt; m) { if(a[i]==b[j]) i++;; j++; } 1.5 éœ€è¦ä¿åºçš„ç¦»æ•£åŒ– typedef pair&lt;int, int&gt; PII; //æ¯ä¸€æ¬¡æ“ä½œéƒ½æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ï¼Œè¿™é‡Œç”¨pair int n,m; int a[N],s[N]; vector &lt;int&gt; alls; //allsæ•°ç»„å†…å­˜çš„æ˜¯æ‰€æœ‰éœ€è¦è¿›è¡Œç¦»æ•£åŒ–çš„æ•°ä»¥åŠè¿›è¡Œå®Œç¦»æ•£åŒ–ä¹‹åçš„æ•°ç»„ vector&lt;PII&gt; add,query; //addæ•°ç»„å†…å­˜çš„æ˜¯æ¯æ¬¡å¯¹æ•°çš„æ“ä½œï¼Œqueryæ•°ç»„å†…å­˜çš„æ˜¯æ¯æ¬¡è¯¢é—®çš„å·¦å³åŒºé—´ int find (int x) //æŸ¥æ‰¾ç¦»æ•£åŒ–åæ•°ç»„çš„ä¸‹æ ‡ { int l = 0, r = alls.size()-1; while(l &lt; r) { int mid = (l+r) &gt;&gt; 1; if(alls[mid] &gt;= x) r = mid; //å½“è¯¥ä¸‹æ ‡å¯¹åº”çš„å€¼ä¸ºå¾…æŸ¥æ‰¾å€¼ï¼ˆç¦»æ•£åŒ–å‰çš„å¤§æ•°ï¼‰æ—¶ï¼Œè¿”å›ä¸‹æ ‡+1ï¼ˆä¸ºäº†ä»1å¼€å§‹ä¾¿äºæ±‚å‰ç¼€å’Œï¼‰ else l = mid + 1; } return r + 1; } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=0;i &lt; n ; i++) { int x , c; scanf(&quot;%d%d&quot;,&amp;x, &amp;c); add.push_back({x,c}); //æŠŠå¯¹åŸæ•°ç»„çš„æ“ä½œå­˜æ”¾è¿›å»,å³æŠŠxåŠ ä¸Šc alls.push_back(x); //å°†éœ€è¦è¿›è¡Œç¦»æ•£åŒ–çš„æ•°å­˜åˆ°allsé‡Œ } for(int i = 0; i &lt; m; i++) { int l, r; scanf(&quot;%d%d&quot;,&amp;l, &amp;r); query.push_back({l, r}); //æŠŠæ¯æ¬¡è¯¢é—®å­˜æ”¾è¿›å»ï¼Œå³å­˜æ”¾éœ€è¦æ±‚å’Œçš„å·¦å³åŒºé—´ alls.push_back(l); //ç”±äºl,rä¹Ÿå¯èƒ½æ˜¯å¤§æ•°ï¼Œå› æ­¤æˆ‘ä»¬ä¹Ÿéœ€è¦å°†lå’Œrè¿›è¡Œç¦»æ•£åŒ– alls.push_back(r); } //æ­¤å¤„æ˜¯ç¦»æ•£åŒ–çš„æ ¸å¿ƒï¼Œå³è¿›è¡Œç¦»æ•£åŒ–çš„è¿‡ç¨‹ sort(alls.begin(), alls.end()); //å°†éœ€è¦ç¦»æ•£åŒ–çš„æ•°ç»„è¿›è¡Œæ’åº alls.erase(unique(alls.begin(), alls.end()),alls.end()); //å»é‡ï¼Œç›®çš„æ˜¯å°†æ•°ç»„ä¸­çš„å­˜æ”¾çš„æ•°é‡å‡å°‘ï¼ŒèŠ‚çœå†…å­˜ç©ºé—´ for(auto it : add) { int x = find(it.first); //å¯»æ‰¾è¢«åŠ çš„æ•°è¿›è¡Œç¦»æ•£åŒ–ä¹‹åçš„ä¸‹æ ‡ a[x] += it.second; //æ±‚ç¦»æ•£åŒ–åçš„æ•°ç»„a } for(int i=1;i&lt;=alls.size(); i++) s[i] = s[i-1] + a[i]; //æ±‚ç¦»æ•£åŒ–åæ•°ç»„çš„å‰ç¼€å’Œ for(auto it : query) { //å¤„ç†æ¯æ¬¡è¯¢é—® int l = find(it.first); //å¯»æ‰¾å·¦åŒºé—´è¿›è¡Œç¦»æ•£åŒ–ä¹‹åçš„ä¸‹æ ‡ int r = find(it.second); //å¯»æ‰¾å³åŒºé—´è¿›è¡Œç¦»æ•£åŒ–ä¹‹åçš„ä¸‹æ ‡ printf(&quot;%d\\n&quot; ,s[r]-s[l-1]); //æ±‚åŒºé—´å’Œ } return 0; } 1.6 ä¸éœ€è¦ä¿åºçš„ç¦»æ•£åŒ– //å¾…è¡¥å…… 1.7 åŒºé—´åˆå¹¶ vector&lt;PII&gt; segs; void merge(vector&lt;PII&gt; &amp;segs) { vector&lt;PII&gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for(auto seg : segs) { if(ed &lt; seg.first) { if(st != -2e9) res.push_back({st , ed}); st = seg.first; ed = seg.second; } else ed=max(ed , seg.second); } if(st != -2e9) res.push_back({st , ed}); segs=res; } int main() { int n; cin&gt;&gt;n; for(int i = 0;i &lt; n; i++ ) { int l , r; cin&gt;&gt;l&gt;&gt;r; segs.push_back({l,r}); } merge(segs); cout&lt;&lt;segs.size()&lt;&lt;endl; return 0; } 1.8 åŒºé—´æœ€å€¼é—®é¢˜ï¼ˆRMQï¼‰ int w[N]; int f[N][M]; int n, m; void init() { for(int j = 0; j &lt; M; j ++) //å…ˆæšä¸¾åŒºé—´é•¿åº¦ { for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++) //æšä¸¾åŒºé—´å·¦ç«¯ç‚¹ { if(!j) f[i][j] = w[i]; else f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; j - 1)][j - 1]); } } } int query(int l, int r) { int len = r - l + 1; int k = log(len) / log(2); return max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]); //è¿™ä¸¤ä¸ªåŒºé—´ä¸€å®šè¦†ç›–æŸ¥è¯¢åŒºé—´ } int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; w[i]; init(); cin &gt;&gt; m; while (m -- ) { int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(l, r) &lt;&lt; endl; } return 0; } 1.9 manacherç®—æ³• int n; char a[N], b[N]; int p[N]; int res; void init() { int k = 0; b[k ++] = '$'; b[k ++] = '#'; for(int i = 0; i &lt; n; i ++) { b[k ++] = a[i]; b[k ++] = '#'; } b[k ++] = '^'; n = k; } void manacher() { int mr = 0, mid; for(int i = 1; i &lt; n; i ++) { if(i &lt; mr) p[i] = min(p[mid * 2 - i], mr - i); else p[i] = 1; while(b[i - p[i]] == b[i + p[i]]) p[i] ++; if(i + p[i] &gt; mr) { mr = i + p[i]; mid = i; } } } int main() { scanf(&quot;%s&quot;, a); n = strlen(a); init(); manacher(); for(int i = 0; i &lt; n; i ++) res = max(res, p[i]); cout &lt;&lt; res - 1 &lt;&lt; endl; return 0; } 1.10 æœ€å°è¡¨ç¤ºæ³• //ç”¨äºæ±‚å­—ç¬¦ä¸²çš„æœ€å°è¡¨ç¤ºï¼Œå¯ä»¥ç”¨æ¥åˆ¤æ–­ä¸¤ä¸ªç¯å½¢å­—ç¬¦ä¸²æ˜¯å¦æ˜¯åŒä¸€ä¸ªå­—ç¬¦ä¸² int get_min(char s[]) { int i = 0, j = 1; while(i &lt; n &amp;&amp; j &lt; n) { int k = 0; while(k &lt; n &amp;&amp; s[i + k] == s[j + k]) k ++; if(k == n) break; if(s[i + k] &gt; s[j + k]) i += k + 1; else j += k + 1; if(i == j) j ++; } int k = min(i, j); s[k + n] = 0; return k; } int main() { cin &gt;&gt; a &gt;&gt; b; n = strlen(a); memcpy(a + n, a, n); memcpy(b + n, b, n); int x = get_min(a); int y = get_min(b); if(strcmp(a + x, b + y)) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else { cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; cout &lt;&lt; a + x &lt;&lt; endl; } return 0; } 1.11 å¯¹é¡¶å †ç»´æŠ¤åŠ¨æ€ä¸­ä½æ•° /* å¯¹é¡¶å †ï¼Œç»´æŠ¤ä¸€ä¸ªå¤§æ ¹å †å’Œä¸€ä¸ªå°æ ¹å †ï¼Œå¯¹äºæ¯ä¸ªå…ƒç´ ï¼Œå¦‚æœå¤§æ ¹å †ä¸ºç©ºæˆ–å°äºå¤§æ ¹å †é¡¶ï¼Œåˆ™æ’å…¥å¤§æ ¹å †ï¼Œå¦åˆ™æ’åˆ°å°æ ¹å †ï¼Œè¿™ä¸¤ä¸ªå †éœ€è¦æ—¶åˆ»æ»¡è¶³ï¼š åºåˆ—ä¸­ä»å°åˆ°å¤§æ’åä¸º1 ~ M / 2 + 1çš„æ•´æ•°åœ¨å¤§æ ¹å †ä¸­ åºåˆ—ä¸­ä»å°åˆ°å¤§æ’åä¸ºM / 2 + 2 ~ Mçš„æ•´æ•°å­˜å‚¨åœ¨å°æ ¹å †ä¸­ å¦‚æœä¸æ»¡è¶³ï¼Œå°±æŠŠå¤šå‡ºæ¥çš„æ•°æ”¾åˆ°å¦ä¸€ä¸ªå †ï¼Œç”±æ­¤åºåˆ—çš„ä¸­ä½æ•°ä¸€å®šæ˜¯å¤§æ ¹å †çš„å †é¡¶ */ int main() { int T; cin &gt;&gt; T; while(T --) { priority_queue&lt;int&gt; b_heap; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; s_heap; int n, m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; (m + 1 &gt;&gt; 1) &lt;&lt; endl; int cnt = 0; for(int i = 0; i &lt; m; i ++) { int x; cin &gt;&gt; x; if(b_heap.empty() || x &lt;= b_heap.top()) //å¤§æ ¹å †ä¸ºç©ºæˆ–xå°äºå¤§æ ¹å †é¡¶ï¼Œæ’å…¥å¤§æ ¹å † b_heap.push(x); else s_heap.push(x); //å¦åˆ™æ’å…¥å°æ ¹å † if(b_heap.size() &gt; s_heap.size() + 1) { s_heap.push(b_heap.top()); b_heap.pop(); } if(s_heap.size() &gt; b_heap.size()) { b_heap.push(s_heap.top()); s_heap.pop(); } if(i % 2 == 0) { cout &lt;&lt; b_heap.top() &lt;&lt; &quot; &quot;; if(++ cnt % 10 == 0) cout &lt;&lt; endl; } } if(cnt % 10) cout &lt;&lt; endl; } return 0; } 1.12 äºŒè¿›åˆ¶çŠ¶æ€å‹ç¼©æ±‚æœ€çŸ­Hamiltonè·¯å¾„ int n; int w[N][N]; //ç”¨wæ¥å­˜å‚¨æ•´ä¸ªå›¾ int f[M][N]; //f[i][j]è¡¨ç¤ºä»0èµ°åˆ°jï¼Œèµ°è¿‡çš„ç‚¹ä¸ºiçš„æ‰€æœ‰è·¯å¾„é•¿åº¦ï¼Œiæ˜¯ä¸€ä¸ª20ä½äºŒè¿›åˆ¶æ•°ï¼Œå¦‚æœç¬¬kä½ä¸º1ï¼Œè¡¨ç¤ºè¿™ä¸ªç‚¹å·²ç»èµ°è¿‡äº† int main() { cin &gt;&gt; n; //nä¸ªç‚¹ for(int i = 0; i &lt; n; i ++) { for(int j = 0; j &lt; n; j ++) cin &gt;&gt; w[i][j]; //è¾“å…¥nä¸ªç‚¹ } memset(f, 0x3f, sizeof f); //åˆå§‹åŒ–è·¯å¾„é•¿åº¦ä¸ºæ— ç©·å¤§ f[1][0] = 0; //åˆå§‹åŒ–0å·ç‚¹çš„è·¯å¾„é•¿åº¦ä¸º0 for(int i = 0; i &lt; 1 &lt;&lt; n; i ++) //æšä¸¾æ‰€æœ‰çš„çŠ¶æ€ for(int j = 0; j &lt; n; j ++) if(i &gt;&gt; j &amp; 1) //ä»0èµ°åˆ°jæ—¶ï¼Œiä¸­ä¸€å®šè¦åŒ…å«jï¼Œå³içš„ç¬¬jä½ä¸€å®šä¸º1 for(int k = 0; k &lt; n; k ++) //æšä¸¾jç‚¹ä»å“ªä¸€ä¸ªç‚¹è½¬ç§»è¿‡æ¥ if((i - (1 &lt;&lt; j)) &gt;&gt; k &amp; 1) //å¦‚æœié™¤å»ç¬¬jä¸ªç‚¹ä¹‹ååŒ…å«ç¬¬kä¸ªç‚¹ f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j]); //é‚£ä¹ˆå½“å‰çš„çŠ¶æ€å°±æ˜¯ä»0èµ°åˆ°kåŠ ä¸Škèµ°åˆ°jçš„æ‰€æœ‰è·¯å¾„å–æœ€å°å€¼ cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl; //è¾“å‡ºèµ°å®Œæ‰€æœ‰çš„ç‚¹ï¼Œå¹¶ä¸”èµ°åˆ°n-1å·ç‚¹æ—¶çš„è·ç¦» return 0; } 2. æ•°æ®ç»“æ„ 2.1 å•è°ƒæ ˆ //ç”¨äºå¯»æ‰¾ä¸€ä¸ªæ•°å·¦è¾¹æœ€è¿‘çš„æ¯”å®ƒå¤§ï¼ˆå°ï¼‰çš„æ•° int stk[N],tt; int main() { int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { int x; cin&gt;&gt;x; while(tt &amp;&amp; stk[tt]&gt;=x) tt--; if(tt) cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;; else cout&lt;&lt;&quot;-1&quot;&lt;&lt;&quot; &quot;; stk[++tt] = x; } return 0; } 2.2 å•è°ƒé˜Ÿåˆ—ï¼ˆæ»‘åŠ¨çª—å£ï¼‰ //ç»´æŠ¤åŒºé—´å†…æœ€å¤§å€¼å’Œæœ€å°å€¼ int n,k; int a[N],q[N]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); int hh=0,tt=-1; for(int i=0;i&lt;n;i++) { //é¦–å…ˆåˆ¤æ–­é˜Ÿå¤´æ˜¯å¦æ»‘å‡ºæ»‘åŠ¨çª—å£ if(hh &lt;=tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; q[++tt] = i; if(i &gt;= k-1) printf(&quot;%d &quot;,a[q[hh]]); } puts(&quot;&quot;); hh = 0, tt = -1; for(int i=0;i&lt;n;i++) { //é¦–å…ˆåˆ¤æ–­é˜Ÿå¤´æ˜¯å¦æ»‘å‡ºæ»‘åŠ¨çª—å£ if(hh &lt;=tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; q[++tt] = i; if(i &gt;= k - 1) printf(&quot;%d &quot;,a[q[hh]]); } puts(&quot;&quot;); return 0; } 2.3 KMPç®—æ³• /* KMPç®—æ³•æ˜¯ä¸€ç§åœ¨æ¨¡å¼ä¸²ä¸­å¯»æ‰¾ç»™å®šæ¨¡æ¿ä¸²çš„ä¸€ç§ç®—æ³•ï¼Œè¯¥ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(M+N)ï¼Œç›¸è¾ƒäºæš´åŠ›ç®—æ³•ï¼Œè¯¥ç®—æ³•æœ€å¤§çš„ç‰¹ç‚¹æ˜¯æ¨¡æ¿ä¸²æŒ‡é’ˆä¸éœ€è¦å›æº¯å³å¯åˆ¤æ–­ä¸¤ä¸ªä¸²æ˜¯å¦åŒ¹é… è¯¥ç®—æ³•éœ€è¦æ³¨æ„çš„å‡ ä¸ªåœ°æ–¹ 1. nextæ•°ç»„çš„å«ä¹‰ï¼šnext[i]çš„å«ä¹‰ä¸ºï¼šå½“å½“å‰æ¨¡å¼ä¸²ä¸æ¨¡æ¿ä¸²çš„å…ƒç´ ä¸åŒ¹é…æ—¶ï¼Œå½“å‰å…ƒç´ ä¹‹å‰çš„æ¨¡æ¿ä¸²çš„å…ƒç´ ä¸­ï¼Œå‰ç¼€ä¸åç¼€ç›¸åŒçš„æœ€å¤§ä¸²é•¿åº¦ 2. æ±‚nextæ•°ç»„æ—¶ï¼Œnextæ•°ç»„ä»ä¸‹æ ‡2å¼€å§‹æ±‚ï¼Œå› ä¸ºnext[0]å’Œnext[1]çš„å€¼å‡ä¸º0, 3. è¿›è¡ŒkmpåŒ¹é…æ—¶ï¼Œä»iä¸‹æ ‡1å¼€å§‹ï¼Œjä»ä¸‹æ ‡0å¼€å§‹ 4. pæ•°ç»„å’Œsæ•°ç»„å‡ä»ä¸‹æ ‡1å¼€å§‹å­˜æ”¾å…ƒç´  */ int n,m; char p[N], s[M]; int ne[N]; int main() { cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1; //pæ•°ç»„å’Œsæ•°ç»„å‡ä»ä¸‹æ ‡1å¼€å§‹å­˜æ”¾å…ƒç´  //æ±‚nextæ•°ç»„çš„è¿‡ç¨‹ for(int i = 2 ,j = 0; i &lt;= n ; i++ ) { while(j &amp;&amp; p[i] != p[j+1]) j=ne[j]; //å‰ç¼€ä¸åç¼€ä¸åŒæ—¶ï¼Œè®°å½•å‰ç¼€ä¸åç¼€ç›¸åŒæ—¶çš„é•¿åº¦ if(p[i] == p[j+1]) j++; //å¦‚æœå‰ç¼€å’Œåç¼€ç›¸åŒï¼Œé‚£ä¹ˆijç»§ç»­å³ç§»ï¼Œåˆ¤æ–­æ›´å¤§çš„å‰ç¼€åç¼€æ˜¯å¦ç›¸åŒ ne[i] = j; //nextæ•°ç»„çš„å«ä¹‰æ˜¯:å½“å½“å‰æ¨¡å¼ä¸²ä¸æ¨¡æ¿ä¸²çš„å…ƒç´ ä¸åŒ¹é…æ—¶ï¼Œå½“å‰å…ƒç´ ä¹‹å‰çš„æ¨¡æ¿ä¸²çš„å…ƒç´ ä¸­ï¼Œå‰ç¼€ä¸åç¼€ç›¸åŒçš„æœ€å¤§ä¸²é•¿åº¦ } //kmpçš„åŒ¹é…è¿‡ç¨‹ for(int i = 1, j = 0; i &lt;= m; i ++) { while(j &amp;&amp; s[i] != p[j+1]) j = ne[j]; //å½“æ¨¡æ¿ä¸²ä¸æ¨¡å¼ä¸²ä¸åŒ¹é…æ—¶ï¼Œå°†æ¨¡æ¿ä¸²å³ç§»ne[j]çš„è·ç¦» if(s[i] == p[j+1]) j++; //å¦‚æœæ¨¡æ¿ä¸²ä¸æ¨¡å¼ä¸²åŒ¹é…ï¼Œé‚£ä¹ˆå°±å°†å®ƒä»¬çš„ä¸‹ä¸€ä½è¿›è¡ŒåŒ¹é… if(j == n) //å¦‚æœæ¨¡æ¿ä¸²æ‰€æœ‰çš„å­—ç¬¦éƒ½è¢«åŒ¹é…äº†ï¼Œé‚£ä¹ˆåŒ¹é…æˆåŠŸ { printf(&quot;%d &quot;,i-n); j=ne[j]; } } return 0; } 2.4 Trieç»Ÿè®¡å­—ç¬¦ä¸² //sonæ•°ç»„ç¬¬ä¸€ç»´è¡¨ç¤ºnå·èŠ‚ç‚¹ï¼Œç¬¬äºŒç»´è¡¨ç¤ºå®ƒçš„ç¬¬å‡ ä¸ªå„¿å­ int son[N][26],cnt[N],idx; char str[N]; void insert(char str[]) { int p=0; for(int i=0 ; str[i] ; i++) { int u = str[i] - 'a'; //å°†å­—æ¯æ˜ å°„åˆ°ä¸‹æ ‡ if(!son[p][u]) son[p][u]=++idx; //å¦‚æœè¯¥èŠ‚ç‚¹çš„å„¿å­ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆå°±å°†å®ƒåŠ å…¥è¿›å» p=son[p][u]; //è½¬åˆ°på·èŠ‚ç‚¹çš„uå·å„¿å­ } cnt[p]++; //å‡ºç°æ¬¡æ•°+1 } int query(char str[]) { int p=0; for(int i=0;str[i];i++) { int u = str[i] - 'a'; if(!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main() { int n; cin&gt;&gt;n; while (n -- ){ char op[2]; scanf(&quot;%s%s&quot;,op,str); if(op[0] == 'I') insert(str); else printf(&quot;%d\\n&quot;, query(str)); } return 0; } 2.5 å¹¶æŸ¥é›†å¸¦ç»´æŠ¤é›†åˆå¤§å° int find(int x) // å¹¶æŸ¥é›† { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { p[i]=i; siz[i]=1; } cin&gt;&gt;m; while (m -- ) { char op[5]; int a,b; scanf(&quot;%s&quot;,op); if(op[0] == 'C') { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(find(a) == find(b)) continue; siz[find(b)] += siz[find(a)]; p[find(a)] = find(b); } else if(op[1] == '1') { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(find(a) == find(b)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } else if(op[1] == '2') { scanf(&quot;%d&quot;,&amp;a); cout&lt;&lt;siz[find(a)]&lt;&lt;endl; } } return 0; } 2.6 æ‹“å±•åŸŸå¹¶æŸ¥é›†ï¼ˆæ‹†ç‚¹ï¼‰ int find(int x) { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin &gt;&gt; n &gt;&gt; k; int res = 0; for(int i = 1; i &lt;= 3 * n; i ++) p[i] = i; while(k --) { int d, x, y; cin &gt;&gt; d &gt;&gt; x &gt;&gt; y; int xs = x, xe = x + n, xy = x + 2 * n; int ys = y, ye = y + n, yy = y + 2 * n; if(d == 1) { if(x &gt; n || y &gt; n) res ++; else if(find(xs) == find(yy)) res ++; else if(find(ye) == find(xs)) res ++; else { p[find(xs)] = find(ys); p[find(xe)] = find(ye); p[find(xy)] = find(yy); } } if(d == 2) { if(x &gt; n || y &gt; n) res ++; else if(x == y) res ++; else if(find(xs) == find(ys)) res ++; else if(find(ye) == find(xs)) res ++; else { p[find(xe)] = find(ys); p[find(xs)] = find(yy); p[find(xy)] = find(ye); } } } cout &lt;&lt; res &lt;&lt; endl; return 0; } 2.7 æ‰‹å†™å †æ’åº int h[N]; int n,m; int siz; void down(int u) { int t = u; //tä¸ºæœ€å°å€¼ if(u * 2 &lt;= siz &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; //å¦‚æœå·¦å„¿å­å­˜åœ¨å¹¶ä¸”å·¦å„¿å­çš„å€¼å°äºçˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œé‚£ä¹ˆæœ€å°å€¼æ›´æ–°ä¸ºå·¦å„¿å­ if(u * 2 + 1 &lt;= siz &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; //å¦‚æœå³å„¿å­å­˜åœ¨å¹¶ä¸”å³å„¿å­çš„å€¼å°äºçˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œé‚£ä¹ˆæœ€å°å€¼æ›´æ–°ä¸ºå³å„¿å­ if(u != t) //å¦‚æœä¼ å…¥çš„å€¼ä¸æ˜¯æœ€å°å€¼ï¼Œé‚£ä¹ˆå°†è¯¥å€¼ä¸æœ€å°å€¼äº’æ¢ï¼Œç„¶åé€’å½’å°†è¯¥å€¼æ”¾å…¥å †ä¸­ { swap(h[u], h[t]); down(t); } } void up(int u) { while(u / 2 &amp;&amp; h[u / 2] &gt; h[u]) { swap(h[u / 2], h[u]); u /= 2; } } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;h[i]); siz = n; for(int i = n / 2; i; i--) down(i); while (m -- ) { cout &lt;&lt; h[1] &lt;&lt; &quot; &quot;; h[1] = h[siz]; siz--; down(1); } return 0; } 2.8 å­—ç¬¦ä¸²å“ˆå¸Œ //ç”¨äºåˆ¤æ–­ä¸¤ä¸ªåŒºé—´å†…çš„å­—ç¬¦ä¸²æ˜¯å¦å®Œå…¨ç›¸åŒ typedef unsigned long long ULL; const int N = 1e5 + 5, P = 131; ULL h[N], p[N]; ULL query(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; string x; cin &gt;&gt; x; p[0] = 1; h[0] = 0; for(int i = 0; i &lt; n; i ++) { p[i + 1] = p[i] * P; h[i + 1] = h[i] * P + x[i]; } while(m --) { int l1, r1, l2, r2; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2; if(query(l1, r1) == query(l2, r2)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; } return 0; } 2.9 æ ‘çŠ¶æ•°ç»„ 2.9.1 åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ LL tr[N]; int a[N]; int n, m; int lowbit(int x) { return x &amp; -x; } void add(int x, int c) { for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; } LL sum(int x) { LL res = 0; for(int i = x; i ; i -= lowbit(i)) res += tr[i]; return res; } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n ; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n ;i ++) { add(i, a[i] - a[i - 1]); } while(m --) { char op[2]; int l; scanf(&quot;%s%d&quot;, op, &amp;l); if(op[0] == 'C') { int r, d; cin &gt;&gt; r &gt;&gt; d; add(l, d); add(r + 1, -d); } else cout &lt;&lt; sum(l) &lt;&lt; endl; } return 0; } 2.9.2 å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ int lowbit(int x) { return x &amp; -x; } void add(int x, int c) { for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; } int sum(int x) { int res = 0; for(int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } 2.9.3 åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ int a[N]; LL tr1[N], tr2[N]; int n, m; int lowbit(int x) { return x &amp; -x; } void add(LL tr[], int x, LL c) { for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; } LL sum(LL tr[], int x) { LL res = 0; for(int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } LL pre_sum(int x) //æ±‚åŸæ•°ç»„çš„å‰ç¼€å’Œ { return sum(tr1, x) * (x + 1) - sum(tr2, x); } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i ++) { int b = a[i] - a[i - 1]; add(tr1, i, b); add(tr2, i, (LL)b * i); } while(m --) { char op[2]; int l ,r, d; scanf(&quot;%s%d%d&quot;, op, &amp;l, &amp;r); if(op[0] == 'Q') printf(&quot;%lld\\n&quot;, pre_sum(r) - pre_sum(l - 1)); //åŸæ•°ç»„çš„åŒºé—´æŸ¥è¯¢ else { cin &gt;&gt; d; add(tr1, l, d), add(tr2, l, l * d); add(tr1, r + 1, -d), add(tr2, r + 1, (r + 1) * -d); } } return 0; } 2.10 çº¿æ®µæ ‘ 2.10.1 å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10; struct info { int minv, cnt_min; }; struct Node { info val; }tr[N * 4]; int n, q; int a[N]; info operator + (const info &amp;l, const info &amp;r) { info a; a.minv = min(l.minv, r.minv); if(l.minv == r.minv) a.cnt_min = l.cnt_min + r.cnt_min; else if(l.minv &lt; r.minv) a.cnt_min = l.cnt_min; else a.cnt_min = r.cnt_min; return a; } void pushup(int u) { tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val; } void build(int u, int l, int r) { if(l == r) tr[u].val = {a[l], 1}; else { int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void change(int u, int l, int r, int pos, int val) { if(l == r) tr[u].val = {val, 1}; else { int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) change(u &lt;&lt; 1, l, mid, pos, val); else change(u &lt;&lt; 1 | 1, mid + 1, r, pos, val); pushup(u); } } info query(int u, int l, int r, int ql, int qr) { if(l == ql &amp;&amp; r == qr) return tr[u].val; int mid = l + r &gt;&gt; 1; if(qr &lt;= mid) return query(u &lt;&lt; 1, l, mid, ql, qr); else if(ql &gt; mid) return query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr); else { return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 1, n); while(q --) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if(a == 1) { change(1, 1, n, b, c); } else { auto a = query(1, 1, n, b, c); printf(&quot;%d %d\\n&quot;, a.minv, a.cnt_min); } } } 2.10.2 åŒºé—´æœ€å¤§å…¬çº¦æ•°ï¼ˆåŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ï¼‰ struct Node{ int l, r; LL sum, d; }tr[N * 4]; LL a[N]; LL gcd(LL a, LL b) { return b ? gcd(b, a % b) : a; } void build(int u, int l, int r) { if(l == r) { LL b = a[r] - a[r - 1]; tr[u] = {l, l, b, b}; } else { tr[u] = {l ,r}; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum; tr[u].d = gcd(tr[u &lt;&lt; 1].d, tr[u &lt;&lt; 1 | 1].d); } } Node query(int u, int l, int r) { if(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) return tr[u]; else { int mid = tr[u].l + tr[u].r &gt;&gt; 1; if(r &lt;= mid) return query(u &lt;&lt; 1, l, r); if(l &gt; mid) return query(u &lt;&lt; 1 | 1, l, r); else { auto left = query(u &lt;&lt; 1, l, r); auto right = query(u &lt;&lt; 1 | 1, l, r); Node res; res.sum = left.sum + right.sum; res.d = gcd(left.d, right.d); return res; } } } void modify(int u, int x, LL c) { if(tr[u].l == x &amp;&amp; tr[u].r == x) { LL b = tr[u].sum + c; tr[u] = {x, x, b, b}; } else { int mid = tr[u].l +tr[u].r &gt;&gt; 1; if(x &lt;= mid) modify(u &lt;&lt; 1, x, c); else modify(u &lt;&lt; 1 | 1, x, c); tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum; tr[u].d = gcd(tr[u &lt;&lt; 1].d, tr[u &lt;&lt; 1 | 1].d); } } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; build(1, 1, n); char op[2]; while(m --) { int l, r; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if(op[0] == 'C') { LL d; cin &gt;&gt; d; modify(1, l, d); if(r + 1 &lt;= n) modify(1, r + 1, -d); } else { auto left = query(1, 1, l); Node right({0, 0, 0, 0}); if(l + 1 &lt;= r) right = query(1, l + 1, r); cout &lt;&lt; abs(gcd(left.sum, right.d)) &lt;&lt; endl; } } return 0; } 2.10.3 å¸¦æ‡’æ ‡è®°çš„åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10; typedef long long ll; ll n, q; ll a[N]; struct info { ll maxv; }; struct tag { ll add; }; info operator + (const info &amp;l, const info &amp;r) { return {max(l.maxv, r.maxv)}; } info operator + (const info &amp;v, const tag &amp;t) { return {v.maxv + t.add}; } tag operator + (const tag &amp;t1, const tag &amp;t2) { return {t1.add + t2.add}; } struct node { tag t; info val; }tr[N * 4]; void pushup(int u) { tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val; } void settag(int u, tag t) { tr[u].val = tr[u].val + t; tr[u].t = tr[u].t + t; } void pushdown(int u) { if(tr[u].t.add != 0) { settag(u &lt;&lt; 1, tr[u].t); settag(u &lt;&lt; 1 | 1, tr[u].t); tr[u].t.add = 0; } } void build(int u, int l, int r) { if(l == r) tr[u].val = {a[l]}; else { ll mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int l, int r, int ql, int qr, tag t) { if(l == ql &amp;&amp; r == qr) { settag(u, t); return ; } ll mid = l + r &gt;&gt; 1; pushdown(u); if(qr &lt;= mid) modify(u &lt;&lt; 1, l, mid, ql, qr, t); else if(ql &gt; mid) modify(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr, t); else { modify(u &lt;&lt; 1, l, mid, ql, mid, t); modify(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr, t); } pushup(u); } info query(int u, int l, int r, int ql, int qr) { if(l == ql &amp;&amp; r == qr) return tr[u].val; ll mid = l + r &gt;&gt; 1; pushdown(u); if(qr &lt;= mid) query(u &lt;&lt; 1, l, mid, ql, qr); else if(ql &gt; mid) query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr); else { return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 1, n); while(q --) { int op; scanf(&quot;%d&quot;, &amp;op); if(op == 1) { int l, r, d; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d); modify(1, 1, n, l, r, (tag){d}); } else { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); auto a = query(1, 1, n, l, r); printf(&quot;%lld\\n&quot;, a.maxv); } } return 0; } 2.10.4 æ‰«æçº¿æ±‚çŸ©å½¢çš„é¢ç§¯å¹¶ struct Segment { double x, y1, y2; int k; bool operator&lt; (const Segment &amp;t)const { return x &lt; t.x; } }seg[N * 2]; struct Node { int l, r; int cnt; double len; }tr[N * 8]; vector&lt;double&gt; ys; int find(double y) { return lower_bound(ys.begin(), ys.end(), y) - ys.begin(); } void pushup(int u) { if (tr[u].cnt) tr[u].len = ys[tr[u].r + 1] - ys[tr[u].l]; else if (tr[u].l != tr[u].r) { tr[u].len = tr[u &lt;&lt; 1].len + tr[u &lt;&lt; 1 | 1].len; } else tr[u].len = 0; } void build(int u, int l, int r) { tr[u] = {l, r, 0, 0}; if (l != r) { int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); } } void modify(int u, int l, int r, int k) { if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) { tr[u].cnt += k; pushup(u); } else { int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, k); if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, k); pushup(u); } } int main() { int T = 1; while (scanf(&quot;%d&quot;, &amp;n), n) { ys.clear(); for (int i = 0, j = 0; i &lt; n; i ++ ) { double x1, y1, x2, y2; scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); seg[j ++ ] = {x1, y1, y2, 1}; seg[j ++ ] = {x2, y1, y2, -1}; ys.push_back(y1), ys.push_back(y2); } sort(ys.begin(), ys.end()); ys.erase(unique(ys.begin(), ys.end()), ys.end()); build(1, 0, ys.size() - 2); sort(seg, seg + n * 2); double res = 0; for (int i = 0; i &lt; n * 2; i ++ ) { if (i &gt; 0) res += tr[1].len * (seg[i].x - seg[i - 1].x); modify(1, find(seg[i].y1), find(seg[i].y2) - 1, seg[i].k); } printf(&quot;Test case #%d\\n&quot;, T ++ ); printf(&quot;Total explored area: %.2lf\\n\\n&quot;, res); } return 0; } 2.10.5 åŠ¨æ€å¼€ç‚¹ä¸æƒå€¼çº¿æ®µæ ‘ //å¾…è¡¥å…… 2.11 å¯æŒä¹…åŒ–æ•°æ®ç»“æ„ 2.11.1 å¯æŒä¹…åŒ–Trie //æ”¯æŒä¸¤ç§æ“ä½œï¼šæœ«å°¾æ·»åŠ ä¸€ä¸ªæ•°ï¼Œæ±‚ä¸€ä¸ªä½ç½®pï¼Œä½¿å¾—påœ¨l-rä¹‹é—´ï¼Œä¸”a[p] xor ... xor a[n] xor xçš„å€¼æœ€å¤§ int tr[M][2], max_id[M]; int root[N]; int n, m, idx; int s[N]; void insert(int i, int k, int p, int q) //iä¸ºå‰ç¼€å’Œä¸‹æ ‡ï¼Œkä¸ºå½“å‰ç¬¬å‡ ä½ï¼Œpä¸ºä¸Šä¸€ä¸ªç‰ˆæœ¬ï¼Œqä¸ºå½“å‰ç‰ˆæœ¬ { if(k &lt; 0) { max_id[q] = i; return ; } int v = s[i] &gt;&gt; k &amp; 1; if(p) tr[q][v ^ 1] = tr[p][v ^ 1]; tr[q][v] = ++ idx; insert(i, k - 1, tr[p][v], tr[q][v]); max_id[q] = max(max_id[tr[q][0]], max_id[tr[q][1]]); } int query(int root, int c, int l) { int p = root; for(int i = 23; i &gt;= 0; i --) { int v = c &gt;&gt; i &amp; 1; if(max_id[tr[p][v ^ 1]] &gt;= l) p = tr[p][v ^ 1]; else p = tr[p][v]; } return c ^ s[max_id[p]]; } int main() { cin &gt;&gt; n &gt;&gt; m; max_id[0] = -1; root[0] = ++ idx; insert(0, 23, 0, root[0]); for(int i = 1; i &lt;= n; i ++) { int x; cin &gt;&gt; x; s[i] = s[i - 1] ^ x; root[i] = ++ idx; insert(i, 23, root[i - 1], root[i]); } char op[2]; int l, r, x; while(m --) { cin &gt;&gt; op; if(op[0] == 'A') { cin &gt;&gt; x; n ++; s[n] = s[n - 1] ^ x; root[n] = ++ idx; insert(n, 23, root[n - 1], root[n]); } else { cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; cout &lt;&lt; query(root[r - 1], s[n] ^ x, l - 1) &lt;&lt; endl; } } return 0; } 2.11.2 å¯æŒä¹…åŒ–çº¿æ®µæ ‘(ä¸»å¸­æ ‘) //æ±‚åŒºé—´å†…ç¬¬kå°æ•° int n, m; int a[N]; vector&lt;int&gt; nums; struct Node { int l, r; int cnt; }tr[N * 4 + N * 17]; int root[N], idx; int build(int l, int r) //l,rè¡¨ç¤ºå·¦å³å„¿å­ { int p = ++ idx; if(l == r) return p; int mid = l + r &gt;&gt; 1; tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r); return p; } int insert(int p, int l, int r, int x) { int q = ++ idx; tr[q] = tr[p]; if(l == r) { tr[q].cnt ++; return q; } int mid = l + r &gt;&gt; 1; if(x &lt;= mid) tr[q].l = insert(tr[p].l, l, mid, x); else tr[q].r = insert(tr[p].r, mid + 1, r, x); tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt; return q; } int find(int x) { return lower_bound(nums.begin(), nums.end(), x) - nums.begin(); } int query(int q, int p, int l, int r, int k) { if(l == r) return r; int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt; int mid = l + r &gt;&gt; 1; if(k &lt;= cnt) return query(tr[q].l, tr[p].l, l, mid, k); else return query(tr[q].r, tr[p].r, mid + 1, r, k - cnt); } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; nums.push_back(a[i]); } sort(nums.begin(), nums.end()); nums.erase(unique(nums.begin(), nums.end()), nums.end()); root[0] = build(0, nums.size() - 1); for(int i = 1; i &lt;= n; i ++) root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i])); while(m --) { int l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &lt;&lt; endl; } } 2.12 å¹³è¡¡æ ‘ 2.12.1 æ™®é€šå¹³è¡¡æ ‘ï¼ˆTreapï¼‰ /* æ”¯æŒçš„æ“ä½œï¼š 1. æ’å…¥æ•°å€¼ xã€‚ 2. åˆ é™¤æ•°å€¼ x(è‹¥æœ‰å¤šä¸ªç›¸åŒçš„æ•°ï¼Œåº”åªåˆ é™¤ä¸€ä¸ª)ã€‚ 3. æŸ¥è¯¢æ•°å€¼ x çš„æ’å(è‹¥æœ‰å¤šä¸ªç›¸åŒçš„æ•°ï¼Œåº”è¾“å‡ºæœ€å°çš„æ’å)ã€‚ 4. æŸ¥è¯¢æ’åä¸º x çš„æ•°å€¼ã€‚ 5. æ±‚æ•°å€¼ x çš„å‰é©±(å‰é©±å®šä¹‰ä¸ºå°äº x çš„æœ€å¤§çš„æ•°)ã€‚ 6. æ±‚æ•°å€¼ x çš„åç»§(åç»§å®šä¹‰ä¸ºå¤§äº x çš„æœ€å°çš„æ•°)ã€‚ */ struct Node { int l, r; int key, val; int cnt, size; //cntè¡¨ç¤ºæŸä¸ªæ•°å‡ºç°çš„æ¬¡æ•°ï¼Œsizeè¡¨ç¤ºå­æ ‘ä¸­æœ‰å¤šå°‘ä¸ªæ•° }tr[N]; int root, idx; //idxè¡¨ç¤ºå½“å‰åˆ†é…åˆ°ç¬¬å‡ ä¸ªèŠ‚ç‚¹ void pushup(int p) { tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt; } int get_node(int key) //åˆ›å»ºèŠ‚ç‚¹ { tr[++ idx].key = key; tr[idx].val = rand(); tr[idx].cnt = tr[idx].size = 1; //åˆå§‹åŒ–cntå’Œsize return idx; } void zig(int &amp;p) //å³æ—‹ï¼Œä¼ å¼•ç”¨ { int q = tr[p].l; tr[p].l = tr[q].r, tr[q].r = p, p = q; pushup(tr[p].r), pushup(p); } void zag(int &amp;p) { int q = tr[p].r; tr[p].r = tr[q].l, tr[q].l = p, p = q; pushup(tr[p].l), pushup(p); } void build() { get_node(-INF), get_node(INF); //æ’å…¥æ­£æ— ç©·å’Œæ— è´Ÿç©·å“¨å…µ root = 1, tr[1].r = 2; //æ ¹èŠ‚ç‚¹æ˜¯ä¸€å·ç‚¹ï¼Œå³å„¿å­æ˜¯äºŒå·ç‚¹ pushup(root); if(tr[1].val &lt;tr[2].val) zag(root); } void insert(int &amp;p, int key) { if(!p) p = get_node(key); else if(tr[p].key == key) tr[p].cnt ++; else if(tr[p].key &gt; key) { insert(tr[p].l, key); if(tr[tr[p].l].val &gt; tr[p].val) zig(p); } else { insert(tr[p].r, key); if(tr[tr[p].r].val &gt; tr[p].val) zag(p); } pushup(p); } void remove(int &amp;p, int key) { if(!p) return ; if(tr[p].key == key) { if(tr[p].cnt &gt; 1) tr[p].cnt --; else if(tr[p].l || tr[p].r) { if(!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val) { zig(p); remove(tr[p].r, key); } else { zag(p); remove(tr[p].l, key); } } else p = 0; } else if(tr[p].key &gt; key) remove(tr[p].l, key); else remove(tr[p].r, key); pushup(p); } int get_rank_by_key(int &amp;p, int key) //é€šè¿‡æ’åæ‰¾æ•°å€¼ { if(!p) return 0; if(tr[p].key == key) return tr[tr[p].l].size + 1; if(tr[p].key &gt; key) return get_rank_by_key(tr[p].l, key); return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r, key); } int get_key_by_rank(int &amp;p, int rank) //é€šè¿‡æ•°å€¼æ‰¾æ’å { if(!p) return INF; if(tr[tr[p].l].size &gt;= rank) return get_key_by_rank(tr[p].l, rank); if(tr[tr[p].l].size + tr[p].cnt &gt;= rank) return tr[p].key; return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt); } int get_prev(int &amp;p, int key) //æ‰¾åˆ°ä¸¥æ ¼å°äºkeyçš„æœ€å¤§æ•° { if(!p) return -INF; if(tr[p].key &gt;= key) return get_prev(tr[p].l, key); return max(tr[p].key, get_prev(tr[p].r, key)); } int get_next(int &amp;p, int key) //æ‰¾åˆ°ä¸¥æ ¼å¤§äºkeyçš„æœ€å°æ•° { if(!p) return INF; if(tr[p].key &lt;= key) return get_next(tr[p].r, key); return min(tr[p].key, get_next(tr[p].l, key)); } int main() { build(); cin &gt;&gt; n; while(n --) { int op, x; cin &gt;&gt; op &gt;&gt; x; if(op == 1) insert(root, x); else if(op == 2) remove(root, x); else if(op == 3) cout &lt;&lt; get_rank_by_key(root, x) - 1 &lt;&lt; endl; else if(op == 4) cout &lt;&lt; get_key_by_rank(root, x + 1) &lt;&lt; endl; else if(op == 5) cout &lt;&lt; get_prev(root, x) &lt;&lt; endl; else if(op == 6) cout &lt;&lt; get_next(root, x) &lt;&lt; endl; } return 0; } 2.12.2 Splay(ä¼¸å±•æ ‘) /* m æ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œé€‰å®šä¸€ä¸ªå­åºåˆ— [l,r]ï¼Œå¹¶å°†è¯¥å­åºåˆ—ä¸­çš„æ‰€æœ‰æ•°å­—è¿›è¡Œç¿»è½¬ */ int n, m; struct Node { int s[2], p, v; int size, flag; void init(int _v, int _p) { v = _v, p = _p; size = 1; } }tr[N]; int root, idx; void pushup(int x) { tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1; } void pushdown(int x) { if (tr[x].flag) { swap(tr[x].s[0], tr[x].s[1]); tr[tr[x].s[0]].flag ^= 1; tr[tr[x].s[1]].flag ^= 1; tr[x].flag = 0; } } void rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = tr[y].s[1] == x; // k=0è¡¨ç¤ºxæ˜¯yçš„å·¦å„¿å­ï¼›k=1è¡¨ç¤ºxæ˜¯yçš„å³å„¿å­ tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; pushup(y), pushup(x); } void splay(int x, int k) { while (tr[x].p != k) { int y = tr[x].p, z = tr[y].p; if (z != k) if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x); else rotate(y); rotate(x); } if (!k) root = x; } void insert(int v) { int u = root, p = 0; while (u) p = u, u = tr[u].s[v &gt; tr[u].v]; u = ++ idx; if (p) tr[p].s[v &gt; tr[p].v] = u; tr[u].init(v, p); splay(u, 0); } int get_k(int k) { int u = root; while (true) { pushdown(u); if (tr[tr[u].s[0]].size &gt;= k) u = tr[u].s[0]; else if (tr[tr[u].s[0]].size + 1 == k) return u; else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1]; } return -1; } void output(int u) { pushdown(u); if (tr[u].s[0]) output(tr[u].s[0]); if (tr[u].v &gt;= 1 &amp;&amp; tr[u].v &lt;= n) printf(&quot;%d &quot;, tr[u].v); if (tr[u].s[1]) output(tr[u].s[1]); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt;= n + 1; i ++ ) insert(i); while (m -- ) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); l = get_k(l), r = get_k(r + 2); splay(l, 0), splay(r, l); tr[tr[r].s[0]].flag ^= 1; } output(root); return 0; } 2.13 ACè‡ªåŠ¨æœº /ç»™å®šnä¸ªå•è¯ï¼Œé•¿åº¦ä¸ºmçš„æ–‡ç« ï¼Œæ±‚æœ‰å¤šå°‘ä¸ªå•è¯åœ¨æ–‡ç« ä¸­å‡ºç°äº† int n; int tr[N * S][26], cnt[N * S], idx; char str[M]; int q[N * S], ne[N * S]; void insert() { int p = 0; for (int i = 0; str[i]; i ++ ) { int t = str[i] - 'a'; if (!tr[p][t]) tr[p][t] = ++ idx; p = tr[p][t]; } cnt[p] ++ ; } void build() { int hh = 0, tt = -1; for (int i = 0; i &lt; 26; i ++ ) if (tr[0][i]) q[ ++ tt] = tr[0][i]; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = 0; i &lt; 26; i ++ ) { int p = tr[t][i]; if (!p) tr[t][i] = tr[ne[t]][i]; else { ne[p] = tr[ne[t]][i]; q[ ++ tt] = p; } } } } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T -- ) { memset(tr, 0, sizeof tr); memset(cnt, 0, sizeof cnt); memset(ne, 0, sizeof ne); idx = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) { scanf(&quot;%s&quot;, str); insert(); } build(); scanf(&quot;%s&quot;, str); int res = 0; for (int i = 0, j = 0; str[i]; i ++ ) { int t = str[i] - 'a'; j = tr[j][t]; int p = j; while (p) { res += cnt[p]; cnt[p] = 0; p = ne[p]; } } printf(&quot;%d\\n&quot;, res); } return 0; } 2.14 åˆ†å—ä¸è«é˜Ÿ 2.14.1 åˆ†å—è§£å†³åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ LL a[N], sum[N], add[N]; int L[N], R[N]; int pos[N]; int n, m, t; void modify(int l, int r, LL d) { int p = pos[l], q = pos[r]; if(p == q) { for(int i = l; i &lt;= r; i ++) a[i] += d; sum[p] += d * (r - l + 1); } else { for(int i = p + 1; i &lt;= q - 1; i ++) add[i] += d; for(int i = l; i &lt;= R[p]; i ++) a[i] += d; sum[p] += d * (R[p] - l + 1); for(int i = L[q]; i &lt;= r; i ++) a[i] += d; sum[q] += d * (r - L[q] + 1); } } LL query(int l, int r) { int p = pos[l], q = pos[r]; LL ans = 0; if(p == q) { for(int i = l; i &lt;= r; i ++) ans += a[i]; ans += add[p] * (r - l + 1); } else { for(int i = p + 1; i &lt;= q - 1; i ++) ans += sum[i] + add[i] * (R[i] - L[i] + 1); for(int i = l; i &lt;= R[p]; i ++) ans += a[i]; ans += add[p] * (R[p] - l + 1); for(int i = L[q]; i &lt;= r; i ++) ans += a[i]; ans += add[q] * (r - L[q] + 1); } return ans; } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; //åˆ†å— t = sqrt(n); for(int i = 1; i &lt;= t; i ++) { L[i] = (i - 1) * sqrt(n) + 1; R[i] = i * sqrt(n); } if(R[t] &lt; n) { t ++; L[t] = R[t - 1] + 1; R[t] = n; } for(int i = 1; i &lt;= t; i ++) { for(int j = L[i]; j &lt;= R[i]; j ++) { pos[j] = i; sum[i] += a[j]; } } while(m --) { char op[3]; int l, r, d; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if(op[0] == 'C') { cin &gt;&gt; d; modify(l, r, d); } else cout &lt;&lt; query(l, r) &lt;&lt; endl; } return 0; } 2.14.2 åˆ†å—-å—çŠ¶é“¾è¡¨ //å¾…è¡¥å…… 2.14.3 åŸºç¡€è«é˜Ÿ //æ±‚ä¸€æ®µåŒºé—´å†…æœ‰å¤šå°‘ä¸ªä¸åŒçš„æ•° int n, m, len; int w[N], ans[M]; struct Query{ int id, l, r; }q[M]; int cnt[S]; int get(int x) //æ±‚å—çš„ç¼–å· { return x / len; } bool cmp(const Query&amp; a, const Query&amp; b) { int i = get(a.l), j = get(b.l); if(i != j) return i &lt; j; return a.r &lt; b.r; } void add(int x, int&amp; res) { if(!cnt[x]) res ++; cnt[x] ++; } void del(int x, int &amp; res) { cnt[x] --; if(!cnt[x]) res --; } int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; w[i]; cin &gt;&gt; m; len = max(1, (int)sqrt((double)n * n / m)); for(int i = 0; i &lt; m; i ++) { int l, r; cin &gt;&gt; l &gt;&gt; r; q[i] = {i, l, r}; } sort(q, q + m, cmp); for(int k = 0, i = 0, j = 1, res = 0; k &lt; m; k ++) //å¤„ç†æ‰€æœ‰è¯¢é—® { int id = q[k].id, l = q[k].l, r = q[k].r; //åŒºé—´çš„ç¼–å·ï¼ŒåŒºé—´å·¦å³ç«¯ç‚¹ while(i &lt; r) add(w[ ++ i], res); //å½“å‰åŒºé—´åŠ ä¸€ä¸ªæ•° while(i &gt; r) del(w[i --], res); while(j &lt; l) del(w[j ++], res); while(j &gt; l) add(w[-- j], res); ans[id] = res; } for(int i = 0; i &lt; m; i ++) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0; } 2.15 ç‚¹åˆ†æ²» //æ±‚æ ‘ä¸Šè¾¹æƒé•¿åº¦ä¸è¶…è¿‡Kçš„è·¯å¾„æœ‰å¤šå°‘æ¡ int n, m; int h[N], e[M], w[M], ne[M], idx; bool st[N]; //è¡¨ç¤ºç‚¹æ˜¯å¦è¢«åˆ æ‰ int p[N], q[N]; void add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx ++; } int get_size(int u, int fa) //æ±‚å­æ ‘å¤§å° { if(st[u]) return 0; int res = 1; for(int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if(j != fa) res += get_size(j, u); } return res; } int get_wc(int u, int fa, int tot, int&amp; wc) //æ±‚æ ‘çš„é‡å¿ƒ { if(st[u]) return 0; int sum = 1, ms = 0; for(int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if(j == fa) continue; int t = get_wc(j, u, tot, wc); ms = max(ms, t); sum += t; } ms = max(ms, tot - sum); if(ms &lt;= tot / 2) wc = u; return sum; } void get_dist(int u, int fa, int dist, int&amp; qt) { if(st[u]) return ; q[qt ++] = dist; for(int i = h[u]; ~i; i = ne[i]) if(e[i] != fa) get_dist(e[i], u, dist + w[i], qt); } int get(int a[], int k) { sort(a, a + k); int res = 0; for(int i = k - 1, j = -1; i &gt;= 0; i --) { while(j + 1 &lt; i &amp;&amp; a[j + 1] + a[i] &lt;= m) j ++; j = min(j, i - 1); res += j + 1; } return res; } int calc(int u) { if(st[u]) return 0; int res = 0; get_wc(u, -1, get_size(u, -1), u); st[u] = true; int pt = 0; for(int i = h[u]; ~i; i = ne[i]) { int j = e[i], qt = 0; get_dist(j, -1, w[i], qt); res -= get(q, qt); for(int k = 0; k &lt; qt; k ++) { if(q[k] &lt;= m) res ++; p[pt ++] = q[k]; } } res += get(p, pt); for(int i = h[u]; ~i; i = ne[i]) { res += calc(e[i]); } return res; } int main() { while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n, m) { memset(st, 0, sizeof st); idx = 0; memset(h, -1, sizeof h); for(int i = 0; i &lt; n - 1; i ++) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); add(b, a, c); } cout &lt;&lt; calc(0) &lt;&lt; endl; } return 0; } 2.16 æ ‘å¥—æ ‘(çº¿æ®µæ ‘å¥—å¹³è¡¡æ ‘) /* æ ‘å¥—æ ‘ç”¨äºç»´æŠ¤ä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°åˆ—ï¼Œæ”¯æŒä»¥ä¸‹æ“ä½œ 1. `1 l r x`ï¼ŒæŸ¥è¯¢æ•´æ•° x åœ¨åŒºé—´ [l,r] å†…çš„æ’åã€‚ 2. `2 l r k`ï¼ŒæŸ¥è¯¢åŒºé—´ [l,r] å†…æ’åä¸º k çš„å€¼ã€‚ 3. `3 pos x`ï¼Œå°† pos ä½ç½®çš„æ•°ä¿®æ”¹ä¸º xã€‚ 4. `4 l r x`ï¼ŒæŸ¥è¯¢æ•´æ•° x åœ¨åŒºé—´ [l,r] å†…çš„å‰é©±(å‰é©±å®šä¹‰ä¸ºå°äº xï¼Œä¸”æœ€å¤§çš„æ•°)ã€‚ 5. `5 l r x`ï¼ŒæŸ¥è¯¢æ•´æ•° x åœ¨åŒºé—´ [l,r] å†…çš„åç»§(åç»§å®šä¹‰ä¸ºå¤§äº xï¼Œä¸”æœ€å°çš„æ•°)ã€‚çš„æ•°)ã€‚ */ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 2000010, INF = 1e9; int n, m; struct Node { int s[2], p, v; int size; void init(int _v, int _p) { v = _v, p = _p; size = 1; } }tr[N]; int L[N], R[N], T[N], idx; int w[N]; void pushup(int x) { tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1; } void rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = tr[y].s[1] == x; tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; pushup(y), pushup(x); } void splay(int&amp; root, int x, int k) { while (tr[x].p != k) { int y = tr[x].p, z = tr[y].p; if (z != k) if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x); else rotate(y); rotate(x); } if (!k) root = x; } void insert(int&amp; root, int v) { int u = root, p = 0; while (u) p = u, u = tr[u].s[v &gt; tr[u].v]; u = ++ idx; if (p) tr[p].s[v &gt; tr[p].v] = u; tr[u].init(v, p); splay(root, u, 0); } int get_k(int root, int v) { int u = root, res = 0; while (u) { if (tr[u].v &lt; v) res += tr[tr[u].s[0]].size + 1, u = tr[u].s[1]; else u = tr[u].s[0]; } return res; } void update(int&amp; root, int x, int y) { int u = root; while (u) { if (tr[u].v == x) break; if (tr[u].v &lt; x) u = tr[u].s[1]; else u = tr[u].s[0]; } splay(root, u, 0); int l = tr[u].s[0], r = tr[u].s[1]; while (tr[l].s[1]) l = tr[l].s[1]; while (tr[r].s[0]) r = tr[r].s[0]; splay(root, l, 0), splay(root, r, l); tr[r].s[0] = 0; pushup(r), pushup(l); insert(root, y); } void build(int u, int l, int r) { L[u] = l, R[u] = r; insert(T[u], -INF), insert(T[u], INF); for (int i = l; i &lt;= r; i ++ ) insert(T[u], w[i]); if (l == r) return; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); } int query(int u, int a, int b, int x) { if (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) return get_k(T[u], x) - 1; int mid = L[u] + R[u] &gt;&gt; 1, res = 0; if (a &lt;= mid) res += query(u &lt;&lt; 1, a, b, x); if (b &gt; mid) res += query(u &lt;&lt; 1 | 1, a, b, x); return res; } void change(int u, int p, int x) { update(T[u], w[p], x); if (L[u] == R[u]) return; int mid = L[u] + R[u] &gt;&gt; 1; if (p &lt;= mid) change(u &lt;&lt; 1, p, x); else change(u &lt;&lt; 1 | 1, p, x); } int get_pre(int root, int v) { int u = root, res = -INF; while (u) { if (tr[u].v &lt; v) res = max(res, tr[u].v), u = tr[u].s[1]; else u = tr[u].s[0]; } return res; } int get_suc(int root, int v) { int u = root, res = INF; while (u) { if (tr[u].v &gt; v) res = min(res, tr[u].v), u = tr[u].s[0]; else u = tr[u].s[1]; } return res; } int query_pre(int u, int a, int b, int x) { if (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) return get_pre(T[u], x); int mid = L[u] + R[u] &gt;&gt; 1, res = -INF; if (a &lt;= mid) res = max(res, query_pre(u &lt;&lt; 1, a, b, x)); if (b &gt; mid) res = max(res, query_pre(u &lt;&lt; 1 | 1, a, b, x)); return res; } int query_suc(int u, int a, int b, int x) { if (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) return get_suc(T[u], x); int mid = L[u] + R[u] &gt;&gt; 1, res = INF; if (a &lt;= mid) res = min(res, query_suc(u &lt;&lt; 1, a, b, x)); if (b &gt; mid) res = min(res, query_suc(u &lt;&lt; 1 | 1, a, b, x)); return res; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); build(1, 1, n); while (m -- ) { int op, a, b, x; scanf(&quot;%d&quot;, &amp;op); if (op == 1) { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x); printf(&quot;%d\\n&quot;, query(1, a, b, x) + 1); } else if (op == 2) { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x); int l = 0, r = 1e8; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (query(1, a, b, mid) + 1 &lt;= x) l = mid; else r = mid - 1; } printf(&quot;%d\\n&quot;, r); } else if (op == 3) { scanf(&quot;%d%d&quot;, &amp;a, &amp;x); change(1, a, x); w[a] = x; } else if (op == 4) { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x); printf(&quot;%d\\n&quot;, query_pre(1, a, b, x)); } else { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x); printf(&quot;%d\\n&quot;, query_suc(1, a, b, x)); } } return 0; } æ ‘å¥—æ ‘åŠ¨æ€ç»´æŠ¤åŒºé—´ç¬¬kå¤§æ•° #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 50010, P = N * 17 * 17, M = N * 4; int n, m; struct Tree { int l, r, sum, add; }tr[P]; int L[M], R[M], T[M], idx; struct Query { int op, a, b, c; }q[N]; vector&lt;int&gt; nums; int get(int x) { return lower_bound(nums.begin(), nums.end(), x) - nums.begin(); } void build(int u, int l, int r) { L[u] = l, R[u] = r, T[u] = ++ idx; if (l == r) return; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); } int intersection(int a, int b, int c, int d) { return min(b, d) - max(a, c) + 1; } void update(int u, int l, int r, int pl, int pr) { tr[u].sum += intersection(l, r, pl, pr); if (l &gt;= pl &amp;&amp; r &lt;= pr) { tr[u].add ++ ; return; } int mid = l + r &gt;&gt; 1; if (pl &lt;= mid) { if (!tr[u].l) tr[u].l = ++ idx; update(tr[u].l, l, mid, pl, pr); } if (pr &gt; mid) { if (!tr[u].r) tr[u].r = ++ idx; update(tr[u].r, mid + 1, r, pl, pr); } } void change(int u, int a, int b, int c) { update(T[u], 1, n, a, b); if (L[u] == R[u]) return; int mid = L[u] + R[u] &gt;&gt; 1; if (c &lt;= mid) change(u &lt;&lt; 1, a, b, c); else change(u &lt;&lt; 1 | 1, a, b, c); } int get_sum(int u, int l, int r, int pl, int pr, int add) { if (l &gt;= pl &amp;&amp; r &lt;= pr) return tr[u].sum + (r - l + 1) * add; int mid = l + r &gt;&gt; 1, res = 0; add += tr[u].add; if (pl &lt;= mid) { if (tr[u].l) res += get_sum(tr[u].l, l, mid, pl, pr, add); else res += intersection(l, mid, pl, pr) * add; } if (pr &gt; mid) { if (tr[u].r) res += get_sum(tr[u].r, mid + 1, r, pl, pr, add); else res += intersection(mid + 1, r, pl, pr) * add; } return res; } int query(int u, int a, int b, int c) { if (L[u] == R[u]) return R[u]; int mid = L[u] + R[u] &gt;&gt; 1; int k = get_sum(T[u &lt;&lt; 1 | 1], 1, n, a, b, 0); if (k &gt;= c) return query(u &lt;&lt; 1 | 1, a, b, c); return query(u &lt;&lt; 1, a, b, c - k); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; i ++ ) { scanf(&quot;%d%d%d%d&quot;, &amp;q[i].op, &amp;q[i].a, &amp;q[i].b, &amp;q[i].c); if (q[i].op == 1) nums.push_back(q[i].c); } sort(nums.begin(), nums.end()); nums.erase(unique(nums.begin(), nums.end()), nums.end()); build(1, 0, nums.size() - 1); for (int i = 0; i &lt; m; i ++ ) { int op = q[i].op, a = q[i].a, b = q[i].b, c = q[i].c; if (op == 1) change(1, a, b, get(c)); else printf(&quot;%d\\n&quot;, nums[query(1, a, b, c)]); } return 0; } 2.17 æ ‘é“¾å‰–åˆ†(æ ‘ä¸Šå·®åˆ†plus) /* ç»´æŠ¤ä¸€æ£µæ ‘ï¼Œæ”¯æŒä»¥ä¸‹æ“ä½œï¼š - `1 u v k`ï¼Œä¿®æ”¹è·¯å¾„ä¸ŠèŠ‚ç‚¹æƒå€¼ï¼Œå°†èŠ‚ç‚¹ u å’ŒèŠ‚ç‚¹ v ä¹‹é—´è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬è¿™ä¸¤ä¸ªèŠ‚ç‚¹ï¼‰çš„æƒå€¼å¢åŠ  kã€‚ - `2 u k`ï¼Œä¿®æ”¹å­æ ‘ä¸ŠèŠ‚ç‚¹æƒå€¼ï¼Œå°†ä»¥èŠ‚ç‚¹ u ä¸ºæ ¹çš„å­æ ‘ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹çš„æƒå€¼å¢åŠ  kã€‚ - `3 u v`ï¼Œè¯¢é—®è·¯å¾„ï¼Œè¯¢é—®èŠ‚ç‚¹ u å’ŒèŠ‚ç‚¹ v ä¹‹é—´è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬è¿™ä¸¤ä¸ªèŠ‚ç‚¹ï¼‰çš„æƒå€¼å’Œã€‚ - `4 u`ï¼Œè¯¢é—®å­æ ‘ï¼Œè¯¢é—®ä»¥èŠ‚ç‚¹ u ä¸ºæ ¹çš„å­æ ‘ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹çš„æƒå€¼å’Œã€‚ */ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 100010, M = N * 2; int n, m; int w[N], h[N], e[M], ne[M], idx; int id[N], nw[N], cnt; int dep[N], sz[N], top[N], fa[N], son[N]; struct Tree { int l, r; LL add, sum; }tr[N * 4]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void dfs1(int u, int father, int depth) { dep[u] = depth, fa[u] = father, sz[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; dfs1(j, u, depth + 1); sz[u] += sz[j]; if (sz[son[u]] &lt; sz[j]) son[u] = j; } } void dfs2(int u, int t) { id[u] = ++ cnt, nw[cnt] = w[u], top[u] = t; if (!son[u]) return; dfs2(son[u], t); for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa[u] || j == son[u]) continue; dfs2(j, j); } } void pushup(int u) { tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum; } void pushdown(int u) { auto &amp;root = tr[u], &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1]; if (root.add) { left.add += root.add, left.sum += root.add * (left.r - left.l + 1); right.add += root.add, right.sum += root.add * (right.r - right.l + 1); root.add = 0; } } void build(int u, int l, int r) { tr[u] = {l, r, 0, nw[r]}; if (l == r) return; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } void update(int u, int l, int r, int k) { if (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) { tr[u].add += k; tr[u].sum += k * (tr[u].r - tr[u].l + 1); return; } pushdown(u); int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (l &lt;= mid) update(u &lt;&lt; 1, l, r, k); if (r &gt; mid) update(u &lt;&lt; 1 | 1, l, r, k); pushup(u); } LL query(int u, int l, int r) { if (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) return tr[u].sum; pushdown(u); int mid = tr[u].l + tr[u].r &gt;&gt; 1; LL res = 0; if (l &lt;= mid) res += query(u &lt;&lt; 1, l, r); if (r &gt; mid) res += query(u &lt;&lt; 1 | 1, l, r); return res; } void update_path(int u, int v, int k) { while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); update(1, id[top[u]], id[u], k); u = fa[top[u]]; } if (dep[u] &lt; dep[v]) swap(u, v); update(1, id[v], id[u], k); } LL query_path(int u, int v) { LL res = 0; while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); res += query(1, id[top[u]], id[u]); u = fa[top[u]]; } if (dep[u] &lt; dep[v]) swap(u, v); res += query(1, id[v], id[u]); return res; } void update_tree(int u, int k) { update(1, id[u], id[u] + sz[u] - 1, k); } LL query_tree(int u) { return query(1, id[u], id[u] + sz[u] - 1); } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); memset(h, -1, sizeof h); for (int i = 0; i &lt; n - 1; i ++ ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b), add(b, a); } dfs1(1, -1, 1); dfs2(1, 1); build(1, 1, n); scanf(&quot;%d&quot;, &amp;m); while (m -- ) { int t, u, v, k; scanf(&quot;%d%d&quot;, &amp;t, &amp;u); if (t == 1) { scanf(&quot;%d%d&quot;, &amp;v, &amp;k); update_path(u, v, k); } else if (t == 2) { scanf(&quot;%d&quot;, &amp;k); update_tree(u, k); } else if (t == 3) { scanf(&quot;%d&quot;, &amp;v); printf(&quot;%lld\\n&quot;, query_path(u, v)); } else printf(&quot;%lld\\n&quot;, query_tree(u)); } return 0; } 2.18 åŠ¨æ€æ ‘ /* ç»´æŠ¤ä¸€æ£µæ ‘ï¼Œæ”¯æŒä»¥ä¸‹æ“ä½œï¼š - `0 x y`ï¼Œè¡¨ç¤ºè¯¢é—®ç‚¹ x åˆ°ç‚¹ y ä¹‹é—´çš„è·¯å¾„ä¸Šçš„æ‰€æœ‰ç‚¹ï¼ˆåŒ…æ‹¬ä¸¤ç«¯ç‚¹ï¼‰çš„æƒå€¼çš„å¼‚æˆ–å’Œã€‚ä¿è¯ x å’Œ y ä¹‹é—´å­˜åœ¨è¿é€šè·¯å¾„ã€‚ - `1 x y`ï¼Œè¡¨ç¤ºåœ¨ç‚¹ x å’Œç‚¹ y ä¹‹é—´å¢åŠ ä¸€æ¡è¾¹ (x,y)ã€‚æ³¨æ„ï¼š**å¦‚æœä¸¤ç‚¹å·²ç»å¤„äºè¿é€šçŠ¶æ€ï¼Œåˆ™æ— è§†è¯¥æ“ä½œ**ã€‚ - `2 x y`ï¼Œè¡¨ç¤ºåˆ é™¤è¾¹ (x,y)ã€‚æ³¨æ„ï¼š**å¦‚æœè¯¥è¾¹ä¸å­˜åœ¨ï¼Œåˆ™æ— è§†è¯¥æ“ä½œ**ã€‚ - `3 x w`ï¼Œè¡¨ç¤ºå°†ç‚¹ x çš„æƒå€¼ä¿®æ”¹ä¸º wã€‚ */ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n, m; struct Node { int s[2], p, v; int sum, rev; }tr[N]; int stk[N]; void pushrev(int x) { swap(tr[x].s[0], tr[x].s[1]); tr[x].rev ^= 1; } void pushup(int x) { tr[x].sum = tr[tr[x].s[0]].sum ^ tr[x].v ^ tr[tr[x].s[1]].sum; } void pushdown(int x) { if (tr[x].rev) { pushrev(tr[x].s[0]), pushrev(tr[x].s[1]); tr[x].rev = 0; } } bool isroot(int x) { return tr[tr[x].p].s[0] != x &amp;&amp; tr[tr[x].p].s[1] != x; } void rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = tr[y].s[1] == x; if (!isroot(y)) tr[z].s[tr[z].s[1] == y] = x; tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; pushup(y), pushup(x); } void splay(int x) { int top = 0, r = x; stk[ ++ top] = r; while (!isroot(r)) stk[ ++ top] = r = tr[r].p; while (top) pushdown(stk[top -- ]); while (!isroot(x)) { int y = tr[x].p, z = tr[y].p; if (!isroot(y)) if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x); else rotate(y); rotate(x); } } void access(int x) // å»ºç«‹ä¸€æ¡ä»æ ¹åˆ°xçš„è·¯å¾„ï¼ŒåŒæ—¶å°†xå˜æˆsplayçš„æ ¹èŠ‚ç‚¹ { int z = x; for (int y = 0; x; y = x, x = tr[x].p) { splay(x); tr[x].s[1] = y, pushup(x); } splay(z); } void makeroot(int x) // å°†xå˜æˆåŸæ ‘çš„æ ¹èŠ‚ç‚¹ { access(x); pushrev(x); } int findroot(int x) // æ‰¾åˆ°xæ‰€åœ¨åŸæ ‘çš„æ ¹èŠ‚ç‚¹, å†å°†åŸæ ‘çš„æ ¹èŠ‚ç‚¹æ—‹è½¬åˆ°splayçš„æ ¹èŠ‚ç‚¹ { access(x); while (tr[x].s[0]) pushdown(x), x = tr[x].s[0]; splay(x); return x; } void split(int x, int y) // ç»™xå’Œyä¹‹é—´çš„è·¯å¾„å»ºç«‹ä¸€ä¸ªsplayï¼Œå…¶æ ¹èŠ‚ç‚¹æ˜¯y { makeroot(x); access(y); } void link(int x, int y) // å¦‚æœxå’Œyä¸è¿é€šï¼Œåˆ™åŠ å…¥ä¸€æ¡xå’Œyä¹‹é—´çš„è¾¹ { makeroot(x); if (findroot(y) != x) tr[x].p = y; } void cut(int x, int y) // å¦‚æœxå’Œyä¹‹é—´å­˜åœ¨è¾¹ï¼Œåˆ™åˆ é™¤è¯¥è¾¹ { makeroot(x); if (findroot(y) == x &amp;&amp; tr[y].p == x &amp;&amp; !tr[y].s[0]) { tr[x].s[1] = tr[y].p = 0; pushup(x); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;tr[i].v); while (m -- ) { int t, x, y; scanf(&quot;%d%d%d&quot;, &amp;t, &amp;x, &amp;y); if (t == 0) { split(x, y); printf(&quot;%d\\n&quot;, tr[y].sum); } else if (t == 1) link(x, y); else if (t == 2) cut(x, y); else { splay(x); tr[x].v = y; pushup(x); } } return 0; } 2.19 Dancing Links(DLX) 2.19.1 ç²¾ç¡®è¦†ç›–é—®é¢˜ ç»™å®šä¸€ä¸ª01çŸ©é˜µAï¼Œæ‰¾åˆ°ä¸€ä¸ªè¡Œçš„é›†åˆï¼Œä½¿å¾—è¿™äº›è¡Œä¸­ï¼Œæ¯ä¸€åˆ—æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªæ•°å­—1 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 5510; int n, m; int l[N], r[N], u[N], d[N], s[N], row[N], col[N], idx; int ans[N], top; void init() { for (int i = 0; i &lt;= m; i ++ ) { l[i] = i - 1, r[i] = i + 1; u[i] = d[i] = i; } l[0] = m, r[m] = 0; idx = m + 1; } void add(int&amp; hh, int&amp; tt, int x, int y) { row[idx] = x, col[idx] = y, s[y] ++ ; u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx; r[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh; tt = idx ++ ; } void remove(int p) { r[l[p]] = r[p], l[r[p]] = l[p]; for (int i = d[p]; i != p; i = d[i]) for (int j = r[i]; j != i; j = r[j]) { s[col[j]] -- ; u[d[j]] = u[j], d[u[j]] = d[j]; } } void resume(int p) { for (int i = u[p]; i != p; i = u[i]) for (int j = l[i]; j != i; j = l[j]) { u[d[j]] = j, d[u[j]] = j; s[col[j]] ++ ; } r[l[p]] = p, l[r[p]] = p; } bool dfs() { if (!r[0]) return true; int p = r[0]; for (int i = r[0]; i; i = r[i]) if (s[i] &lt; s[p]) p = i; remove(p); for (int i = d[p]; i != p; i = d[i]) { ans[ ++ top] = row[i]; for (int j = r[i]; j != i; j = r[j]) remove(col[j]); if (dfs()) return true; for (int j = l[i]; j != i; j = l[j]) resume(col[j]); top -- ; } resume(p); return false; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); init(); for (int i = 1; i &lt;= n; i ++ ) { int hh = idx, tt = idx; for (int j = 1; j &lt;= m; j ++ ) { int x; scanf(&quot;%d&quot;, &amp;x); if (x) add(hh, tt, i, j); } } if (dfs()) { for (int i = 1; i &lt;= top; i ++ ) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;); } else puts(&quot;No Solution!&quot;); return 0; } å¡«å†™16*16çš„æ•°ç‹¬ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 20000; int m = 16 * 16 * 4; int u[N], d[N], l[N], r[N], s[N], col[N], row[N], idx; int ans[N], top; struct Op { int x, y; char z; }op[N]; char g[20][20]; void init() { for (int i = 0; i &lt;= m; i ++ ) { l[i] = i - 1, r[i] = i + 1; s[i] = 0; d[i] = u[i] = i; } l[0] = m, r[m] = 0; idx = m + 1; } void add(int&amp; hh, int&amp; tt, int x, int y) { row[idx] = x, col[idx] = y, s[y] ++ ; u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx; r[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh; tt = idx ++ ; } void remove(int p) { r[l[p]] = r[p], l[r[p]] = l[p]; for (int i = d[p]; i != p; i = d[i]) for (int j = r[i]; j != i; j = r[j]) { s[col[j]] -- ; u[d[j]] = u[j], d[u[j]] = d[j]; } } void resume(int p) { for (int i = u[p]; i != p; i = u[i]) for (int j = l[i]; j != i; j = l[j]) { u[d[j]] = j, d[u[j]] = j; s[col[j]] ++ ; } r[l[p]] = p, l[r[p]] = p; } bool dfs() { if (!r[0]) return true; int p = r[0]; for (int i = r[0]; i; i = r[i]) if (s[i] &lt; s[p]) p = i; remove(p); for (int i = d[p]; i != p; i = d[i]) { ans[ ++ top] = row[i]; for (int j = r[i]; j != i; j = r[j]) remove(col[j]); if (dfs()) return true; for (int j = l[i]; j != i; j = l[j]) resume(col[j]); top -- ; } resume(p); return false; } int main() { while (~scanf(&quot;%s&quot;, g[0])) { for (int i = 1; i &lt; 16; i ++ ) scanf(&quot;%s&quot;, g[i]); init(); for (int i = 0, n = 1; i &lt; 16; i ++ ) for (int j = 0; j &lt; 16; j ++ ) { int a = 0, b = 15; if (g[i][j] != '-') a = b = g[i][j] - 'A'; for (int k = a; k &lt;= b; k ++, n ++ ) { int hh = idx, tt = idx; op[n] = {i, j, k + 'A'}; add(hh, tt, n, i * 16 + j + 1); add(hh, tt, n, 256 + i * 16 + k + 1); add(hh, tt, n, 256 * 2 + j * 16 + k + 1); add(hh, tt, n, 256 * 3 + (i / 4 * 4 + j / 4) * 16 + k + 1); } } dfs(); for (int i = 1; i &lt;= top; i ++ ) { auto t = op[ans[i]]; g[t.x][t.y] = t.z; } for (int i = 0; i &lt; 16; i ++ ) puts(g[i]); puts(&quot;&quot;); } return 0; } 2.19.2 é‡å¤è¦†ç›–é—®é¢˜ ç»™å®šä¸€ä¸ª01çŸ©é˜µAï¼Œæ‰¾åˆ°ä¸€ä¸ªè¡Œçš„é›†åˆï¼Œä½¿å¾—è¿™äº›è¡Œä¸­ï¼Œæ¯ä¸€åˆ—éƒ½åŒ…å«æ•°å­—1ï¼Œä¸”é›†åˆä¸­åŒ…å«çš„è¡Œæ•°å°½å¯èƒ½å°‘ã€‚ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 10010; int n, m; int l[N], r[N], u[N], d[N], col[N], row[N], s[N], idx; int ans[N]; bool st[110]; void init() { for (int i = 0; i &lt;= m; i ++ ) { l[i] = i - 1, r[i] = i + 1; col[i] = u[i] = d[i] = i; s[i] = 0; } l[0] = m, r[m] = 0; idx = m + 1; } void add(int&amp; hh, int&amp; tt, int x, int y) { row[idx] = x, col[idx] = y, s[y] ++ ; u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx; r[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh; tt = idx ++ ; } int h() { int cnt = 0; memset(st, 0, sizeof st); for (int i = r[0]; i; i = r[i]) { if (st[col[i]]) continue; cnt ++ ; st[col[i]] = true; for (int j = d[i]; j != i; j = d[j]) for (int k = r[j]; k != j; k = r[k]) st[col[k]] = true; } return cnt; } void remove(int p) { for (int i = d[p]; i != p; i = d[i]) { r[l[i]] = r[i]; l[r[i]] = l[i]; } } void resume(int p) { for (int i = u[p]; i != p; i = u[i]) { r[l[i]] = i; l[r[i]] = i; } } bool dfs(int k, int depth) { if (k + h() &gt; depth) return false; if (!r[0]) return true; int p = r[0]; for (int i = r[0]; i; i = r[i]) if (s[p] &gt; s[i]) p = i; for (int i = d[p]; i != p; i = d[i]) { ans[k] = row[i]; remove(i); for (int j = r[i]; j != i; j = r[j]) remove(j); if (dfs(k + 1, depth)) return true; for (int j = l[i]; j != i; j = l[j]) resume(j); resume(i); } return false; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); init(); for (int i = 1; i &lt;= n; i ++ ) { int hh = idx, tt = idx; for (int j = 1; j &lt;= m; j ++ ) { int x; scanf(&quot;%d&quot;, &amp;x); if (x) add(hh, tt, i, j); } } int depth = 0; while (!dfs(0, depth)) depth ++ ; printf(&quot;%d\\n&quot;, depth); for (int i = 0; i &lt; depth; i ++ ) printf(&quot;%d &quot;, ans[i]); return 0; } 2.20 å·¦åæ ‘ /* ç»´æŠ¤ä¸€ä¸ªå°æ ¹å †ï¼Œæ”¯æŒä»¥ä¸‹æ“ä½œï¼š 1. `1 a`ï¼Œåœ¨é›†åˆä¸­æ’å…¥ä¸€ä¸ªæ–°å †ï¼Œå †ä¸­åªåŒ…å«ä¸€ä¸ªæ•° aã€‚ 2. `2 x y`ï¼Œå°†ç¬¬ x ä¸ªæ’å…¥çš„æ•°å’Œç¬¬ y ä¸ªæ’å…¥çš„æ•°æ‰€åœ¨çš„å°æ ¹å †åˆå¹¶ã€‚æ•°æ®ä¿è¯ä¸¤ä¸ªæ•°å‡æœªè¢«åˆ é™¤ã€‚è‹¥ä¸¤æ•°å·²åœ¨åŒä¸€å †ä¸­ï¼Œåˆ™å¿½ç•¥æ­¤æ“ä½œã€‚ 3. `3 x`ï¼Œè¾“å‡ºç¬¬ x ä¸ªæ’å…¥çš„æ•°æ‰€åœ¨å°æ ¹å †çš„æœ€å°å€¼ã€‚æ•°æ®ä¿è¯è¯¥æ•°æœªè¢«åˆ é™¤ã€‚ 4. `4 x`ï¼Œåˆ é™¤ç¬¬ x ä¸ªæ’å…¥çš„æ•°æ‰€åœ¨å°æ ¹å †çš„æœ€å°å€¼ï¼ˆè‹¥æœ€å°å€¼ä¸å”¯ä¸€ï¼Œåˆ™ä¼˜å…ˆåˆ é™¤å…ˆæ’å…¥çš„æ•°ï¼‰ã€‚æ•°æ®ä¿è¯è¯¥æ•°æœªè¢«åˆ é™¤ã€‚ */ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 200010; int n; int v[N], dist[N], l[N], r[N], idx; int p[N]; bool cmp(int x, int y) { if (v[x] != v[y]) return v[x] &lt; v[y]; return x &lt; y; } int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int merge(int x, int y) { if (!x || !y) return x + y; if (cmp(y, x)) swap(x, y); r[x] = merge(r[x], y); if (dist[r[x]] &gt; dist[l[x]]) swap(l[x], r[x]); dist[x] = dist[r[x]] + 1; return x; } int main() { scanf(&quot;%d&quot;, &amp;n); v[0] = 2e9; while (n -- ) { int t, x, y; scanf(&quot;%d%d&quot;, &amp;t, &amp;x); if (t == 1) { v[ ++ idx] = x; dist[idx] = 1; p[idx] = idx; } else if (t == 2) { scanf(&quot;%d&quot;, &amp;y); x = find(x), y = find(y); if (x != y) { if (cmp(y, x)) swap(x, y); p[y] = x; merge(x, y); } } else if (t == 3) { printf(&quot;%d\\n&quot;, v[find(x)]); } else { x = find(x); if (cmp(r[x], l[x])) swap(l[x], r[x]); p[x] = l[x], p[l[x]] = l[x]; merge(l[x], r[x]); } } return 0; } ç»™å®šä¸€ä¸ªæ•´æ•°åºåˆ—aï¼Œæ±‚ä¸€ä¸ªé€’å¢åºåˆ—bï¼Œä½¿å¾—aia_{i}aiâ€‹å’Œbib_{i}biâ€‹çš„å„é¡¹ä¹‹å·®çš„ç»å¯¹å€¼ä¹‹å’Œæœ€å° #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 1000010; int n; int v[N], dist[N], l[N], r[N]; struct Segment { int end, root, size; }stk[N]; int ans[N]; int merge(int x, int y) { if (!x || !y) return x + y; if (v[x] &lt; v[y]) swap(x, y); r[x] = merge(r[x], y); if (dist[r[x]] &gt; dist[l[x]]) swap(r[x], l[x]); dist[x] = dist[r[x]] + 1; return x; } int pop(int x) { return merge(l[x], r[x]); } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) { scanf(&quot;%d&quot;, &amp;v[i]); v[i] -= i; } int tt = 0; for (int i = 1; i &lt;= n; i ++ ) { auto cur = Segment({i, i, 1}); dist[i] = 1; while (tt &amp;&amp; v[cur.root] &lt; v[stk[tt].root]) { cur.root = merge(cur.root, stk[tt].root); if (cur.size % 2 &amp;&amp; stk[tt].size % 2) cur.root = pop(cur.root); cur.size += stk[tt].size; tt -- ; } stk[ ++ tt] = cur; } for (int i = 1, j = 1; i &lt;= tt; i ++ ) { while (j &lt;= stk[i].end) ans[j ++ ] = v[stk[i].root]; } LL res = 0; for (int i = 1; i &lt;= n; i ++ ) res += abs(v[i] - ans[i]); printf(&quot;%lld\\n&quot;, res); for (int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, ans[i] + i); return 0; } 2.21 åç¼€æ•°ç»„ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1000010; int n, m; char s[N]; int sa[N], x[N], y[N], c[N], rk[N], height[N]; void get_sa() { for (int i = 1; i &lt;= n; i ++ ) c[x[i] = s[i]] ++ ; for (int i = 2; i &lt;= m; i ++ ) c[i] += c[i - 1]; for (int i = n; i; i -- ) sa[c[x[i]] -- ] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) { int num = 0; for (int i = n - k + 1; i &lt;= n; i ++ ) y[ ++ num] = i; for (int i = 1; i &lt;= n; i ++ ) if (sa[i] &gt; k) y[ ++ num] = sa[i] - k; for (int i = 1; i &lt;= m; i ++ ) c[i] = 0; for (int i = 1; i &lt;= n; i ++ ) c[x[i]] ++ ; for (int i = 2; i &lt;= m; i ++ ) c[i] += c[i - 1]; for (int i = n; i; i -- ) sa[c[x[y[i]]] -- ] = y[i], y[i] = 0; swap(x, y); x[sa[1]] = 1, num = 1; for (int i = 2; i &lt;= n; i ++ ) x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++ num; if (num == n) break; m = num; } } void get_height() { for (int i = 1; i &lt;= n; i ++ ) rk[sa[i]] = i; for (int i = 1, k = 0; i &lt;= n; i ++ ) { if (rk[i] == 1) continue; if (k) k -- ; int j = sa[rk[i] - 1]; while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) k ++ ; height[rk[i]] = k; } } int main() { scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1), m = 122; get_sa(); get_height(); for (int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, sa[i]); puts(&quot;&quot;); for (int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, height[i]); puts(&quot;&quot;); return 0; } 2.22 åç¼€è‡ªåŠ¨æœº ç»™å®šä¸€ä¸ªé•¿åº¦ä¸ºnçš„å°å†™å­—æ¯å­—ç¬¦ä¸²Sï¼Œå¯¹äºæ‰€æœ‰Sçš„å‡ºç°æ¬¡æ•°ä¸ä¸º1çš„å­ä¸²ï¼Œè®¾valueçš„å€¼ä¸ºå­ä¸²å‡ºç°çš„æ¬¡æ•°Ã—å­ä¸²çš„é•¿åº¦ï¼Œæ±‚valueçš„æœ€å¤§å€¼ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 2000010; int tot = 1, last = 1; struct Node { int len, fa; int ch[26]; }node[N]; char str[N]; LL f[N], ans; int h[N], e[N], ne[N], idx; void extend(int c) { int p = last, np = last = ++ tot; f[tot] = 1; node[np].len = node[p].len + 1; for (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np; if (!p) node[np].fa = 1; else { int q = node[p].ch[c]; if (node[q].len == node[p].len + 1) node[np].fa = q; else { int nq = ++ tot; node[nq] = node[q], node[nq].len = node[p].len + 1; node[q].fa = node[np].fa = nq; for (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq; } } } void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void dfs(int u) { for (int i = h[u]; ~i; i = ne[i]) { dfs(e[i]); f[u] += f[e[i]]; } if (f[u] &gt; 1) ans = max(ans, f[u] * node[u].len); } int main() { scanf(&quot;%s&quot;, str); for (int i = 0; str[i]; i ++ ) extend(str[i] - 'a'); memset(h, -1, sizeof h); for (int i = 2; i &lt;= tot; i ++ ) add(node[i].fa, i); dfs(1); printf(&quot;%lld\\n&quot;, ans); return 0; } åç¼€è‡ªåŠ¨æœºæ±‚æœ€é•¿å…¬å…±å­ä¸² #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 20010; int n; int tot = 1, last = 1; char str[N]; struct Node { int len, fa; int ch[26]; }node[N]; int ans[N], now[N]; int h[N], e[N], ne[N], idx; void extend(int c) { int p = last, np = last = ++ tot; node[np].len = node[p].len + 1; for (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np; if (!p) node[np].fa = 1; else { int q = node[p].ch[c]; if (node[q].len == node[p].len + 1) node[np].fa = q; else { int nq = ++ tot; node[nq] = node[q], node[nq].len = node[p].len + 1; node[q].fa = node[np].fa = nq; for (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq; } } } void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void dfs(int u) { for (int i = h[u]; ~i; i = ne[i]) { dfs(e[i]); now[u] = max(now[u], now[e[i]]); } } int main() { scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, str); for (int i = 0; str[i]; i ++ ) extend(str[i] - 'a'); for (int i = 1; i &lt;= tot; i ++ ) ans[i] = node[i].len; memset(h, -1, sizeof h); for (int i = 2; i &lt;= tot; i ++ ) add(node[i].fa, i); for (int i = 0; i &lt; n - 1; i ++ ) { scanf(&quot;%s&quot;, str); memset(now, 0, sizeof now); int p = 1, t = 0; for (int j = 0; str[j]; j ++ ) { int c = str[j] - 'a'; while (p &gt; 1 &amp;&amp; !node[p].ch[c]) p = node[p].fa, t = node[p].len; if (node[p].ch[c]) p = node[p].ch[c], t ++ ; now[p] = max(now[p], t); } dfs(1); for (int j = 1; j &lt;= tot; j ++ ) ans[j] = min(ans[j], now[j]); } int res = 0; for (int i = 1; i &lt;= tot; i ++ ) res = max(res, ans[i]); printf(&quot;%d\\n&quot;, res); return 0; } 2.23 ç‚¹åˆ†æ ‘ //å¾…è¡¥å…… 2.24 CDQåˆ†æ²» //å¾…è¡¥å…… CDQåˆ†æ²»æ±‚åŠ¨æ€é€†åºå¯¹ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 100010; int n, m; struct Data { int a, t, res; }q[N], w[N]; int tr[N], pos[N]; LL ans[N]; int lowbit(int x) { return x &amp; -x; } void add(int x, int v) { for (int i = x; i &lt; N; i += lowbit(i)) tr[i] += v; } int query(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } void merge_sort(int l, int r) { if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(l, mid), merge_sort(mid + 1, r); int i = mid, j = r; while (i &gt;= l &amp;&amp; j &gt; mid) if (q[i].a &gt; q[j].a) add(q[i].t, 1), i -- ; else q[j].res += query(q[j].t - 1), j -- ; while (j &gt; mid) q[j].res += query(q[j].t - 1), j -- ; for (int k = i + 1; k &lt;= mid; k ++ ) add(q[k].t, -1); j = l, i = mid + 1; while (j &lt;= mid &amp;&amp; i &lt;= r) if (q[i].a &lt; q[j].a) add(q[i].t, 1), i ++ ; else q[j].res += query(q[j].t - 1), j ++ ; while (j &lt;= mid) q[j].res += query(q[j].t - 1), j ++ ; for (int k = mid + 1; k &lt; i; k ++ ) add(q[k].t, -1); i = l, j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i].a &lt;= q[j].a) w[k ++ ] = q[i ++ ]; else w[k ++ ] = q[j ++ ]; while (i &lt;= mid) w[k ++ ] = q[i ++ ]; while (j &lt;= r) w[k ++ ] = q[j ++ ]; for (i = l, j = 0; j &lt; k; i ++, j ++ ) q[i] = w[j]; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) { scanf(&quot;%d&quot;, &amp;q[i].a); pos[q[i].a] = i; } for (int i = 0, j = n; i &lt; m; i ++ ) { int a; scanf(&quot;%d&quot;, &amp;a); q[pos[a]].t = j -- ; pos[a] = -1; } for (int i = 1, j = n - m; i &lt;= n; i ++ ) if (pos[i] != -1) q[pos[i]].t = j -- ; merge_sort(0, n - 1); for (int i = 0; i &lt; n; i ++ ) ans[q[i].t] = q[i].res; for (int i = 2; i &lt;= n; i ++ ) ans[i] += ans[i - 1]; for (int i = 0, j = n; i &lt; m; i ++, j -- ) printf(&quot;%lld\\n&quot;, ans[j]); return 0; } 2.25 ç¬›å¡å°”æ ‘ //æ±‚åŒºé—´æœ€å€¼ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e6 + 10; int a[N]; int l[N], r[N]; int n; int ans[N], tot; void dfs(int u) { ans[u] = ++ tot; if(l[u]) dfs(l[u]); if(r[u]) dfs(r[u]); } void build() { stack&lt;int&gt; st; int root = 0; for(int i = 1; i &lt;= n; i ++) { int last = 0; while(!st.empty() &amp;&amp; a[st.top()] &gt; a[i]) { last = st.top(); st.pop(); } if(!st.empty()) r[st.top()] = i; else root = i; l[i] = last; st.push(i); } dfs(root); } int main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; build(); for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } 3. æ•°å­¦ 3.1 åˆ†è§£è´¨å› æ•° #include&lt;iostream&gt; using namespace std; void device(int a) { for(int i = 2; i &lt;= a / i; i ++) { if(a % i == 0) //å¦‚æœè¯¥è¯­å¥æˆç«‹ï¼Œé‚£ä¹ˆiä¸€å®šæ˜¯è´¨æ•° int s = 0; while(a % i == 0) { a /= i; s ++; } printf(&quot;%d %d\\n&quot;, i, s); } } if(a &gt; 1) cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt;endl; cout &lt;&lt; endl; } int main() { int n; cin &gt;&gt; n; while (n -- ) { int a; cin &gt;&gt; a; device(a); } return 0; } 3.2 ç­›è´¨æ•° #include&lt;iostream&gt; using namespace std; const int N = 1e6 + 10; int prime[N],cnt; int st[N]; void getprime(int n) { for(int i = 2; i &lt;= n; i ++) { if(!st[i]) prime[cnt ++] = i; //å¦‚æœiæ˜¯ä¸€ä¸ªè´¨æ•°ï¼Œé‚£ä¹ˆå°±æŠŠiåŠ å…¥åˆ°è´¨æ•°è¡¨é‡Œ for(int j = 0; prime[j] &lt;= n / i; j ++) //æšä¸¾è´¨æ•°è¡¨ä¸­å°äºn/içš„è´¨å› å­ { st[prime[j] * i] = true; //å°†æ‰€æœ‰æœ€å°è´¨å› å­ä¸ºprime[j]çš„åˆæ•°ç­›æ‰ if(i % prime[j] == 0) break; //å¦‚æœi%prime[j]æˆç«‹ï¼Œé‚£ä¹ˆprime[j]æ˜¯içš„æœ€å°è´¨å› å­ï¼Œå¹¶ä¸”ä¹Ÿæ˜¯prime[j] * içš„æœ€å°è´¨å› å­ //å¦‚æœä¸æˆç«‹ï¼Œé‚£ä¹ˆprime[j]ä¹Ÿæ˜¯prime[j] * içš„æœ€å°è´¨å› å­ } } } int main() { int n; cin &gt;&gt; n; getprime(n); cout &lt;&lt; cnt ; return 0; } 3.3 è¯•é™¤æ³•æ±‚çº¦æ•° #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; void ddd(int a) { vector&lt;int&gt; res; for(int i = 1; i &lt;= a / i; i ++) { if(a % i == 0) { res.push_back(i); if(i != a / i) res.push_back(a / i); } } sort(res.begin(), res.end()); for(auto t : res) cout &lt;&lt; t &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } int main() { int n; cin &gt;&gt; n; while(n --) { int a; cin &gt;&gt; a; ddd(a); } return 0; } 3.4 æ±‚nä¸ªæ•°ä¹˜ç§¯çš„çº¦æ•°ä¸ªæ•° #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;unordered_map&gt; typedef long long LL; using namespace std; const int mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while(n --) { int x; cin &gt;&gt; x; for(int i = 2; i &lt;= x / i; i ++) { while(x % i == 0) { x /= i; primes[i] ++; } } if(x &gt; 1) primes[x] ++; } LL res = 1; for(auto prime : primes) res = res * (prime.second + 1) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0; } 3.5 æ±‚nä¸ªæ•°ä¹˜ç§¯çš„çº¦æ•°ä¹‹å’Œ #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;unordered_map&gt; typedef long long LL; using namespace std; const int mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while(n --) { int x; cin &gt;&gt; x; for(int i = 2; i &lt;= x / i; i ++) { while(x % i == 0) { x /= i; primes[i] ++; } } if(x &gt; 1) primes[x] ++; } LL res = 1; for(auto prime : primes) { int p = prime.first, a = prime.second; LL t = 1; while(a --) t = (t * p + 1) % mod; res = res * t % mod; } cout &lt;&lt; res &lt;&lt; endl; return 0; } 3.6 çº¿æ€§ç­›æ±‚æ¬§æ‹‰å‡½æ•° #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 1e6 + 10; int primes[N], cnt; int phi[N]; bool st[N]; LL get_eulers(int n) { phi[1] = 1; for(int i = 2; i &lt;= n; i ++) { if(!st[i]) { primes[cnt ++] = i; phi[i] = i - 1; } for(int j = 0; primes[j] * i &lt;= n; j ++) { st[primes[j] * i] = true; if(i % primes[j] == 0) { phi[primes[j] * i] = primes[j] * phi[i]; break; } phi[primes[j] * i] = phi[i] * (primes[j] - 1); } } LL res = 0; for(int i = 1; i &lt;= n; i ++) res += phi[i]; return res; } int main() { int n; cin &gt;&gt; n; cout &lt;&lt; get_eulers(n) &lt;&lt; endl; return 0; } 3.7 å¿«é€Ÿå¹‚ int qmi(int a, int b, int p) { int res = 1 % p; for(; b; b &gt;&gt;= 1) { if(b &amp; 1) res = (long long)res * a % p; a = (long long)a * a % p; } return res; } 3.8 æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•(EXGCD) ç»™å®š n å¯¹æ­£æ•´æ•° aia_iaiâ€‹,bib_ibiâ€‹ï¼Œå¯¹äºæ¯å¯¹æ•°ï¼Œæ±‚å‡ºä¸€ç»„ xixixi , yiy_iyiâ€‹ï¼Œä½¿å…¶æ»¡è¶³ aia_iaiâ€‹Ã—xix_ixiâ€‹+bib_ibiâ€‹Ã—yiy_iyiâ€‹=gcd(aia_iaiâ€‹,bib_ibiâ€‹)ã€‚ #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int exgcd(int a, int b, int &amp;x, int &amp;y) { if(!b) { x = 1, y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } int main() { int n; cin &gt;&gt; n; while(n --) { int a, b, x, y; cin &gt;&gt; a &gt;&gt; b; exgcd(a, b, x, y); cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; } return 0; } æ±‚è§£çº¿æ€§åŒä½™æ–¹ç¨‹ç»„ #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; typedef long long LL; using namespace std; int exgcd(int a, int b, int &amp;x, int &amp;y) { if(!b) { x = 1, y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } int main() { int n; cin &gt;&gt; n; while(n --) { int a, b, m; cin &gt;&gt; a &gt;&gt; b &gt;&gt; m; int x, y; int d = exgcd(a, m, x ,y); if(b % d) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; else cout &lt;&lt; (LL)x * (b / d) % m &lt;&lt; endl; } return 0; } 3.9 é«˜æ–¯æ¶ˆå…ƒæ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„ #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 110; const double eps = 1e-6; int n; double a[N][N]; int gauss() { int c, r; for(c = 0, r = 0; c &lt; n; c ++) { int t = r; for(int i = r; i &lt; n; i ++) if(fabs(a[i][c] &gt; fabs(a[t][c]))) t = i; if(fabs(a[t][c]) &lt; eps) continue; for(int i = c; i &lt;= n; i ++) swap(a[t][i], a[r][i]); for(int i = n; i &gt;= c; i --) a[r][i] /= a[r][c]; for(int i = r + 1; i &lt; n; i ++) if(fabs(a[i][c]) &gt; eps) for(int j = n; j &gt;= c; j --) a[i][j] -= a[r][j] * a[i][c]; r ++; } if(r &lt; n) { for(int i = r; i &lt; n; i ++) if(fabs(a[i][n]) &gt; eps) return 2; return 1; } for(int i = n - 1; i &gt;= 0; i --) for(int j = i + 1; j &lt; n; j ++) a[i][n] -= a[i][j] * a[j][n]; return 0; } int main() { cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) for(int j = 0; j &lt; n + 1; j ++) cin &gt;&gt; a[i][j]; int t = gauss(); if(t == 0) { for(int i = 0; i &lt; n; i ++) { if (fabs(a[i][n]) &lt; eps) a[i][n] = 0; printf(&quot;%.2lf\\n&quot;, a[i][n]); } } else if(t == 1) cout &lt;&lt; &quot;Infinite group solutions&quot; &lt;&lt; endl; else puts(&quot;No solution&quot;); return 0; } 3.10 ç»„åˆæ•°å¤§å…¨ 3.10.1 æ±‚C(a, b)ï¼Œå…¶ä¸­1 â‰¤ b â‰¤ a â‰¤ 2000 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 2010, mod = 1e9 + 7; int c[N][N]; void init() { for(int i = 0; i &lt; N; i ++) for(int j = 0; j &lt;= i; j ++) if(!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; } int main() { init(); int n; cin &gt;&gt; n; while(n --) { int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; c[a][b] &lt;&lt; endl; } return 0; } 3.10.2 æ±‚C(a, b)ï¼Œå…¶ä¸­1 â‰¤ b â‰¤ a â‰¤ 100000 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 100010, mod = 1e9 + 7; int fact[N], infact[N]; int qmi(int a, int k, int p) { int res = 1; for(; k; k &gt;&gt;= 1) { if(k &amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; } return res; } int main() { fact[0] = infact[0] = 1; for(int i = 1; i &lt; N; i ++) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; } int n; cin &gt;&gt; n; while(n --) { int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (LL)fact[a] * infact[b] % mod * infact[a - b] % mod &lt;&lt; endl; } } 3.10.3 æ±‚C(a, b) mod pï¼Œå…¶ä¸­ 1â‰¤bâ‰¤aâ‰¤10181 â‰¤ b â‰¤ a â‰¤ 10^{18}1â‰¤bâ‰¤aâ‰¤1018ï¼Œä¸”pä¸ºè´¨æ•° #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long LL; int p; int qmi(int a, int k) { int res = 1; for(; k; k &gt;&gt;= 1) { if(k &amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; } return res; } int C(LL a, LL b) { int res = 1; for(int i = 1, j = a; i &lt;= b; i ++, j --) { res = (LL)res * j % p; res = (LL)res * qmi(i ,p - 2) % p; } return res; } LL lucas(LL a, LL b) { if(a &lt; p &amp; b &lt; p) return C(a, b); return C(a % p, b % p) * lucas(a / p, b / p) % p; } int main() { int n; cin &gt;&gt; n; while(n --) { LL a, b; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; cout &lt;&lt; lucas(a, b) &lt;&lt; endl; } return 0; } 3.10.4 æ±‚C(a, b)ï¼Œå…¶ä¸­1 â‰¤ b â‰¤ a â‰¤ 5000 (é«˜ç²¾åº¦ä¸å–æ¨¡) #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; const int N = 5010; int primes[N], cnt; bool st[N]; int sum[N]; void init(int n) { for(int i = 2; i &lt;= n; i ++) { if(!st[i]) primes[cnt ++] = i; for(int j = 0; primes[j] * i &lt;= n; j ++) { st[primes[j] * i] = true; if(i % primes[j] == 0) break; } } } int get(int n, int p) //*nçš„é˜¶ä¹˜é‡ŒåŒ…å«çš„pçš„ä¸ªæ•° { int res = 0; while(n) { res += n / p; n /= p; } return res; } vector&lt;int&gt; mul(vector&lt;int&gt; a, int b) { vector&lt;int&gt; c; int t = 0; for(int i = 0; i &lt; a.size(); i ++) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while(t) { c.push_back(t % 10); t /= 10; } return c; } int main() { int a, b; cin &gt;&gt; a &gt;&gt; b; init(a); for(int i = 0; i &lt; cnt; i ++) { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector&lt;int&gt; res; res.push_back(1); for(int i = 0; i &lt; cnt; i ++) for(int j = 0; j &lt; sum[i]; j ++) res = mul(res, primes[i]); for(int i = res.size() - 1; i &gt;= 0; i --) cout &lt;&lt; res[i] ; cout &lt;&lt; endl; return 0; } 3.10.5 å¡ç‰¹å…°æ•° ç»™å®š01åºåˆ—ï¼Œæ±‚ä»»æ„å‰ç¼€åºåˆ—ä¸­0çš„ä¸ªæ•°ä¸å°‘äº1çš„ä¸ªæ•°çš„åºåˆ—æœ‰å¤šå°‘ä¸ª #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; typedef long long LL; using namespace std; const int mod = 1e9 + 7; int qmi(int a, int k, int p) { int res = 1; for(; k; k &gt;&gt;= 1) { if(k &amp; 1) res = (LL)res * a % p; a= (LL)a * a % p; } return res; } int main() { int n; cin &gt;&gt; n; int a = 2 * n, b = n; int res = 1; for(int i = a; i &gt; a - b; i --) res = (LL)res * i % mod; for(int i = 1; i &lt;= b; i ++) res = (LL)res * qmi(i, mod - 2, mod) % mod; res = (LL)res * qmi(n + 1, mod - 2, mod) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0; } 3.11 å®¹æ–¥åŸç† ç»™å®šnå’Œmä¸ªä¸åŒçš„è´¨æ•°pï¼Œæ±‚1-nä¸­èƒ½è¢«pä¸­è‡³å°‘ä¸€ä¸ªæ•°æ•´é™¤çš„æ•´æ•°æœ‰å¤šå°‘ä¸ª #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 20; typedef long long LL; int n, m; int p[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i ++) cin &gt;&gt; p[i]; int res = 0; for(int i = 1; i &lt; 1 &lt;&lt; m; i ++) { int t = 1, cnt = 0; for(int j = 0; j &lt; m; j ++) if(i &gt;&gt; j &amp; 1) { cnt ++; if((LL)t * p[j] &gt; n) { t = -1; break; } t *= p[j]; } if(t != -1) { if(cnt % 2) res += n / t; else res -= n / t; } } cout &lt;&lt; res &lt;&lt; endl; return 0; } nä¸ªç›’å­æ”¾aia_iaiâ€‹æèŠ±ï¼ŒåŒä¸€ä¸ªç›’å­å†…çš„èŠ±çš„é¢œè‰²ç›¸åŒï¼Œä¸åŒç›’å­å†…çš„ç”»çš„é¢œè‰²ä¸åŒï¼Œé€‰å‡ºMæèŠ±å…±æœ‰å¤šå°‘ç§æ–¹æ¡ˆ #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 20, mod = 1e9 + 7; int A[N]; int down = 1; int qmi(int a, int b, int k) { int res = 1; for(; b; b &gt;&gt;= 1) { if(b &amp; 1) res = (long long)res * a % k; a = (long long)a * a % k; } return res; } int C(int a, int b) { if(a &lt; b) return 0; int up = 1; for(int i = a; i &gt; a - b; i --) up = i % mod * up % mod; return (up * down) % mod; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, m; int res = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++) cin &gt;&gt; A[i]; for(int j = 1; j &lt;= n - 1; j ++) down = j * down % mod; down = qmi(down, mod - 2, mod); for(int i = 0; i &lt; 1 &lt;&lt; n; i ++) { int a = m + n - 1, b = n - 1; int p = 1; for(int j = 0; j &lt; n; j ++) if(i &gt;&gt; j &amp; 1) { p *= -1; a -= A[j] + 1; } res = (res + C(a, b) * p) % mod; } cout &lt;&lt; (res + mod) % mod &lt;&lt; endl; return 0; } 3.12 åšå¼ˆè®º 3.12.1 NIMåšå¼ˆ ç»™å®š n å †çŸ³å­ï¼Œä¸¤ä½ç©å®¶è½®æµæ“ä½œï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥ä»ä»»æ„ä¸€å †çŸ³å­ä¸­æ‹¿èµ°ä»»æ„æ•°é‡çš„çŸ³å­ï¼ˆå¯ä»¥æ‹¿å®Œï¼Œä½†ä¸èƒ½ä¸æ‹¿ï¼‰ï¼Œæœ€åæ— æ³•è¿›è¡Œæ“ä½œçš„äººè§†ä¸ºå¤±è´¥ã€‚ é—®å¦‚æœä¸¤äººéƒ½é‡‡ç”¨æœ€ä¼˜ç­–ç•¥ï¼Œå…ˆæ‰‹æ˜¯å¦å¿…èƒœã€‚ #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n; int res = 0; cin &gt;&gt; n; while(n --) { int x; cin &gt;&gt; x; res ^= x; } if(res) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; } 3.12.2 å°é˜¶-NIMæ¸¸æˆ æœ‰ä¸€ä¸ª n çº§å°é˜¶çš„æ¥¼æ¢¯ï¼Œæ¯çº§å°é˜¶ä¸Šéƒ½æœ‰è‹¥å¹²ä¸ªçŸ³å­ï¼Œå…¶ä¸­ç¬¬ i çº§å°é˜¶ä¸Šæœ‰ ai ä¸ªçŸ³å­(iâ‰¥1)ã€‚ ä¸¤ä½ç©å®¶è½®æµæ“ä½œï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥ä»ä»»æ„ä¸€çº§å°é˜¶ä¸Šæ‹¿è‹¥å¹²ä¸ªçŸ³å­æ”¾åˆ°ä¸‹ä¸€çº§å°é˜¶ä¸­ï¼ˆä¸èƒ½ä¸æ‹¿ï¼‰ã€‚ å·²ç»æ‹¿åˆ°åœ°é¢ä¸Šçš„çŸ³å­ä¸èƒ½å†æ‹¿ï¼Œæœ€åæ— æ³•è¿›è¡Œæ“ä½œçš„äººè§†ä¸ºå¤±è´¥ã€‚ é—®å¦‚æœä¸¤äººéƒ½é‡‡ç”¨æœ€ä¼˜ç­–ç•¥ï¼Œå…ˆæ‰‹æ˜¯å¦å¿…èƒœã€‚ #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int main() { int n; scanf(&quot;%d&quot;, &amp;n); int res = 0; for (int i = 1; i &lt;= n; i ++ ) { int x; scanf(&quot;%d&quot;, &amp;x); if (i &amp; 1) res ^= x; } if (res) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0; } 3.12.3 é›†åˆ-NIMæ¸¸æˆ ç»™å®š n å †çŸ³å­ä»¥åŠä¸€ä¸ªç”± k ä¸ªä¸åŒæ­£æ•´æ•°æ„æˆçš„æ•°å­—é›†åˆ Sã€‚ ç°åœ¨æœ‰ä¸¤ä½ç©å®¶è½®æµæ“ä½œï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥ä»ä»»æ„ä¸€å †çŸ³å­ä¸­æ‹¿å–çŸ³å­ï¼Œæ¯æ¬¡æ‹¿å–çš„çŸ³å­æ•°é‡å¿…é¡»åŒ…å«äºé›†åˆ Sï¼Œæœ€åæ— æ³•è¿›è¡Œæ“ä½œçš„äººè§†ä¸ºå¤±è´¥ã€‚ é—®å¦‚æœä¸¤äººéƒ½é‡‡ç”¨æœ€ä¼˜ç­–ç•¥ï¼Œå…ˆæ‰‹æ˜¯å¦å¿…èƒœã€‚ #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;unordered_set&gt; using namespace std; const int N = 110, M = 10010; int n, m; int s[N], f[M]; int sg(int x) { if(f[x] != -1) return f[x]; unordered_set&lt;int&gt; S; for(int i = 0; i &lt; m; i ++) { int sum = s[i]; if(x &gt;= sum) S.insert(sg(x - sum)); } for(int i = 0; ; i ++) { if(!S.count(i)) return f[x] = i; } } int main() { cin &gt;&gt; m; for(int i = 0; i &lt; m; i ++) cin &gt;&gt; s[i]; cin &gt;&gt; n; memset(f, -1, sizeof f); int res = 0; for(int i = 0; i &lt; n; i ++) { int x; cin &gt;&gt; x; res ^= sg(x); } if(res) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0; } 3.12.4 æ‹†åˆ†-NIMæ¸¸æˆ ç»™å®š n å †çŸ³å­ï¼Œä¸¤ä½ç©å®¶è½®æµæ“ä½œï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥å–èµ°å…¶ä¸­çš„ä¸€å †çŸ³å­ï¼Œç„¶åæ”¾å…¥ä¸¤å †è§„æ¨¡æ›´å°çš„çŸ³å­ï¼ˆæ–°å †è§„æ¨¡å¯ä»¥ä¸º 0ï¼Œä¸”ä¸¤ä¸ªæ–°å †çš„çŸ³å­æ€»æ•°å¯ä»¥å¤§äºå–èµ°çš„é‚£å †çŸ³å­æ•°ï¼‰ï¼Œæœ€åæ— æ³•è¿›è¡Œæ“ä½œçš„äººè§†ä¸ºå¤±è´¥ã€‚ é—®å¦‚æœä¸¤äººéƒ½é‡‡ç”¨æœ€ä¼˜ç­–ç•¥ï¼Œå…ˆæ‰‹æ˜¯å¦å¿…èƒœã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;unordered_set&gt; using namespace std; const int N = 110; int n; int f[N]; int sg(int x) { if (f[x] != -1) return f[x]; unordered_set&lt;int&gt; S; for (int i = 0; i &lt; x; i ++ ) for (int j = 0; j &lt;= i; j ++ ) S.insert(sg(i) ^ sg(j)); for (int i = 0;; i ++ ) if (!S.count(i)) return f[x] = i; } int main() { cin &gt;&gt; n; memset(f, -1, sizeof f); int res = 0; while (n -- ) { int x; cin &gt;&gt; x; res ^= sg(x); } if (res) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0; } 3.13 çŸ©é˜µä¹˜æ³• æ±‚æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å‰né¡¹å’Œ #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 3; typedef long long LL; int n, m; void mul(int c[], int a[], int b[][N]) { int temp[N] = {0}; for(int i = 0; i &lt; N; i ++) for(int j = 0; j &lt; N; j ++) temp[i] = (temp[i] + (LL)a[j] * b[j][i]) % m; memcpy(c, temp, sizeof temp); } void mul(int c[][N], int a[][N], int b[][N]) { int temp[N][N] = {0}; for(int i = 0; i &lt; N; i ++) for(int j = 0; j &lt; N; j ++) for(int k = 0; k &lt; N; k ++) temp[i][j] = (temp[i][j] + (LL)a[i][k] * b[k][j]) % m; memcpy(c, temp, sizeof temp); } int main() { cin &gt;&gt; n &gt;&gt; m; int f1[N] = {1, 1, 1}; int a[N][N] = { {0, 1, 0}, {1, 1, 1}, {0, 0, 1} }; n --; for(; n; n &gt;&gt;= 1) { if(n &amp; 1) mul(f1, f1, a); mul(a, a, a); } cout &lt;&lt; f1[2] &lt;&lt; endl; return 0; } ç”¨ T(n)=(F1+2F2+3F3+â€¦+nFn)modm è¡¨ç¤º Fibonacci æ•°åˆ—å‰ n é¡¹å˜å½¢åçš„å’Œ mod m çš„å€¼ï¼Œæ±‚å‡º T(n) çš„å€¼ã€‚ #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 4; int n, m; void mul(int c[][N], int a[][N], int b[][N]) //*c = a * b { static int t[N][N]; memset(t, 0, sizeof t); for(int i = 0; i &lt; N; i ++) for(int j = 0; j &lt; N; j ++) for(int k = 0; k &lt; N; k ++) t[i][j] = (t[i][j] + (LL)a[i][k] * b[k][j]) % m; memcpy(c, t, sizeof t); } int main() { cin &gt;&gt; n &gt;&gt; m; int f1[N][N] = {1, 1, 1, 0}; int a[N][N] = { {0, 1, 0, 0}, {1, 1, 1, 0}, {0, 0, 1, 1}, {0, 0, 0, 1}, }; int k = n - 1; for(; k; k &gt;&gt;= 1) { if(k &amp; 1) mul(f1, f1, a); mul(a, a, a); } cout &lt;&lt; (((LL)n * f1[0][2] - f1[0][3]) % m + m) % m &lt;&lt; endl; return 0; } 3.14 è«æ¯”ä¹Œæ–¯å‡½æ•°ä¸è«æ¯”ä¹Œæ–¯åæ¼”ä¸ç§¯æ€§å‡½æ•° //å¾…è¡¥å…… 4. åŠ¨æ€è§„åˆ’ æ•°å­—ä¸‰è§’å½¢æ¨¡å‹ 4.1 ä¸€æ¡è·¯å¾„ç‚¹æƒå’Œæœ€å¤§(æ‘˜èŠ±ç”Ÿ) #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110; int n, m; int w[N][N]; int f[N][N]; int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T -- ) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) scanf(&quot;%d&quot;, &amp;w[i][j]); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j]; printf(&quot;%d\\n&quot;, f[n][m]); } return 0; } 4.2 ä¸€æ¡è·¯å¾„ç‚¹æƒå’Œæœ€å° #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110, INF = 1e9; int n; int w[N][N]; int f[N][N]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) scanf(&quot;%d&quot;, &amp;w[i][j]); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (i == 1 &amp;&amp; j == 1) f[i][j] = w[i][j]; // ç‰¹åˆ¤å·¦ä¸Šè§’ else { f[i][j] = INF; if (i &gt; 1) f[i][j] = min(f[i][j], f[i - 1][j] + w[i][j]);// åªæœ‰ä¸åœ¨ç¬¬ä¸€è¡Œçš„æ—¶å€™ï¼Œæ‰å¯ä»¥ä»ä¸Šé¢è¿‡æ¥ if (j &gt; 1) f[i][j] = min(f[i][j], f[i][j - 1] + w[i][j]);// åªæœ‰ä¸åœ¨ç¬¬ä¸€åˆ—çš„æ—¶å€™ï¼Œæ‰å¯ä»¥ä»å·¦è¾¹è¿‡æ¥ } printf(&quot;%d\\n&quot;, f[n][n]); return 0; } 4.3 ä¸¤æ¡è·¯å¾„ç‚¹æƒå’Œæœ€å¤§ è¯¥ç±»é—®é¢˜æ»¡è¶³ï¼šå·¦ä¸Šèµ°åˆ°å³ä¸‹èµ°ä¸¤æ¬¡ï¼Œæ ¼ç‚¹æ•°è¢«å–è¿‡ç¬¬äºŒæ¬¡å°±ä¸ä¼šå†å–(åæ ‡å’Œç›¸åŠ ç›¸ç­‰å³è¢«èµ°äº†ä¸¤æ¬¡) // ä¸¤æ¡è·¯å¾„éƒ½æ˜¯ï¼šå·¦ä¸Šåˆ°å³ä¸‹ #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 15; int n; int w[N][N]; int f[N * 2][N][N]; int main() { scanf(&quot;%d&quot;, &amp;n); int a, b, c; while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c) w[a][b] = c; for (int k = 2; k &lt;= n + n; k ++ ) for (int i1 = 1; i1 &lt;= n; i1 ++ ) for (int i2 = 1; i2 &lt;= n; i2 ++ ) { int j1 = k - i1, j2 = k - i2; if (j1 &gt;= 1 &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= 1 &amp;&amp; j2 &lt;= n) { int t = w[i1][j1]; if (i1 != i2) t += w[i2][j2]; int &amp;x = f[k][i1][i2]; x = max(x, f[k - 1][i1 - 1][i2 - 1] + t); x = max(x, f[k - 1][i1 - 1][i2] + t); x = max(x, f[k - 1][i1][i2 - 1] + t); x = max(x, f[k - 1][i1][i2] + t); } } printf(&quot;%d\\n&quot;, f[n + n][n][n]); return 0; } // å…ˆå·¦ä¸Šåˆ°å³ä¸‹ï¼Œå†å³ä¸‹åˆ°å·¦ä¸Š #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10; int n, m; int g[55][55], f[110][55][55]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= n;i ++) for(int j = 1;j &lt;= m;j ++) cin &gt;&gt; g[i][j]; for(int k = 2; k &lt;= n + m;k ++) { for(int i1 = max(1, k - m);i1 &lt;= min(k - 1, n);i1 ++) { for(int i2 = max(1, k - m);i2 &lt;= min(k - 1, n);i2 ++) { int j1 = k - i1, j2 = k - i2; int t = g[i1][j1]; if(i1 != i2) t += g[i2][j2]; int &amp;x = f[k][i1][i2]; x = max(x, f[k - 1][i1 - 1][i2 - 1] + t); x = max(x, f[k - 1][i1 - 1][i2] + t); x = max(x, f[k - 1][i1][i2 - 1] + t); x = max(x, f[k - 1][i1][i2] + t); } } } cout &lt;&lt; f[n + m][n][n] &lt;&lt; endl; return 0; } æœ€é•¿ä¸Šå‡å­åºåˆ—æ¨¡å‹ï¼ˆLISï¼‰ 4.4 åŸºæœ¬è½¬æ¢æ¨¡å‹ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const int N = 1e5 + 10; int n, q[N], a[N]; int ask(int s,int t) { q[0] = -2e9; int len = 0; for(int i = s;i &lt; t;i ++) { int l = 0, r = len; while(l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if(q[mid] &lt; a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); q[r + 1] = a[i]; } return len; } int main() { int n; cin &gt;&gt; n; for(int i = 0;i &lt; n;i ++) cin &gt;&gt; a[i]; cout &lt;&lt; ask(0, n) &lt;&lt; endl; // å·¦é—­å³å¼€ return 0; } 4.5ä¸Šä¸‹æ¨¡å‹ å…ˆä¸Šå‡å†ä¸‹é™ï¼Œä¸€æ—¦ä¸‹é™å°±ä¸å†ä¸Šå‡ï¼Œä¸­é—´é«˜ä¸¤è¾¹çŸ®çš„æœ€é•¿å­åºåˆ— #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e3 + 10; int f[N][2], n, a[N]; int main () { cin &gt;&gt; n; for(int i = 0;i &lt; n;i ++ ) cin &gt;&gt; a[i]; for(int i = 0;i &lt; n;i ++) { f[i][1] = f[i][0] = 1; for(int k = 0;k &lt; i;k ++) { if(a[i] &gt; a[k]) f[i][0] = max(f[i][0], f[k][0] + 1); if(a[i] &lt; a[k]) f[i][1] = max(f[i][1], max(f[k][0], f[k][1]) + 1); } } int res = 0; for(int i = 0;i &lt; n;i ++) res = max(res, max(f[i][1], f[i][0])); cout &lt;&lt; res &lt;&lt; endl; return 0; } 4.6 æœ€å¤§ä¸Šå‡å­åºåˆ—å’Œ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1010; int a[N], n, f[N]; int main () { cin &gt;&gt; n; for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i]; for(int i = 1;i &lt;= n;i ++) { f[i] = a[i]; for(int k = 1;k &lt; i;k ++) { if(a[k] &lt; a[i]) f[i] = max(f[i], f[k] + a[i]); } } int res = 0; for(int i = 1;i &lt;= n;i ++) res = max(res, f[i]); cout &lt;&lt; res &lt;&lt; endl; return 0; } 4.7 Dilworthå®šç†ï¼ˆæœ€å°‘ä¸‹é™å­åºåˆ—æ•°ç­‰äºæœ€é•¿ä¸Šå‡å­åºåˆ—é•¿åº¦ï¼‰ æœ€é•¿å…¬å…±å­åºåˆ— 4.8 æœ€é•¿å…¬å…±ä¸Šå‡å­åºåˆ—ï¼ˆLICSå’ŒLCSï¼‰ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 3010; int n, f[N][N], a[N], b[N]; int main () { cin &gt;&gt; n; for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i]; for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; b[i]; for(int i = 1;i &lt;= n;i ++) { int res = 0; if(b[1] &lt; a[i]) res = f[i - 1][1]; for(int j = 1;j &lt;= n;j ++) { if(a[i] == b[j]) f[i][j] = res + 1; else f[i][j] = f[i - 1][j]; if(b[j] &lt; a[i]) res = max(res, f[i - 1][j]); } } int ans = 0; for(int i = 1;i &lt;= n;i ++) ans = max(ans, f[n][i]); cout &lt;&lt; ans &lt;&lt; endl; return 0; } 4.9 æœ€é•¿å…¬å…±å­åºåˆ— #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); scanf(&quot;%s%s&quot;, a + 1, b + 1); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } printf(&quot;%d\\n&quot;, f[n][m]); return 0; } 4.10 æœ€çŸ­ç¼–è¾‘è·ç¦» Aåˆ°Bæœ€å°‘æ“ä½œæ¬¡æ•° æ“ä½œï¼š åˆ é™¤â€“å°†å­—ç¬¦ä¸² A ä¸­çš„æŸä¸ªå­—ç¬¦åˆ é™¤ã€‚ æ’å…¥â€“åœ¨å­—ç¬¦ä¸² A çš„æŸä¸ªä½ç½®æ’å…¥æŸä¸ªå­—ç¬¦ã€‚ æ›¿æ¢â€“å°†å­—ç¬¦ä¸² A ä¸­çš„æŸä¸ªå­—ç¬¦æ›¿æ¢ä¸ºå¦ä¸€ä¸ªå­—ç¬¦ã€‚ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n,m; char a[1010],b[1010]; int f[1010][1010]; int main() { scanf(&quot;%d%s&quot;,&amp;n, a + 1); scanf(&quot;%d%s&quot;,&amp;m, b + 1); for(int i = 0;i &lt;= m;i ++) f[0][i] = i; for(int i = 0;i &lt;= n;i ++) f[i][0] = i; for(int i = 1;i &lt;= n;i ++) { for(int j = 1;j &lt;= m;j ++) { f[i][j] = min(f[i][j - 1], f[i - 1][j]) + 1; if(a[i] != b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); else f[i][j] = min(f[i][j], f[i - 1][j - 1]); } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; } èƒŒåŒ… 4.11 01èƒŒåŒ…é—®é¢˜ #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int M = 20010; int n, m; int f[M]; int main() { cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) { int v; cin &gt;&gt; v; for (int j = m; j &gt;= v; j -- ) f[j] = max(f[j], f[j - v] + v); } cout &lt;&lt; m - f[m] &lt;&lt; endl; return 0; } 01èƒŒåŒ…æ±‚æ–¹æ¡ˆæ•° //æ•°å­—ç»„åˆæ–¹æ¡ˆï¼Œéæœ€ä¼˜æœ€å¤§ä»·å€¼æ–¹æ¡ˆæ•° #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 10010; int n, m; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; f[0] = 1; for (int i = 0; i &lt; n; i ++ ) { int v; cin &gt;&gt; v; for (int j = m; j &gt;= v; j -- ) f[j] += f[j - v]; } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 4.12 å®Œå…¨èƒŒåŒ…é—®é¢˜ #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i ++ ) for (int j = v[i]; j &lt;= m; j ++ ) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } å®Œå…¨èƒŒåŒ…æ±‚æ–¹æ¡ˆæ•° //æ•°å­—ç»„åˆæ–¹æ¡ˆï¼Œéæœ€ä¼˜æœ€å¤§ä»·å€¼æ–¹æ¡ˆæ•° #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; typedef long long LL; const LL mod=2147483648LL;//é»˜è®¤æ•°å­—ä¸ºintç±»å‹ï¼Œå› æ­¤æ•°å­—åè¦åŠ LL int n; long long f[4005]; int main() { scanf(&quot;%d&quot;,&amp;n); f[0]=1; for(int i = 1;i &lt; n;i ++) for(int j = i;j &lt;= n;j ++) f[j] = (f[j] + f[j - i]) % mod; printf(&quot;%d&quot;,f[n]); } 4.13 å¤šé‡èƒŒåŒ…é—®é¢˜ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 1e5+10; int n, m; struct node { int v, w; }; vector&lt;node&gt; nodes; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= n;i ++) { int v, w ,s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for(int k = 1;k &lt;= s;k &lt;&lt;= 1) nodes.push_back({v*k, w*k}), s -= k; if(s) nodes.push_back({v*s, w*s}); } for(auto t : nodes) { for(int j = m;j &gt;= t.v;j -- ) { f[j] = max(f[j], f[j - t.v] + t.w); } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } å•è°ƒé˜Ÿåˆ—ä¼˜åŒ– #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n, m; int f[N], g[N], q[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) { int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; memcpy(g, f, sizeof f); for (int j = 0; j &lt; v; j ++ ) { int hh = 0, tt = -1; for (int k = j; k &lt;= m; k += v) { if (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh ++ ; while (hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt -- ; q[ ++ tt] = k; f[k] = g[q[hh]] + (k - q[hh]) / v * w; } } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 4.14 æ··åˆèƒŒåŒ…é—®é¢˜ #include &lt;iostream&gt; using namespace std; const int N = 1010; int n, m; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) { int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; if (!s) { for (int j = v; j &lt;= m; j ++ ) f[j] = max(f[j], f[j - v] + w); } else { if (s == -1) s = 1; for (int k = 1; k &lt;= s; k *= 2) { for (int j = m; j &gt;= k * v; j -- ) f[j] = max(f[j], f[j - k * v] + k * w); s -= k; } if (s) { for (int j = m; j &gt;= s * v; j -- ) f[j] = max(f[j], f[j - s * v] + s * w); } } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 4.15 äºŒç»´è´¹ç”¨çš„èƒŒåŒ…é—®é¢˜ #include &lt;iostream&gt; using namespace std; const int N = 110; int n, V, M; int f[N][N]; int main() { cin &gt;&gt; n &gt;&gt; V &gt;&gt; M; for (int i = 0; i &lt; n; i ++ ) { int v, m, w; cin &gt;&gt; v &gt;&gt; m &gt;&gt; w; for (int j = V; j &gt;= v; j -- ) for (int k = M; k &gt;= m; k -- ) f[j][k] = max(f[j][k], f[j - v][k - m] + w); } cout &lt;&lt; f[V][M] &lt;&lt; endl; return 0; } 4.16 åˆ†ç»„èƒŒåŒ…é—®é¢˜ #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110; int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) { cin &gt;&gt; s[i]; for (int j = 0; j &lt; s[i]; j ++ ) cin &gt;&gt; v[i][j] &gt;&gt; w[i][j]; } for (int i = 1; i &lt;= n; i ++ ) for (int j = m; j &gt;= 0; j -- ) for (int k = 0; k &lt; s[i]; k ++ ) if (v[i][k] &lt;= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 4.17 æœ‰ä¾èµ–çš„èƒŒåŒ…é—®é¢˜ ç‰©å“ä¹‹é—´å…·æœ‰ä¾èµ–å…³ç³»ï¼Œä¸”ä¾èµ–å…³ç³»ç»„æˆä¸€æ£µæ ‘çš„å½¢çŠ¶ã€‚å¦‚æœé€‰æ‹©ä¸€ä¸ªç‰©å“ï¼Œåˆ™å¿…é¡»é€‰æ‹©å®ƒçš„çˆ¶èŠ‚ç‚¹ã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110; int n, m; int v[N], w[N]; int h[N], e[N], ne[N], idx; int f[N][N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void dfs(int u) { for (int i = h[u]; ~i; i = ne[i]) // å¾ªç¯ç‰©å“ç»„ { int son = e[i]; dfs(e[i]); // åˆ†ç»„èƒŒåŒ… for (int j = m - v[u]; j &gt;= 0; j -- ) // å¾ªç¯ä½“ç§¯ for (int k = 0; k &lt;= j; k ++ ) // å¾ªç¯å†³ç­– f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]); } // å°†ç‰©å“uåŠ è¿›å» for (int i = m; i &gt;= v[u]; i -- ) f[u][i] = f[u][i - v[u]] + w[u]; for (int i = 0; i &lt; v[u]; i ++ ) f[u][i] = 0; } int main() { cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); int root; for (int i = 1; i &lt;= n; i ++ ) { int p; cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p; if (p == -1) root = i; else add(p, i); } dfs(root); cout &lt;&lt; f[root][m] &lt;&lt; endl; return 0; } /* 5 7 2 3 -1 2 2 1 3 5 1 4 7 2 3 6 2 11 */ 4.18 æœ€ä¼˜æœ€å¤§ä»·å€¼æ–¹æ¡ˆæ•° #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; const int N = 1010, mod = 1e9 + 7; int n, m; int f[N], g[N]; int main() { cin &gt;&gt; n &gt;&gt; m; memset(f, -0x3f, sizeof f); f[0] = 0; g[0] = 1; for (int i = 0; i &lt; n; i ++ ) { int v, w; cin &gt;&gt; v &gt;&gt; w; for (int j = m; j &gt;= v; j -- ) { int maxv = max(f[j], f[j - v] + w); int s = 0; if (f[j] == maxv) s = g[j]; if (f[j - v] + w == maxv) s = (s + g[j - v]) % mod; f[j] = maxv, g[j] = s; } } int res = 0; for (int i = 1; i &lt;= m; i ++ ) if (f[i] &gt; f[res]) res = i; int sum = 0; for (int i = 0; i &lt;= m; i ++ ) if (f[i] == f[res]) sum = (sum + g[i]) % mod; cout &lt;&lt; sum &lt;&lt; endl; return 0; } 4.19 èƒŒåŒ…é—®é¢˜æ±‚å…·ä½“æ–¹æ¡ˆ #include &lt;iostream&gt; using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N][N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = n; i &gt;= 1; i -- ) for (int j = 0; j &lt;= m; j ++ ) { f[i][j] = f[i + 1][j]; if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]); } int j = m; for (int i = 1; i &lt;= n; i ++ ) if (j &gt;= v[i] &amp;&amp; f[i][j] == f[i + 1][j - v[i]] + w[i]) { cout &lt;&lt; i &lt;&lt; ' '; j -= v[i]; } return 0; } çŠ¶æ€æœºæ¨¡å‹ å¤§ç›—é˜¿ç¦ é˜¿ç¦äº‹å…ˆè°ƒæŸ¥å¾—çŸ¥ï¼Œåªæœ‰å½“ä»–åŒæ—¶æ´—åŠ«äº†ä¸¤å®¶ç›¸é‚»çš„åº—é“ºæ—¶ï¼Œè¡—ä¸Šçš„æŠ¥è­¦ç³»ç»Ÿæ‰ä¼šå¯åŠ¨ï¼Œç„¶åè­¦å¯Ÿå°±ä¼šèœ‚æ‹¥è€Œè‡³ã€‚ä»–æƒ³çŸ¥é“ï¼Œåœ¨ä¸æƒŠåŠ¨è­¦å¯Ÿçš„æƒ…å†µä¸‹ï¼Œä»–ä»Šæ™šæœ€å¤šå¯ä»¥å¾—åˆ°å¤šå°‘ç°é‡‘ï¼Ÿ #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n; int w[N], f[N][2]; int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T -- ) { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); for (int i = 1; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][0] + w[i]; } printf(&quot;%d\\n&quot;, max(f[n][0], f[n][1])); } return 0; } /* 2 3 1 8 2 4 10 7 6 14 8 24 */ è‚¡ç¥¨ä¹°å– IV ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º N çš„æ•°ç»„ï¼Œæ•°ç»„ä¸­çš„ç¬¬ i ä¸ªæ•°å­—è¡¨ç¤ºä¸€ä¸ªç»™å®šè‚¡ç¥¨åœ¨ç¬¬ iå¤©çš„ä»·æ ¼ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ï¼Œä½ æœ€å¤šå¯ä»¥å®Œæˆ kç¬”äº¤æ˜“ã€‚ æ³¨æ„ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚ä¸€æ¬¡ä¹°å…¥å–å‡ºåˆä¸ºä¸€ç¬”äº¤æ˜“ã€‚ // è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæœ€å¤§åˆ©æ¶¦ã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010, M = 110, INF = 0x3f3f3f3f; int n, m; int w[N]; int f[N][M][2]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); memset(f, -0x3f, sizeof f); for (int i = 0; i &lt;= n; i ++ ) f[i][0][0] = 0; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + w[i]); f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - w[i]); } int res = 0; for (int i = 0; i &lt;= m; i ++ ) res = max(res, f[n][i][0]); printf(&quot;%d\\n&quot;, res); return 0; } è‚¡ç¥¨ä¹°å– V ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º N çš„æ•°ç»„ï¼Œæ•°ç»„ä¸­çš„ç¬¬ i ä¸ªæ•°å­—è¡¨ç¤ºä¸€ä¸ªç»™å®šè‚¡ç¥¨åœ¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ è®¾è®¡ä¸€ä¸ªç®—æ³•è®¡ç®—å‡ºæœ€å¤§åˆ©æ¶¦ã€‚åœ¨æ»¡è¶³ä»¥ä¸‹çº¦æŸæ¡ä»¶ä¸‹ï¼Œä½ å¯ä»¥å°½å¯èƒ½åœ°å®Œæˆæ›´å¤šçš„äº¤æ˜“ï¼ˆå¤šæ¬¡ä¹°å–ä¸€æ”¯è‚¡ç¥¨ï¼‰: ä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚ å–å‡ºè‚¡ç¥¨åï¼Œä½ æ— æ³•åœ¨ç¬¬äºŒå¤©ä¹°å…¥è‚¡ç¥¨ (å³å†·å†»æœŸä¸º 1 å¤©)ã€‚ // ç®—å‡ºæœ€å¤§åˆ©æ¶¦ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010, INF = 0x3f3f3f3f; int n; int w[N]; int f[N][3]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); f[0][0] = f[0][1] = -INF, f[0][2] = 0; for (int i = 1; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][2] - w[i]); f[i][1] = f[i - 1][0] + w[i]; f[i][2] = max(f[i - 1][2], f[i - 1][1]); } printf(&quot;%d\\n&quot;, max(f[n][1], f[n][2])); return 0; } è®¾è®¡å¯†ç  ä½ ç°åœ¨éœ€è¦è®¾è®¡ä¸€ä¸ªå¯†ç  Sï¼ŒSéœ€è¦æ»¡è¶³ï¼š S çš„é•¿åº¦æ˜¯ Nï¼› S åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ï¼› S ä¸åŒ…å«å­ä¸² Tï¼› ä¾‹å¦‚ï¼šabc å’Œ abcde æ˜¯ abcde çš„å­ä¸²ï¼Œabd ä¸æ˜¯ abcdeçš„å­ä¸²ã€‚ è¯·é—®å…±æœ‰å¤šå°‘ç§ä¸åŒçš„å¯†ç æ»¡è¶³è¦æ±‚ï¼Ÿ ç”±äºç­”æ¡ˆä¼šéå¸¸å¤§ï¼Œè¯·è¾“å‡ºç­”æ¡ˆæ¨¡ 109+7çš„ä½™æ•°ã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 55, mod = 1e9 + 7; int n, m; char str[N]; int nxt[N]; int f[N][N]; int main() { cin &gt;&gt; n &gt;&gt; str + 1; m = strlen(str + 1); for (int i = 2, j = 0; i &lt;= m; i ++ ) { while (j &amp;&amp; str[i] != str[j + 1]) j = nxt[j]; if (str[i] == str[j + 1]) j ++ ; nxt[i] = j; } f[0][0] = 1; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) for (char k = 'a'; k &lt;= 'z'; k ++ ) { int u = j; while (u &amp;&amp; k != str[u + 1]) u = nxt[u]; if (k == str[u + 1]) u ++ ; if (u &lt; m) f[i + 1][u] = (f[i + 1][u] + f[i][j]) % mod; } int res = 0; for (int i = 0; i &lt; m; i ++ ) res = (res + f[n][i]) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0; } ä¿®å¤DNA ç”Ÿç‰©å­¦å®¶ç»ˆäºå‘æ˜äº†ä¿®å¤DNAçš„æŠ€æœ¯ï¼Œèƒ½å¤Ÿå°†åŒ…å«å„ç§é—ä¼ ç–¾ç—…çš„DNAç‰‡æ®µè¿›è¡Œä¿®å¤ã€‚ä¸ºäº†ç®€å•èµ·è§ï¼ŒDNAçœ‹ä½œæ˜¯ä¸€ä¸ªç”±â€™Aâ€™, â€˜Gâ€™ , â€˜Câ€™ , â€˜Tâ€™æ„æˆçš„å­—ç¬¦ä¸²ã€‚ä¿®å¤æŠ€æœ¯å°±æ˜¯é€šè¿‡æ”¹å˜å­—ç¬¦ä¸²ä¸­çš„ä¸€äº›å­—ç¬¦ï¼Œä»è€Œæ¶ˆé™¤å­—ç¬¦ä¸²ä¸­åŒ…å«çš„è‡´ç—…ç‰‡æ®µã€‚éœ€æ³¨æ„ï¼Œè¢«ä¿®å¤çš„DNAç‰‡æ®µä¸­ï¼Œä»ç„¶åªèƒ½åŒ…å«å­—ç¬¦â€™Aâ€™, â€˜Gâ€™ , â€˜Câ€™ , â€˜Tâ€™ã€‚ è¯·ä½ å¸®åŠ©ç”Ÿç‰©å­¦å®¶ä¿®å¤ç»™å®šçš„DNAç‰‡æ®µï¼Œå¹¶ä¸”ä¿®å¤è¿‡ç¨‹ä¸­æ”¹å˜çš„å­—ç¬¦æ•°é‡è¦å°½å¯èƒ½çš„å°‘ã€‚ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1010; int n, m; int tr[N][4], dar[N], idx; int q[N], ne[N]; char str[N]; int f[N][N]; int get(char c) { if (c == 'A') return 0; if (c == 'T') return 1; if (c == 'G') return 2; return 3; } void insert() { int p = 0; for (int i = 0; str[i]; i ++ ) { int t = get(str[i]); if (tr[p][t] == 0) tr[p][t] = ++ idx; p = tr[p][t]; } dar[p] = 1; } void build() { int hh = 0, tt = -1; for (int i = 0; i &lt; 4; i ++ ) if (tr[0][i]) q[ ++ tt] = tr[0][i]; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = 0; i &lt; 4; i ++ ) { int p = tr[t][i]; if (!p) tr[t][i] = tr[ne[t]][i]; else { ne[p] = tr[ne[t]][i]; q[ ++ tt] = p; dar[p] |= dar[ne[p]]; } } } } int main() { int T = 1; while (scanf(&quot;%d&quot;, &amp;n), n) { memset(tr, 0, sizeof tr); memset(dar, 0, sizeof dar); memset(ne, 0, sizeof ne); idx = 0; for (int i = 0; i &lt; n; i ++ ) { scanf(&quot;%s&quot;, str); insert(); } build(); scanf(&quot;%s&quot;, str + 1); m = strlen(str + 1); memset(f, 0x3f, sizeof f); f[0][0] = 0; for (int i = 0; i &lt; m; i ++ ) for (int j = 0; j &lt;= idx; j ++ ) for (int k = 0; k &lt; 4; k ++ ) { int t = get(str[i + 1]) != k; int p = tr[j][k]; if (!dar[p]) f[i + 1][p] = min(f[i + 1][p], f[i][j] + t); } int res = 0x3f3f3f3f; for (int i = 0; i &lt;= idx; i ++ ) res = min(res, f[m][i]); if (res == 0x3f3f3f3f) res = -1; printf(&quot;Case %d: %d\\n&quot;, T ++, res); } return 0; } /* 2 AAA AAG AAAG 2 A TG TGAATG 4 A G C T AGT 0 Case 1: 1 Case 2: 4 Case 3: -1 */ çŠ¶æ€å‹ç¼©DP å°å›½ç‹ // åœ¨ nÃ—n çš„æ£‹ç›˜ä¸Šæ”¾ k ä¸ªå›½ç‹ï¼Œå›½ç‹å¯æ”»å‡»ç›¸é‚»çš„ 8 ä¸ªæ ¼å­ï¼Œæ±‚ä½¿å®ƒä»¬æ— æ³•äº’ç›¸æ”»å‡»çš„æ–¹æ¡ˆæ€»æ•°ã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long LL; const int N = 12, M = 1 &lt;&lt; 10, K = 110; int n, m; vector&lt;int&gt; state; int cnt[M]; vector&lt;int&gt; head[M]; LL f[N][K][M]; bool check(int state) { for (int i = 0; i &lt; n; i ++ ) if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; i + 1 &amp; 1)) return false; return true; } int count(int state) { int res = 0; for (int i = 0; i &lt; n; i ++ ) res += state &gt;&gt; i &amp; 1; return res; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ) if (check(i)) { state.push_back(i); cnt[i] = count(i); } for (int i = 0; i &lt; state.size(); i ++ ) for (int j = 0; j &lt; state.size(); j ++ ) { int a = state[i], b = state[j]; if ((a &amp; b) == 0 &amp;&amp; check(a | b)) head[i].push_back(j); } f[0][0][0] = 1; for (int i = 1; i &lt;= n + 1; i ++ ) for (int j = 0; j &lt;= m; j ++ ) for (int a = 0; a &lt; state.size(); a ++ ) for (int b : head[a]) { int c = cnt[state[a]]; if (j &gt;= c) f[i][j][a] += f[i - 1][j - c][b]; } cout &lt;&lt; f[n + 1][m][0] &lt;&lt; endl; return 0; } /* 3 2 16 */ ç‰ç±³ç”° å†œå¤«çº¦ç¿°çš„åœŸåœ°ç”± MÃ—N ä¸ªå°æ–¹æ ¼ç»„æˆï¼Œç°åœ¨ä»–è¦åœ¨åœŸåœ°é‡Œç§æ¤ç‰ç±³ã€‚éå¸¸é—æ†¾ï¼Œéƒ¨åˆ†åœŸåœ°æ˜¯ä¸è‚²çš„ï¼Œæ— æ³•ç§æ¤ã€‚ è€Œä¸”ï¼Œç›¸é‚»çš„åœŸåœ°ä¸èƒ½åŒæ—¶ç§æ¤ç‰ç±³ï¼Œä¹Ÿå°±æ˜¯è¯´ç§æ¤ç‰ç±³çš„æ‰€æœ‰æ–¹æ ¼ä¹‹é—´éƒ½ä¸ä¼šæœ‰å…¬å…±è¾¹ç¼˜ã€‚ ç°åœ¨ç»™å®šåœŸåœ°çš„å¤§å°ï¼Œè¯·ä½ æ±‚å‡ºå…±æœ‰å¤šå°‘ç§ç§æ¤æ–¹æ³•ã€‚åœŸåœ°ä¸Šä»€ä¹ˆéƒ½ä¸ç§ä¹Ÿç®—ä¸€ç§æ–¹æ³•ã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 14, M = 1 &lt;&lt; 12, mod = 1e8; int n, m; int w[N]; vector&lt;int&gt; state; vector&lt;int&gt; head[M]; int f[N][M]; bool check(int state) { for (int i = 0; i + 1 &lt; m; i ++ ) if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; i + 1 &amp; 1)) return false; return true; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) for (int j = 0; j &lt; m; j ++ ) { int t; cin &gt;&gt; t; w[i] += !t * (1 &lt;&lt; j); } for (int i = 0; i &lt; 1 &lt;&lt; m; i ++ ) if (check(i)) state.push_back(i); for (int i = 0; i &lt; state.size(); i ++ ) for (int j = 0; j &lt; state.size(); j ++ ) { int a = state[i], b = state[j]; if (!(a &amp; b)) head[i].push_back(j); } f[0][0] = 1; for (int i = 1; i &lt;= n + 1; i ++ ) for (int j = 0; j &lt; state.size(); j ++ ) if (!(state[j] &amp; w[i])) for (int k : head[j]) f[i][j] = (f[i][j] + f[i - 1][k]) % mod; cout &lt;&lt; f[n + 1][0] &lt;&lt; endl; return 0; } /* 2 3 1 1 1 0 1 0 9 */ åŒºé—´DP ç¯å½¢çŸ³å­åˆå¹¶ æ±‚ï¼š é€‰æ‹©ä¸€ç§åˆå¹¶çŸ³å­çš„æ–¹æ¡ˆï¼Œä½¿å¾—åš nâˆ’1 æ¬¡åˆå¹¶å¾—åˆ†æ€»å’Œæœ€å¤§ã€‚ é€‰æ‹©ä¸€ç§åˆå¹¶çŸ³å­çš„æ–¹æ¡ˆï¼Œä½¿å¾—åš nâˆ’1 æ¬¡åˆå¹¶å¾—åˆ†æ€»å’Œæœ€å°ã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 410, INF = 0x3f3f3f3f; int n; int w[N], s[N]; int f[N][N], g[N][N]; int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) { cin &gt;&gt; w[i]; w[i + n] = w[i]; } for (int i = 1; i &lt;= n * 2; i ++ ) s[i] = s[i - 1] + w[i]; memset(f, 0x3f, sizeof f); memset(g, -0x3f, sizeof g); for (int len = 1; len &lt;= n; len ++ ) for (int l = 1; l + len - 1 &lt;= n * 2; l ++ ) { int r = l + len - 1; if (l == r) f[l][r] = g[l][r] = 0; else { for (int k = l; k &lt; r; k ++ ) { f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); g[l][r] = max(g[l][r], g[l][k] + g[k + 1][r] + s[r] - s[l - 1]); } } } int minv = INF, maxv = -INF; for (int i = 1; i &lt;= n; i ++ ) { minv = min(minv, f[i][i + n - 1]); maxv = max(maxv, g[i][i + n - 1]); } cout &lt;&lt; minv &lt;&lt; endl &lt;&lt; maxv &lt;&lt; endl; return 0; } åŠ åˆ†äºŒå‰æ ‘ è®¾ä¸€ä¸ª n ä¸ªèŠ‚ç‚¹çš„äºŒå‰æ ‘ tree çš„ä¸­åºéå†ä¸ºï¼ˆ1,2,3,â€¦,nï¼‰ï¼Œå…¶ä¸­æ•°å­— 1,2,3,â€¦,n ä¸ºèŠ‚ç‚¹ç¼–å·ã€‚ æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªåˆ†æ•°ï¼ˆå‡ä¸ºæ­£æ•´æ•°ï¼‰ï¼Œè®°ç¬¬ i ä¸ªèŠ‚ç‚¹çš„åˆ†æ•°ä¸º diï¼Œtree åŠå®ƒçš„æ¯ä¸ªå­æ ‘éƒ½æœ‰ä¸€ä¸ªåŠ åˆ†ï¼Œä»»ä¸€æ£µå­æ ‘ subtreeï¼ˆä¹ŸåŒ…å« tree æœ¬èº«ï¼‰çš„åŠ åˆ†è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼š subtreeçš„å·¦å­æ ‘çš„åŠ åˆ† Ã— subtreeçš„å³å­æ ‘çš„åŠ åˆ† ï¼‹ subtreeçš„æ ¹çš„åˆ†æ•° è‹¥æŸä¸ªå­æ ‘ä¸ºç©ºï¼Œè§„å®šå…¶åŠ åˆ†ä¸º 1ã€‚ å¶å­çš„åŠ åˆ†å°±æ˜¯å¶èŠ‚ç‚¹æœ¬èº«çš„åˆ†æ•°ï¼Œä¸è€ƒè™‘å®ƒçš„ç©ºå­æ ‘ã€‚ è¯•æ±‚ä¸€æ£µç¬¦åˆä¸­åºéå†ä¸ºï¼ˆ1,2,3,â€¦,nï¼‰ä¸”åŠ åˆ†æœ€é«˜çš„äºŒå‰æ ‘ treeã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 30; int n; int w[N]; int f[N][N], g[N][N]; void dfs(int l, int r) { if (l &gt; r) return; int k = g[l][r]; cout &lt;&lt; k &lt;&lt; ' '; dfs(l, k - 1); dfs(k + 1, r); } int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; w[i]; for (int len = 1; len &lt;= n; len ++ ) for (int l = 1; l + len - 1 &lt;= n; l ++ ) { int r = l + len - 1; if (len == 1) f[l][r] = w[l], g[l][r] = l; else { for (int k = l; k &lt;= r; k ++ ) { int left = k == l ? 1 : f[l][k - 1]; int right = k == r ? 1 : f[k + 1][r]; int score = left * right + w[k]; if (f[l][r] &lt; score) { f[l][r] = score; g[l][r] = k; } } } } cout &lt;&lt; f[1][n] &lt;&lt; endl; dfs(1, n); return 0; } å‡¸å¤šè¾¹å½¢çš„åˆ’åˆ† ç»™å®šä¸€ä¸ªå…·æœ‰ N ä¸ªé¡¶ç‚¹çš„å‡¸å¤šè¾¹å½¢ï¼Œå°†é¡¶ç‚¹ä» 1 è‡³ N æ ‡å·ï¼Œæ¯ä¸ªé¡¶ç‚¹çš„æƒå€¼éƒ½æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ã€‚ å°†è¿™ä¸ªå‡¸å¤šè¾¹å½¢åˆ’åˆ†æˆ Nâˆ’2 ä¸ªäº’ä¸ç›¸äº¤çš„ä¸‰è§’å½¢ï¼Œå¯¹äºæ¯ä¸ªä¸‰è§’å½¢ï¼Œå…¶ä¸‰ä¸ªé¡¶ç‚¹çš„æƒå€¼ç›¸ä¹˜éƒ½å¯å¾—åˆ°ä¸€ä¸ªæƒå€¼ä¹˜ç§¯ï¼Œè¯•æ±‚æ‰€æœ‰ä¸‰è§’å½¢çš„é¡¶ç‚¹æƒå€¼ä¹˜ç§¯ä¹‹å’Œè‡³å°‘ä¸ºå¤šå°‘ã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 55, M = 35, INF = 1e9; int n; int w[N]; LL f[N][N][M]; void add(LL a[], LL b[]) { static LL c[M]; memset(c, 0, sizeof c); for (int i = 0, t = 0; i &lt; M; i ++ ) { t += a[i] + b[i]; c[i] = t % 10; t /= 10; } memcpy(a, c, sizeof c); } void mul(LL a[], LL b) { static LL c[M]; memset(c, 0, sizeof c); LL t = 0; for (int i = 0; i &lt; M; i ++ ) { t += a[i] * b; c[i] = t % 10; t /= 10; } memcpy(a, c, sizeof c); } int cmp(LL a[], LL b[]) { for (int i = M - 1; i &gt;= 0; i -- ) if (a[i] &gt; b[i]) return 1; else if (a[i] &lt; b[i]) return -1; return 0; } void print(LL a[]) { int k = M - 1; while (k &amp;&amp; !a[k]) k -- ; while (k &gt;= 0) cout &lt;&lt; a[k -- ]; cout &lt;&lt; endl; } int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; w[i]; LL temp[M]; for (int len = 3; len &lt;= n; len ++ ) for (int l = 1; l + len - 1 &lt;= n; l ++ ) { int r = l + len - 1; f[l][r][M - 1] = 1; for (int k = l + 1; k &lt; r; k ++ ) { memset(temp, 0, sizeof temp); temp[0] = w[l]; mul(temp, w[k]); mul(temp, w[r]); add(temp, f[l][k]); add(temp, f[k][r]); if (cmp(f[l][r], temp) &gt; 0) memcpy(f[l][r], temp, sizeof temp); } } print(f[1][n]); return 0; } æ•°ä½DP æ•°å­—æ¸¸æˆ ç§‘åé‡Œæœ€è¿‘å¾ˆæµè¡Œæ•°å­—æ¸¸æˆã€‚ æŸäººå‘½åäº†ä¸€ç§ä¸é™æ•°ï¼Œè¿™ç§æ•°å­—å¿…é¡»æ»¡è¶³ä»å·¦åˆ°å³å„ä½æ•°å­—å‘ˆéä¸‹é™å…³ç³»ï¼Œå¦‚ 123ï¼Œ446ã€‚ ç°åœ¨å¤§å®¶å†³å®šç©ä¸€ä¸ªæ¸¸æˆï¼ŒæŒ‡å®šä¸€ä¸ªæ•´æ•°é—­åŒºé—´ [a,b]ï¼Œé—®è¿™ä¸ªåŒºé—´å†…æœ‰å¤šå°‘ä¸ªä¸é™æ•°ã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 15; int f[N][N]; // f[i, j]è¡¨ç¤ºä¸€å…±æœ‰iä½ï¼Œä¸”æœ€é«˜ä½å¡«jçš„æ•°çš„ä¸ªæ•° void init() { for (int i = 0; i &lt;= 9; i ++ ) f[1][i] = 1; for (int i = 2; i &lt; N; i ++ ) for (int j = 0; j &lt;= 9; j ++ ) for (int k = j; k &lt;= 9; k ++ ) f[i][j] += f[i - 1][k]; } int dp(int n) { if (!n) return 1; vector&lt;int&gt; nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0; int last = 0; for (int i = nums.size() - 1; i &gt;= 0; i -- ) { int x = nums[i]; for (int j = last; j &lt; x; j ++ ) res += f[i + 1][j]; if (x &lt; last) break; last = x; if (!i) res ++ ; } return res; } int main() { init(); int l, r; while (cin &gt;&gt; l &gt;&gt; r) cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl; return 0; } /* 1 9 1 19 9 18 */ æ•°å­—æ¸¸æˆ II ç”±äºç§‘åé‡Œæœ€è¿‘çœŸçš„å¾ˆæµè¡Œæ•°å­—æ¸¸æˆã€‚ æŸäººåˆå‘½åäº†ä¸€ç§å–æ¨¡æ•°ï¼Œè¿™ç§æ•°å­—å¿…é¡»æ»¡è¶³å„ä½æ•°å­—ä¹‹å’Œ mod N ä¸º 0ã€‚ ç°åœ¨å¤§å®¶åˆè¦ç©æ¸¸æˆäº†ï¼ŒæŒ‡å®šä¸€ä¸ªæ•´æ•°é—­åŒºé—´ [a.b]ï¼Œé—®è¿™ä¸ªåŒºé—´å†…æœ‰å¤šå°‘ä¸ªå–æ¨¡æ•°ã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 11, M = 110; int P; int f[N][10][M]; int mod(int x, int y) { return (x % y + y) % y; } void init() { memset(f, 0, sizeof f); for (int i = 0; i &lt;= 9; i ++ ) f[1][i][i % P] ++ ; for (int i = 2; i &lt; N; i ++ ) for (int j = 0; j &lt;= 9; j ++ ) for (int k = 0; k &lt; P; k ++ ) for (int x = 0; x &lt;= 9; x ++ ) f[i][j][k] += f[i - 1][x][mod(k - j, P)]; } int dp(int n) { if (!n) return 1; vector&lt;int&gt; nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0; int last = 0; for (int i = nums.size() - 1; i &gt;= 0; i -- ) { int x = nums[i]; for (int j = 0; j &lt; x; j ++ ) res += f[i + 1][j][mod(-last, P)]; last += x; if (!i &amp;&amp; last % P == 0) res ++ ; } return res; } int main() { int l, r; while (cin &gt;&gt; l &gt;&gt; r &gt;&gt; P) { init(); cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl; } return 0; } /* 1 19 9 2 */ ä¸è¦62 ä¸å‰åˆ©çš„æ•°å­—ä¸ºæ‰€æœ‰å«æœ‰ 4 æˆ– 62 çš„å·ç ã€‚ä¾‹å¦‚ï¼š62315,73418,88914 éƒ½å±äºä¸å‰åˆ©å·ç ã€‚ä½†æ˜¯ï¼Œ61152 è™½ç„¶å«æœ‰ 6 å’Œ 2ï¼Œä½†ä¸æ˜¯ è¿å·ï¼Œæ‰€ä»¥ä¸å±äºä¸å‰åˆ©æ•°å­—ä¹‹åˆ—ã€‚ ä½ çš„ä»»åŠ¡æ˜¯ï¼Œå¯¹äºæ¯æ¬¡ç»™å‡ºçš„ä¸€ä¸ªç‰Œç…§å·åŒºé—´ [n,m]ï¼Œæ¨æ–­å‡ºäº¤ç®¡å±€ä»Šååˆè¦å®é™…ä¸Šç»™å¤šå°‘è¾†æ–°çš„å£«è½¦ä¸Šç‰Œç…§äº†ã€‚ /* æ¯ç»„æ•°æ®åŒ…å«ä¸€ä¸ªæ•´æ•°å¯¹ n å’Œ mã€‚ å½“è¾“å…¥ä¸€è¡Œä¸ºâ€œ0 0â€æ—¶ï¼Œè¡¨ç¤ºè¾“å…¥ç»“æŸã€‚ */ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 35; int f[N][10]; void init() { for (int i = 0; i &lt;= 9; i ++ ) if (i != 4) f[1][i] = 1; for (int i = 1; i &lt; N; i ++ ) for (int j = 0; j &lt;= 9; j ++ ) { if (j == 4) continue; for (int k = 0; k &lt;= 9; k ++ ) { if (k == 4 || j == 6 &amp;&amp; k == 2) continue; f[i][j] += f[i - 1][k]; } } } int dp(int n) { if (!n) return 1; vector&lt;int&gt; nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0; int last = 0; for (int i = nums.size() - 1; i &gt;= 0; i -- ) { int x = nums[i]; for (int j = 0; j &lt; x; j ++ ) { if (j == 4 || last == 6 &amp;&amp; j == 2) continue; res += f[i + 1][j]; } if (x == 4 || last == 6 &amp;&amp; x == 2) break; last = x; if (!i) res ++ ; } return res; } int main() { init(); int l, r; while (cin &gt;&gt; l &gt;&gt; r, l || r) { cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl; } return 0; } /* 1 100 0 0 80 */ æ–œç‡ä¼˜åŒ–DP ä»»åŠ¡å®‰æ’3 æœ‰ N ä¸ªä»»åŠ¡æ’æˆä¸€ä¸ªåºåˆ—åœ¨ä¸€å°æœºå™¨ä¸Šç­‰å¾…æ‰§è¡Œï¼Œå®ƒä»¬çš„é¡ºåºä¸å¾—æ”¹å˜ã€‚ æœºå™¨ä¼šæŠŠè¿™ N ä¸ªä»»åŠ¡åˆ†æˆè‹¥å¹²æ‰¹ï¼Œæ¯ä¸€æ‰¹åŒ…å«è¿ç»­çš„è‹¥å¹²ä¸ªä»»åŠ¡ã€‚ ä»æ—¶åˆ» 0 å¼€å§‹ï¼Œä»»åŠ¡è¢«åˆ†æ‰¹åŠ å·¥ï¼Œæ‰§è¡Œç¬¬ i ä¸ªä»»åŠ¡æ‰€éœ€çš„æ—¶é—´æ˜¯ Tiã€‚ å¦å¤–ï¼Œåœ¨æ¯æ‰¹ä»»åŠ¡å¼€å§‹å‰ï¼Œæœºå™¨éœ€è¦ S çš„å¯åŠ¨æ—¶é—´ï¼Œæ•…æ‰§è¡Œä¸€æ‰¹ä»»åŠ¡æ‰€éœ€çš„æ—¶é—´æ˜¯å¯åŠ¨æ—¶é—´ S åŠ ä¸Šæ¯ä¸ªä»»åŠ¡æ‰€éœ€æ—¶é—´ä¹‹å’Œã€‚ ä¸€ä¸ªä»»åŠ¡æ‰§è¡Œåï¼Œå°†åœ¨æœºå™¨ä¸­ç¨ä½œç­‰å¾…ï¼Œç›´è‡³è¯¥æ‰¹ä»»åŠ¡å…¨éƒ¨æ‰§è¡Œå®Œæ¯•ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼ŒåŒä¸€æ‰¹ä»»åŠ¡å°†åœ¨åŒä¸€æ—¶åˆ»å®Œæˆã€‚ æ¯ä¸ªä»»åŠ¡çš„è´¹ç”¨æ˜¯å®ƒçš„å®Œæˆæ—¶åˆ»ä¹˜ä»¥ä¸€ä¸ªè´¹ç”¨ç³»æ•° Ciã€‚ è¯·ä¸ºæœºå™¨è§„åˆ’ä¸€ä¸ªåˆ†ç»„æ–¹æ¡ˆï¼Œä½¿å¾—æ€»è´¹ç”¨æœ€å°ã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 300010; int n, s; LL t[N], c[N]; LL f[N]; int q[N]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;s); for (int i = 1; i &lt;= n; i ++ ) { scanf(&quot;%lld%lld&quot;, &amp;t[i], &amp;c[i]); t[i] += t[i - 1]; c[i] += c[i - 1]; } int hh = 0, tt = 0; q[0] = 0; for (int i = 1; i &lt;= n; i ++ ) { int l = hh, r = tt; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (f[q[mid + 1]] - f[q[mid]] &gt; (t[i] + s) * (c[q[mid + 1]] - c[q[mid]])) r = mid; else l = mid + 1; } int j = q[r]; f[i] = f[j] - (t[i] + s) * c[j] + t[i] * c[i] + s * c[n]; while (hh &lt; tt &amp;&amp; (double)(f[q[tt]] - f[q[tt - 1]]) * (c[i] - c[q[tt - 1]]) &gt;= (double)(f[i] - f[q[tt - 1]]) * (c[q[tt]] - c[q[tt - 1]])) tt -- ; q[ ++ tt] = i; } printf(&quot;%lld\\n&quot;, f[n]); return 0; } /* 5 1 1 3 3 2 4 3 2 3 1 4 153 */ 5. æœç´¢ 5.1 BFSæ±‚è¿é€šå—(FLood Fill) #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #define x first #define y second using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 1010, M = N * N; int n, m; char g[N][N]; PII q[M]; bool st[N][N]; void bfs(int sx, int sy) { int hh = 0, tt = 0; q[0] = {sx, sy}; st[sx][sy] = true; while (hh &lt;= tt) { PII t = q[hh ++ ]; for (int i = t.x - 1; i &lt;= t.x + 1; i ++ ) for (int j = t.y - 1; j &lt;= t.y + 1; j ++ ) { if (i == t.x &amp;&amp; j == t.y) continue; if (i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= m) continue; if (g[i][j] == '.' || st[i][j]) continue; q[ ++ tt] = {i, j}; st[i][j] = true; } } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%s&quot;, g[i]); int cnt = 0; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) if (g[i][j] == 'W' &amp;&amp; !st[i][j]) { bfs(i, j); cnt ++ ; } printf(&quot;%d\\n&quot;, cnt); return 0; } 5.2 çŸ©é˜µæœ€çŸ­è·¯æ¨¡å‹ ç»å…¸è¿·å®«é—®é¢˜ï¼Œå·¦ä¸Šåˆ°å³ä¸‹æ‰¾åˆ°ä¸€æ¡æœ€çŸ­è·¯å¾„(å¹¶è¾“å‡º) #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #define x first #define y second using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 1010, M = N * N; int n; int g[N][N]; PII q[M]; PII pre[N][N]; void bfs(int sx, int sy) { int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int hh = 0, tt = 0; q[0] = {sx, sy}; memset(pre, -1, sizeof pre); pre[sx][sy] = {0, 0}; while (hh &lt;= tt) { PII t = q[hh ++ ]; for (int i = 0; i &lt; 4; i ++ ) { int a = t.x + dx[i], b = t.y + dy[i]; if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n) continue; if (g[a][b]) continue; if (pre[a][b].x != -1) continue; q[ ++ tt] = {a, b}; pre[a][b] = t; } } } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) scanf(&quot;%d&quot;, &amp;g[i][j]); bfs(n - 1, n - 1); PII end(0, 0); while (true) { printf(&quot;%d %d\\n&quot;, end.x, end.y); if (end.x == n - 1 &amp;&amp; end.y == n - 1) break; end = pre[end.x][end.y]; } return 0; } è±¡æ£‹é©¬èµ°æ—¥ï¼Œè±¡èµ°ç”°æœ€çŸ­è·¯å¾„ç­‰åªéœ€è¦ç¨å¾®ä¿®æ”¹ä¸€ä¸‹dxï¼Œdyæ•°ç»„ 5.3 åŒå‘BFS å­—ç¬¦ä¸²å˜æ¢ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;unordered_map&gt; using namespace std; const int N = 6; int n; string A, B; string a[N], b[N]; int extend(queue&lt;string&gt;&amp; q, unordered_map&lt;string, int&gt;&amp;da, unordered_map&lt;string, int&gt;&amp; db, string a[N], string b[N]) { int d = da[q.front()]; while (q.size() &amp;&amp; da[q.front()] == d) { auto t = q.front(); q.pop(); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; t.size(); j ++ ) if (t.substr(j, a[i].size()) == a[i]) { string r = t.substr(0, j) + b[i] + t.substr(j + a[i].size()); if (db.count(r)) return da[t] + db[r] + 1; if (da.count(r)) continue; da[r] = da[t] + 1; q.push(r); } } return 11; } int bfs() { if (A == B) return 0; queue&lt;string&gt; qa, qb; unordered_map&lt;string, int&gt; da, db; qa.push(A), qb.push(B); da[A] = db[B] = 0; int step = 0; while (qa.size() &amp;&amp; qb.size()) { int t; if (qa.size() &lt; qb.size()) t = extend(qa, da, db, a, b); else t = extend(qb, db, da, b, a); if (t &lt;= 10) return t; if ( ++ step == 10) return -1; } return -1; } int main() { cin &gt;&gt; A &gt;&gt; B; while (cin &gt;&gt; a[n] &gt;&gt; b[n]) n ++ ; int t = bfs(); if (t == -1) puts(&quot;NO ANSWER!&quot;); else cout &lt;&lt; t &lt;&lt; endl; return 0; } 5.4 åŒç«¯é˜Ÿåˆ—å¹¿æœ è¾¹æƒåªæœ‰01çš„å›¾é€‚ç”¨ // ç”µè·¯ç»´ä¿® /* è”é€šçš„è¾¹æƒä¸º0ï¼Œä¸è¿é€šçš„è¾¹æƒä¸º0 */ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;deque&gt; #define x first #define y second using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 510, M = N * N; int n, m; char g[N][N]; int dist[N][N]; bool st[N][N]; int bfs() { memset(dist, 0x3f, sizeof dist); memset(st, 0, sizeof st); dist[0][0] = 0; deque&lt;PII&gt; q; q.push_back({0, 0}); char cs[] = &quot;\\\\/\\\\/&quot;; int dx[4] = {-1, -1, 1, 1}, dy[4] = {-1, 1, 1, -1}; int ix[4] = {-1, -1, 0, 0}, iy[4] = {-1, 0, 0, -1}; while (q.size()) { PII t = q.front(); q.pop_front(); if (st[t.x][t.y]) continue; st[t.x][t.y] = true; for (int i = 0; i &lt; 4; i ++ ) { int a = t.x + dx[i], b = t.y + dy[i]; if (a &lt; 0 || a &gt; n || b &lt; 0 || b &gt; m) continue; int ca = t.x + ix[i], cb = t.y + iy[i]; int d = dist[t.x][t.y] + (g[ca][cb] != cs[i]); if (d &lt; dist[a][b]) { dist[a][b] = d; if (g[ca][cb] != cs[i]) q.push_back({a, b}); // å¦‚æœè¾¹æƒä¸º1åˆ™æ”¾åˆ°é˜Ÿå°¾ else q.push_front({a, b}); // å¦‚æœè¾¹æƒä¸º0åˆ™æ”¾åˆ°å¯¹å¤´ } } } return dist[n][m]; } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T -- ) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%s&quot;, g[i]); int t = bfs(); if (t == 0x3f3f3f3f) puts(&quot;NO SOLUTION&quot;); else printf(&quot;%d\\n&quot;, t); } return 0; } 5.5 A* ç¬¬KçŸ­è·¯ // ç»™å®šä¸€å¼  N ä¸ªç‚¹ï¼ˆç¼–å· 1,2â€¦Nï¼‰ï¼ŒM æ¡è¾¹çš„æœ‰å‘å›¾ï¼Œæ±‚ä»èµ·ç‚¹ S åˆ°ç»ˆç‚¹ T çš„ç¬¬ K çŸ­è·¯çš„é•¿åº¦ï¼Œè·¯å¾„å…è®¸é‡å¤ç»è¿‡ç‚¹æˆ–è¾¹ã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #define x first #define y second using namespace std; typedef pair&lt;int, int&gt; PII; typedef pair&lt;int, PII&gt; PIII; const int N = 1010, M = 200010; int n, m, S, T, K; int h[N], rh[N], e[M], w[M], ne[M], idx; int dist[N], cnt[N]; bool st[N]; void add(int h[], int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } void dijkstra() { priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, T}); memset(dist, 0x3f, sizeof dist); dist[T] = 0; while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.y; if (st[ver]) continue; st[ver] = true; for (int i = rh[ver]; ~i; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } int astar() { priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt;&gt; heap; heap.push({dist[S], {0, S}}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.y.y, distance = t.y.x; cnt[ver] ++ ; if (cnt[T] == K) return distance; for (int i = h[ver]; ~i; i = ne[i]) { int j = e[i]; if (cnt[j] &lt; K) heap.push({distance + w[i] + dist[j], {distance + w[i], j}}); } } return -1; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); memset(rh, -1, sizeof rh); for (int i = 0; i &lt; m; i ++ ) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); add(h, a, b, c); add(rh, b, a, c); } scanf(&quot;%d%d%d&quot;, &amp;S, &amp;T, &amp;K); if (S == T) K ++ ; dijkstra(); printf(&quot;%d\\n&quot;, astar()); return 0; } 5.6 åŒå‘DFS è¾¾è¾¾å¸®ç¿°ç¿°ç»™å¥³ç”Ÿé€ç¤¼ç‰©ï¼Œç¿°ç¿°ä¸€å…±å‡†å¤‡äº† N ä¸ªç¤¼ç‰©ï¼Œå…¶ä¸­ç¬¬ i ä¸ªç¤¼ç‰©çš„é‡é‡æ˜¯ G[i]ã€‚ è¾¾è¾¾çš„åŠ›æ°”å¾ˆå¤§ï¼Œä»–ä¸€æ¬¡å¯ä»¥æ¬åŠ¨é‡é‡ä¹‹å’Œä¸è¶…è¿‡ W çš„ä»»æ„å¤šä¸ªç‰©å“ã€‚ è¾¾è¾¾å¸Œæœ›ä¸€æ¬¡æ¬æ‰å°½é‡é‡çš„ä¸€äº›ç‰©å“ï¼Œè¯·ä½ å‘Šè¯‰è¾¾è¾¾åœ¨ä»–çš„åŠ›æ°”èŒƒå›´å†…ä¸€æ¬¡æ€§èƒ½æ¬åŠ¨çš„æœ€å¤§é‡é‡æ˜¯å¤šå°‘ã€‚ #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long LL; const int N = 1 &lt;&lt; 24; int n, m, k; int g[50], weights[N]; int cnt = 0; int ans; void dfs(int u, int s) { if (u == k) { weights[cnt ++ ] = s; return; } if ((LL)s + g[u] &lt;= m) dfs(u + 1, s + g[u]); dfs(u + 1, s); } void dfs2(int u, int s) { if (u == n) { int l = 0, r = cnt - 1; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (weights[mid] + (LL)s &lt;= m) l = mid; else r = mid - 1; } if (weights[l] + (LL)s &lt;= m) ans = max(ans, weights[l] + s); return; } if ((LL)s + g[u] &lt;= m) dfs2(u + 1, s + g[u]); dfs2(u + 1, s); } int main() { cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; g[i]; sort(g, g + n); reverse(g, g + n); k = n / 2; // é˜²æ­¢ n = 1æ—¶ï¼Œå‡ºç°æ­»å¾ªç¯ dfs(0, 0); sort(weights, weights + cnt); int t = 1; for (int i = 1; i &lt; cnt; i ++ ) if (weights[i] != weights[i - 1]) weights[t ++ ] = weights[i]; cnt = t; dfs2(k, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0; } /* 20 5 7 5 4 18 1 19 */ 5.7 IDA* æ’ä¹¦ ç»™å®š n æœ¬ä¹¦ï¼Œç¼–å·ä¸º 1âˆ¼nã€‚ åœ¨åˆå§‹çŠ¶æ€ä¸‹ï¼Œä¹¦æ˜¯ä»»æ„æ’åˆ—çš„ã€‚ åœ¨æ¯ä¸€æ¬¡æ“ä½œä¸­ï¼Œå¯ä»¥æŠ½å–å…¶ä¸­è¿ç»­çš„ä¸€æ®µï¼Œå†æŠŠè¿™æ®µæ’å…¥åˆ°å…¶ä»–æŸä¸ªä½ç½®ã€‚ æˆ‘ä»¬çš„ç›®æ ‡çŠ¶æ€æ˜¯æŠŠä¹¦æŒ‰ç…§ 1âˆ¼n çš„é¡ºåºä¾æ¬¡æ’åˆ—ã€‚ æ±‚æœ€å°‘éœ€è¦å¤šå°‘æ¬¡æ“ä½œã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 15; int n; int q[N]; int w[5][N]; int f() { int cnt = 0; for (int i = 0; i + 1 &lt; n; i ++ ) if (q[i + 1] != q[i] + 1) cnt ++ ; return (cnt + 2) / 3; } bool check() { for (int i = 0; i + 1 &lt; n; i ++ ) if (q[i + 1] != q[i] + 1) return false; return true; } bool dfs(int depth, int max_depth) { if (depth + f() &gt; max_depth) return false; if (check()) return true; for (int len = 1; len &lt;= n; len ++ ) for (int l = 0; l + len - 1 &lt; n; l ++ ) { int r = l + len - 1; for (int k = r + 1; k &lt; n; k ++ ) { memcpy(w[depth], q, sizeof q); int x, y; for (x = r + 1, y = l; x &lt;= k; x ++, y ++ ) q[y] = w[depth][x]; for (x = l; x &lt;= r; x ++, y ++ ) q[y] = w[depth][x]; if (dfs(depth + 1, max_depth)) return true; memcpy(q, w[depth], sizeof q); } } return false; } int main() { int T; cin &gt;&gt; T; while (T -- ) { cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; q[i]; int depth = 0; while (depth &lt; 5 &amp;&amp; !dfs(0, depth)) depth ++ ; if (depth &gt;= 5) puts(&quot;5 or more&quot;); else cout &lt;&lt; depth &lt;&lt; endl; } return 0; } 6. å›¾è®º 6.1 å­˜è¾¹ é‚»æ¥çŸ©é˜µ é‚»æ¥è¡¨ // å¯¹äºæ¯ä¸ªç‚¹kï¼Œå¼€ä¸€ä¸ªå•é“¾è¡¨ï¼Œå­˜å‚¨kæ‰€æœ‰å¯ä»¥èµ°åˆ°çš„ç‚¹ã€‚h[k]å­˜å‚¨è¿™ä¸ªå•é“¾è¡¨çš„å¤´ç»“ç‚¹ int h[N], e[N], ne[N], idx; // æ·»åŠ ä¸€æ¡è¾¹a-&gt;b void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // åˆå§‹åŒ– idx = 0; memset(h, -1, sizeof h); 6.2 æ ‘ä¸å›¾çš„éå† æ—¶é—´å¤æ‚åº¦ O(n+m)ï¼Œn è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•° æ·±åº¦ä¼˜å…ˆéå† int dfs(int u) { st[u] = true; // st[u] è¡¨ç¤ºç‚¹uå·²ç»è¢«éå†è¿‡ for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } å®½åº¦ä¼˜å…ˆéå† queue&lt;int&gt; q; st[1] = true; // è¡¨ç¤º1å·ç‚¹å·²ç»è¢«éå†è¿‡ q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // è¡¨ç¤ºç‚¹jå·²ç»è¢«éå†è¿‡ q.push(j); } } } 6.3 æ‹“æ‰‘æ’åº æ—¶é—´å¤æ‚åº¦ O(n+m)ï¼Œn è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•° bool topsort() { int hh = 0, tt = -1; // d[i] å­˜å‚¨ç‚¹içš„å…¥åº¦ for (int i = 1; i &lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; } } // å¦‚æœæ‰€æœ‰ç‚¹éƒ½å…¥é˜Ÿäº†ï¼Œè¯´æ˜å­˜åœ¨æ‹“æ‰‘åºåˆ—ï¼›å¦åˆ™ä¸å­˜åœ¨æ‹“æ‰‘åºåˆ—ã€‚ return tt == n - 1; } 6.4 å›¾è®ºæœ€çŸ­è·¯æ¨¡å‹(DJ, SPFAâ€¦) å †ä¼˜åŒ–çš„Dijkstra æ—¶é—´å¤æ‚åº¦ O(mlogn), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•° typedef pair&lt;int, int&gt; PII; int n; // ç‚¹çš„æ•°é‡ int h[N], w[N], e[N], ne[N], idx; // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹ int dist[N]; // å­˜å‚¨æ‰€æœ‰ç‚¹åˆ°1å·ç‚¹çš„è·ç¦» bool st[N]; // å­˜å‚¨æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»æ˜¯å¦å·²ç¡®å®š // æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·ç¦»ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¿”å›-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); // firstå­˜å‚¨è·ç¦»ï¼Œsecondå­˜å‚¨èŠ‚ç‚¹ç¼–å· while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } Bellman-Fordç®—æ³• æ—¶é—´å¤æ‚åº¦ O(nm), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•° #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e4 + 10; struct Edge { int a, b, w; }edge[N]; int n, m, k; int dist[N], backup[N]; void bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for(int i = 1;i &lt;= k;i ++) { memcpy(backup, dist, sizeof dist); for(int j = 0;j &lt;= m;j ++) { int a = edge[j].a,b = edge[j].b,w = edge[j].w; dist[b] = min(dist[b], backup[a] + w); } } if(dist[n] &gt; 0x3f3f3f3f / 2) printf(&quot;impossible\\n&quot;); else printf(&quot;%d\\n&quot;, dist[n]); } int main() { scanf(&quot;%d%d%d&quot;,&amp;n, &amp;m, &amp;k); for(int i = 1;i &lt;= m;i ++) { Edge &amp;x = edge[i]; scanf(&quot;%d%d%d&quot;,&amp;x.a, &amp;x.b, &amp;x.w); } bellman_ford(); return 0; } SPFAç®—æ³• æ—¶é—´å¤æ‚åº¦ å¹³å‡æƒ…å†µä¸‹ O(m)ï¼Œæœ€åæƒ…å†µä¸‹ O(nm), n è¡¨ç¤ºç‚¹æ•°, m è¡¨ç¤ºè¾¹æ•° int n; // æ€»ç‚¹æ•° int h[N], w[N], e[N], ne[N], idx; // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹ int dist[N]; // å­˜å‚¨æ¯ä¸ªç‚¹åˆ°1å·ç‚¹çš„æœ€çŸ­è·ç¦» bool st[N]; // å­˜å‚¨æ¯ä¸ªç‚¹æ˜¯å¦åœ¨é˜Ÿåˆ—ä¸­ // æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·¯è·ç¦»ï¼Œå¦‚æœä»1å·ç‚¹æ— æ³•èµ°åˆ°nå·ç‚¹åˆ™è¿”å›-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int&gt; q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // å¦‚æœé˜Ÿåˆ—ä¸­å·²å­˜åœ¨jï¼Œåˆ™ä¸éœ€è¦å°†jé‡å¤æ’å…¥ { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } spfaåˆ¤æ–­å›¾ä¸­æ˜¯å¦å­˜åœ¨è´Ÿç¯ æ—¶é—´å¤æ‚åº¦æ˜¯ O(nm), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•° int n; // æ€»ç‚¹æ•° int h[N], w[N], e[N], ne[N], idx; // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹ int dist[N], cnt[N]; // dist[x]å­˜å‚¨1å·ç‚¹åˆ°xçš„æœ€çŸ­è·ç¦»ï¼Œcnt[x]å­˜å‚¨1åˆ°xçš„æœ€çŸ­è·¯ä¸­ç»è¿‡çš„ç‚¹æ•° bool st[N]; // å­˜å‚¨æ¯ä¸ªç‚¹æ˜¯å¦åœ¨é˜Ÿåˆ—ä¸­ // å¦‚æœå­˜åœ¨è´Ÿç¯ï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›falseã€‚ bool spfa() { // ä¸éœ€è¦åˆå§‹åŒ–distæ•°ç»„ // åŸç†ï¼šå¦‚æœæŸæ¡æœ€çŸ­è·¯å¾„ä¸Šæœ‰nä¸ªç‚¹ï¼ˆé™¤äº†è‡ªå·±ï¼‰ï¼Œé‚£ä¹ˆåŠ ä¸Šè‡ªå·±ä¹‹åä¸€å…±æœ‰n+1ä¸ªç‚¹ï¼Œç”±æŠ½å±‰åŸç†ä¸€å®šæœ‰ä¸¤ä¸ªç‚¹ç›¸åŒï¼Œæ‰€ä»¥å­˜åœ¨ç¯ã€‚ queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] &gt;= n) return true; // å¦‚æœä»1å·ç‚¹åˆ°xçš„æœ€çŸ­è·¯ä¸­åŒ…å«è‡³å°‘nä¸ªç‚¹ï¼ˆä¸åŒ…æ‹¬è‡ªå·±ï¼‰ï¼Œåˆ™è¯´æ˜å­˜åœ¨ç¯ if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } floydç®—æ³• æ—¶é—´å¤æ‚åº¦æ˜¯ O(n3), n è¡¨ç¤ºç‚¹æ•° åˆå§‹åŒ–ï¼š for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF; // ç®—æ³•ç»“æŸåï¼Œd[a][b]è¡¨ç¤ºaåˆ°bçš„æœ€çŸ­è·ç¦» void floyd() { for (int k = 1; k &lt;= n; k ++ ) for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } 6.5 æœ€å°ç”Ÿæˆæ ‘ æœ´ç´ ç‰ˆprimç®—æ³• æ—¶é—´å¤æ‚åº¦æ˜¯ O(n^2+m), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•° int n; // nè¡¨ç¤ºç‚¹æ•° int g[N][N]; // é‚»æ¥çŸ©é˜µï¼Œå­˜å‚¨æ‰€æœ‰è¾¹ int dist[N]; // å­˜å‚¨å…¶ä»–ç‚¹åˆ°å½“å‰æœ€å°ç”Ÿæˆæ ‘çš„è·ç¦» bool st[N]; // å­˜å‚¨æ¯ä¸ªç‚¹æ˜¯å¦å·²ç»åœ¨ç”Ÿæˆæ ‘ä¸­ // å¦‚æœå›¾ä¸è¿é€šï¼Œåˆ™è¿”å›INF(å€¼æ˜¯0x3f3f3f3f), å¦åˆ™è¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æ ‘è¾¹æƒé‡ä¹‹å’Œ int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i ++ ) { int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } Kruskalç®—æ³• æ—¶é—´å¤æ‚åº¦æ˜¯ O(mlogm), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•° int n, m; // næ˜¯ç‚¹æ•°ï¼Œmæ˜¯è¾¹æ•° int p[N]; // å¹¶æŸ¥é›†çš„çˆ¶èŠ‚ç‚¹æ•°ç»„ struct Edge // å­˜å‚¨è¾¹ { int a, b, w; bool operator&lt; (const Edge &amp;W)const { return w &lt; W.w; } }edges[M]; int find(int x) // å¹¶æŸ¥é›†æ ¸å¿ƒæ“ä½œ { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // åˆå§‹åŒ–å¹¶æŸ¥é›† int res = 0, cnt = 0; for (int i = 0; i &lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // å¦‚æœä¸¤ä¸ªè¿é€šå—ä¸è¿é€šï¼Œåˆ™å°†è¿™ä¸¤ä¸ªè¿é€šå—åˆå¹¶ { p[a] = b; res += w; cnt ++ ; } } if (cnt &lt; n - 1) return INF; return res; } 6.6 æŸ“è‰²æ³•åˆ¤åˆ«äºŒåˆ†å›¾ æ—¶é—´å¤æ‚åº¦æ˜¯ O(n+m), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•° int n; // nè¡¨ç¤ºç‚¹æ•° int h[N], e[M], ne[M], idx; // é‚»æ¥è¡¨å­˜å‚¨å›¾ int color[N]; // è¡¨ç¤ºæ¯ä¸ªç‚¹çš„é¢œè‰²ï¼Œ-1è¡¨ç¤ºæœªæŸ“è‰²ï¼Œ0è¡¨ç¤ºç™½è‰²ï¼Œ1è¡¨ç¤ºé»‘è‰² // å‚æ•°ï¼šuè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ï¼Œcè¡¨ç¤ºå½“å‰ç‚¹çš„é¢œè‰² bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i &lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } 6.7 äºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é…ï¼ˆåŒˆç‰™åˆ©ç®—æ³•ï¼‰ æ—¶é—´å¤æ‚åº¦æ˜¯ O(nm), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•° int n1, n2; // n1è¡¨ç¤ºç¬¬ä¸€ä¸ªé›†åˆä¸­çš„ç‚¹æ•°ï¼Œn2è¡¨ç¤ºç¬¬äºŒä¸ªé›†åˆä¸­çš„ç‚¹æ•° int h[N], e[M], ne[M], idx; // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹ï¼ŒåŒˆç‰™åˆ©ç®—æ³•ä¸­åªä¼šç”¨åˆ°ä»ç¬¬ä¸€ä¸ªé›†åˆæŒ‡å‘ç¬¬äºŒä¸ªé›†åˆçš„è¾¹ï¼Œæ‰€ä»¥è¿™é‡Œåªç”¨å­˜ä¸€ä¸ªæ–¹å‘çš„è¾¹ int match[N]; // å­˜å‚¨ç¬¬äºŒä¸ªé›†åˆä¸­çš„æ¯ä¸ªç‚¹å½“å‰åŒ¹é…çš„ç¬¬ä¸€ä¸ªé›†åˆä¸­çš„ç‚¹æ˜¯å“ªä¸ª bool st[N]; // è¡¨ç¤ºç¬¬äºŒä¸ªé›†åˆä¸­çš„æ¯ä¸ªç‚¹æ˜¯å¦å·²ç»è¢«éå†è¿‡ bool find(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // æ±‚æœ€å¤§åŒ¹é…æ•°ï¼Œä¾æ¬¡æšä¸¾ç¬¬ä¸€ä¸ªé›†åˆä¸­çš„æ¯ä¸ªç‚¹èƒ½å¦åŒ¹é…ç¬¬äºŒä¸ªé›†åˆä¸­çš„ç‚¹ int res = 0; for (int i = 1; i &lt;= n1; i ++ ) { memset(st, false, sizeof st); if (find(i)) res ++ ; } 6.8 æ ‘çš„ç›´å¾„ æ ‘ä¸Šæœ€é•¿çš„è·¯å¾„ æ ‘å½¢DPæ±‚æ ‘çš„ç›´å¾„ void dp(int x) { st[x] = 1; for(int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if(st[j]) continue; dp(j); ans = max(ans, d[x] + d[j] + w[i]); d[x] = max(d[x], d[j] + w[i]); } } ä¸¤æ¬¡BFSæ±‚å‡ºæ ‘çš„ç›´å¾„ï¼ˆè¾¹æƒéè´Ÿï¼‰ ï¼ˆ1ï¼‰ä»ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘ï¼Œè·‘ä¸€éBFSï¼Œæ‰¾åˆ°æœ€è¿œçš„p ï¼ˆ2ï¼‰å†ä»på‡ºå‘ï¼Œè·‘ä¸€éBFSï¼Œæ‰¾åˆ°è·ç¦»pæœ€è¿œçš„q p, qå³ä¸ºä¸¤ä¸ªç«¯ç‚¹ã€‚ 6.9 æ¬§æ‹‰å›è·¯ä¸æ¬§æ‹‰è·¯å¾„ å­˜åœ¨æ¬§æ‹‰å›è·¯ä¸æ¬§æ‹‰è·¯å¾„çš„å……è¦æ¡ä»¶ï¼š æ— å‘å›¾ å­˜åœ¨æ¬§æ‹‰è·¯å¾„çš„å……è¦æ¡ä»¶ : åº¦æ•°ä¸ºå¥‡æ•°çš„ç‚¹åªèƒ½æœ‰0æˆ–2ä¸ª å­˜åœ¨æ¬§æ‹‰å›è·¯çš„å……è¦æ¡ä»¶ : åº¦æ•°ä¸ºå¥‡æ•°çš„ç‚¹åªèƒ½æœ‰0ä¸ª æœ‰å‘å›¾ å­˜åœ¨æ¬§æ‹‰è·¯å¾„çš„å……è¦æ¡ä»¶ : è¦ä¹ˆæ‰€æœ‰ç‚¹çš„å‡ºåº¦å‡==å…¥åº¦ï¼› è¦ä¹ˆé™¤äº†ä¸¤ä¸ªç‚¹ä¹‹å¤–ï¼Œå…¶ä½™æ‰€æœ‰ç‚¹çš„å‡ºåº¦==å…¥åº¦ å‰©ä½™çš„ä¸¤ä¸ªç‚¹:ä¸€ä¸ªæ»¡è¶³å‡ºåº¦-å…¥åº¦==1(èµ·ç‚¹) ä¸€ä¸ªæ»¡è¶³å…¥åº¦-å‡ºåº¦==1(ç»ˆç‚¹) å­˜åœ¨æ¬§æ‹‰å›è·¯çš„å……è¦æ¡ä»¶ : æ‰€æœ‰ç‚¹çš„å‡ºåº¦å‡ç­‰äºå…¥åº¦ 6.10 æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ˆLCAï¼‰ ç¥–å­™è¯¢é—® #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 40010, M = N * 2; int n, m; int h[N], e[M], ne[M], idx; int depth[N], fa[N][16]; int q[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void bfs(int root) { memset(depth, 0x3f, sizeof depth); depth[0] = 0, depth[root] = 1; int hh = 0, tt = 0; q[0] = root; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if (depth[j] &gt; depth[t] + 1) { depth[j] = depth[t] + 1; q[ ++ tt] = j; fa[j][0] = t; for (int k = 1; k &lt;= 15; k ++ ) fa[j][k] = fa[fa[j][k - 1]][k - 1]; } } } } int lca(int a, int b) { if (depth[a] &lt; depth[b]) swap(a, b); for (int k = 15; k &gt;= 0; k -- ) if (depth[fa[a][k]] &gt;= depth[b]) a = fa[a][k]; if (a == b) return a; for (int k = 15; k &gt;= 0; k -- ) if (fa[a][k] != fa[b][k]) { a = fa[a][k]; b = fa[b][k]; } return fa[a][0]; } int main() { scanf(&quot;%d&quot;, &amp;n); int root = 0; memset(h, -1, sizeof h); for (int i = 0; i &lt; n; i ++ ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (b == -1) root = a; else add(a, b), add(b, a); } bfs(root); scanf(&quot;%d&quot;, &amp;m); while (m -- ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); int p = lca(a, b); if (p == a) puts(&quot;1&quot;); else if (p == b) puts(&quot;2&quot;); else puts(&quot;0&quot;); } return 0; } æ¬¡å°ç”Ÿæˆæ ‘ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 100010, M = 300010, INF = 0x3f3f3f3f; int n, m; struct Edge { int a, b, w; bool used; bool operator&lt; (const Edge &amp;t) const { return w &lt; t.w; } }edge[M]; int p[N]; int h[N], e[M], w[M], ne[M], idx; int depth[N], fa[N][17], d1[N][17], d2[N][17]; int q[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } LL kruskal() { for (int i = 1; i &lt;= n; i ++ ) p[i] = i; sort(edge, edge + m); LL res = 0; for (int i = 0; i &lt; m; i ++ ) { int a = find(edge[i].a), b = find(edge[i].b), w = edge[i].w; if (a != b) { p[a] = b; res += w; edge[i].used = true; } } return res; } void build() { memset(h, -1, sizeof h); for (int i = 0; i &lt; m; i ++ ) if (edge[i].used) { int a = edge[i].a, b = edge[i].b, w = edge[i].w; add(a, b, w), add(b, a, w); } } void bfs() { memset(depth, 0x3f, sizeof depth); depth[0] = 0, depth[1] = 1; q[0] = 1; int hh = 0, tt = 0; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if (depth[j] &gt; depth[t] + 1) { depth[j] = depth[t] + 1; q[ ++ tt] = j; fa[j][0] = t; d1[j][0] = w[i], d2[j][0] = -INF; for (int k = 1; k &lt;= 16; k ++ ) { int anc = fa[j][k - 1]; fa[j][k] = fa[anc][k - 1]; int distance[4] = {d1[j][k - 1], d2[j][k - 1], d1[anc][k - 1], d2[anc][k - 1]}; d1[j][k] = d2[j][k] = -INF; for (int u = 0; u &lt; 4; u ++ ) { int d = distance[u]; if (d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d; else if (d != d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d; } } } } } } int lca(int a, int b, int w) { static int distance[N * 2]; int cnt = 0; if (depth[a] &lt; depth[b]) swap(a, b); for (int k = 16; k &gt;= 0; k -- ) if (depth[fa[a][k]] &gt;= depth[b]) { distance[cnt ++ ] = d1[a][k]; distance[cnt ++ ] = d2[a][k]; a = fa[a][k]; } if (a != b) { for (int k = 16; k &gt;= 0; k -- ) if (fa[a][k] != fa[b][k]) { distance[cnt ++ ] = d1[a][k]; distance[cnt ++ ] = d2[a][k]; distance[cnt ++ ] = d1[b][k]; distance[cnt ++ ] = d2[b][k]; a = fa[a][k], b = fa[b][k]; } distance[cnt ++ ] = d1[a][0]; distance[cnt ++ ] = d1[b][0]; } int dist1 = -INF, dist2 = -INF; for (int i = 0; i &lt; cnt; i ++ ) { int d = distance[i]; if (d &gt; dist1) dist2 = dist1, dist1 = d; else if (d != dist1 &amp;&amp; d &gt; dist2) dist2 = d; } if (w &gt; dist1) return w - dist1; if (w &gt; dist2) return w - dist2; return INF; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; i ++ ) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); edge[i] = {a, b, c}; } LL sum = kruskal(); build(); bfs(); LL res = 1e18; for (int i = 0; i &lt; m; i ++ ) if (!edge[i].used) { int a = edge[i].a, b = edge[i].b, w = edge[i].w; res = min(res, sum + lca(a, b, w)); } printf(&quot;%lld\\n&quot;, res); return 0; } 6.11 æ ‘ä¸Šä¸¤ç‚¹è·ç¦» #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 10010, M = N * 2; int n, m; int h[N], e[M], w[M], ne[M], idx; int dist[N]; int p[N]; int res[M]; int st[N]; vector&lt;PII&gt; query[N]; // firstå­˜æŸ¥è¯¢çš„å¦å¤–ä¸€ä¸ªç‚¹ï¼Œsecondå­˜æŸ¥è¯¢ç¼–å· void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } void dfs(int u, int fa) { for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa) continue; dist[j] = dist[u] + w[i]; dfs(j, u); } } int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } void tarjan(int u) { st[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (!st[j]) { tarjan(j); p[j] = u; } } for (auto item : query[u]) { int y = item.first, id = item.second; if (st[y] == 2) { int anc = find(y); res[id] = dist[u] + dist[y] - dist[anc] * 2; } } st[u] = 2; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); for (int i = 0; i &lt; n - 1; i ++ ) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); add(a, b, c), add(b, a, c); } for (int i = 0; i &lt; m; i ++ ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (a != b) { query[a].push_back({b, i}); query[b].push_back({a, i}); } } for (int i = 1; i &lt;= n; i ++ ) p[i] = i; dfs(1, -1); tarjan(1); for (int i = 0; i &lt; m; i ++ ) printf(&quot;%d\\n&quot;, res[i]); return 0; } 6.12 æœ‰å‘å›¾çš„å¼ºè”é€šåˆ†é‡ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 10010, M = 50010; int n, m; int h[N], e[M], ne[M], idx; int dfn[N], low[N], timestamp; int stk[N], top; bool in_stk[N]; int id[N], scc_cnt, Size[N]; int dout[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void tarjan(int u) { dfn[u] = low[u] = ++ timestamp; stk[ ++ top] = u, in_stk[u] = true; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!dfn[j]) { tarjan(j); low[u] = min(low[u], low[j]); } else if (in_stk[j]) low[u] = min(low[u], dfn[j]); } if (dfn[u] == low[u]) { ++ scc_cnt; int y; do { y = stk[top -- ]; in_stk[y] = false; id[y] = scc_cnt; Size[scc_cnt] ++ ; } while (y != u); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); while (m -- ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b); } for (int i = 1; i &lt;= n; i ++ ) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; i ++ ) for (int j = h[i]; ~j; j = ne[j]) { int k = e[j]; int a = id[i], b = id[k]; if (a != b) dout[a] ++ ; } int zeros = 0, sum = 0; for (int i = 1; i &lt;= scc_cnt; i ++ ) if (!dout[i]) { zeros ++ ; sum += Size[i]; if (zeros &gt; 1) { sum = 0; break; } } printf(&quot;%d\\n&quot;, sum); return 0; } 6.13 æ— å‘å›¾çš„åŒè”é€šåˆ†é‡ å†—ä½™è·¯å¾„ ä¸ºäº†ä» FF ä¸ªè‰åœºä¸­çš„ä¸€ä¸ªèµ°åˆ°å¦ä¸€ä¸ªï¼Œå¥¶ç‰›ä»¬æœ‰æ—¶ä¸å¾—ä¸è·¯è¿‡ä¸€äº›å¥¹ä»¬è®¨åŒçš„å¯æ€•çš„æ ‘ã€‚ å¥¶ç‰›ä»¬å·²ç»åŒå€¦äº†è¢«è¿«èµ°æŸä¸€æ¡è·¯ï¼Œæ‰€ä»¥å¥¹ä»¬æƒ³å»ºä¸€äº›æ–°è·¯ï¼Œä½¿æ¯ä¸€å¯¹è‰åœºä¹‹é—´éƒ½ä¼šè‡³å°‘æœ‰ä¸¤æ¡ç›¸äº’åˆ†ç¦»çš„è·¯å¾„ï¼Œè¿™æ ·å¥¹ä»¬å°±æœ‰å¤šä¸€äº›é€‰æ‹©ã€‚ æ¯å¯¹è‰åœºä¹‹é—´å·²ç»æœ‰è‡³å°‘ä¸€æ¡è·¯å¾„ã€‚ ç»™å‡ºæ‰€æœ‰ RR æ¡åŒå‘è·¯çš„æè¿°ï¼Œæ¯æ¡è·¯è¿æ¥äº†ä¸¤ä¸ªä¸åŒçš„è‰åœºï¼Œè¯·è®¡ç®—æœ€å°‘çš„æ–°å»ºé“è·¯çš„æ•°é‡ï¼Œè·¯å¾„ç”±è‹¥å¹²é“è·¯é¦–å°¾ç›¸è¿è€Œæˆã€‚ ä¸¤æ¡è·¯å¾„ç›¸äº’åˆ†ç¦»ï¼Œæ˜¯æŒ‡ä¸¤æ¡è·¯å¾„æ²¡æœ‰ä¸€æ¡é‡åˆçš„é“è·¯ã€‚ ä½†æ˜¯ï¼Œä¸¤æ¡åˆ†ç¦»çš„è·¯å¾„ä¸Šå¯ä»¥æœ‰ä¸€äº›ç›¸åŒçš„è‰åœºã€‚ å¯¹äºåŒä¸€å¯¹è‰åœºä¹‹é—´ï¼Œå¯èƒ½å·²ç»æœ‰ä¸¤æ¡ä¸åŒçš„é“è·¯ï¼Œä½ ä¹Ÿå¯ä»¥åœ¨å®ƒä»¬ä¹‹é—´å†å»ºä¸€æ¡é“è·¯ï¼Œä½œä¸ºå¦ä¸€æ¡ä¸åŒçš„é“è·¯ã€‚ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 5010, M = 20010; int n, m; int h[N], e[M], ne[M], idx; int dfn[N], low[N], timestamp; int stk[N], top; int id[N], dcc_cnt; bool is_bridge[M]; int d[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void tarjan(int u, int from) { dfn[u] = low[u] = ++ timestamp; stk[ ++ top] = u; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (!dfn[j]) { tarjan(j, i); low[u] = min(low[u], low[j]); if (dfn[u] &lt; low[j]) is_bridge[i] = is_bridge[i ^ 1] = true; } else if (i != (from ^ 1)) low[u] = min(low[u], dfn[j]); } if (dfn[u] == low[u]) { ++ dcc_cnt; int y; do { y = stk[top -- ]; id[y] = dcc_cnt; } while (y != u); } } int main() { cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); while (m -- ) { int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b), add(b, a); } tarjan(1, -1); for (int i = 0; i &lt; idx; i ++ ) if (is_bridge[i]) d[id[e[i]]] ++ ; int cnt = 0; for (int i = 1; i &lt;= dcc_cnt; i ++ ) if (d[i] == 1) cnt ++ ; printf(&quot;%d\\n&quot;, (cnt + 1) / 2); return 0; }","categories":[],"tags":[],"keywords":[]},{"title":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","date":"2022-10-18T03:08:52.000Z","updated":"2022-10-18T03:10:18.143Z","comments":true,"path":"2022/10/18/çº¿æ®µæ ‘/","link":"","permalink":"https://memsetray.github.io/2022/10/18/çº¿æ®µæ ‘/","excerpt":"","text":"çº¿æ®µæ ‘ 1.å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢çº¿æ®µæ ‘ #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10; struct info { int minv, cnt_min; }; struct Node { info val; }tr[N * 4]; int n, q; int a[N]; info operator + (const info &amp;l, const info &amp;r) { info a; a.minv = min(l.minv, r.minv); if(l.minv == r.minv) a.cnt_min = l.cnt_min + r.cnt_min; else if(l.minv &lt; r.minv) a.cnt_min = l.cnt_min; else a.cnt_min = r.cnt_min; return a; } void pushup(int u) { tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val; } void build(int u, int l, int r) { if(l == r) tr[u].val = {a[l], 1}; else { int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void change(int u, int l, int r, int pos, int val) { if(l == r) tr[u].val = {val, 1}; else { int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) change(u &lt;&lt; 1, l, mid, pos, val); else change(u &lt;&lt; 1 | 1, mid + 1, r, pos, val); pushup(u); } } info query(int u, int l, int r, int ql, int qr) { if(l == ql &amp;&amp; r == qr) return tr[u].val; int mid = l + r &gt;&gt; 1; if(qr &lt;= mid) return query(u &lt;&lt; 1, l, mid, ql, qr); else if(ql &gt; mid) return query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr); else { return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 1, n); while(q --) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if(a == 1) { change(1, 1, n, b, c); } else { auto a = query(1, 1, n, b, c); printf(&quot;%d %d\\n&quot;, a.minv, a.cnt_min); } } } 2.ç»´æŠ¤å¤æ‚ä¿¡æ¯çš„çº¿æ®µæ ‘ï¼ˆæœ€å¤§å­æ®µå’Œï¼‰ #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int N = 2e5 + 10; struct info { ll mss, mpre, msuf, s; info () {} info (int a):mss(a), mpre(a), msuf(a), s(a) {} }; struct Node { info val; }tr[N * 4]; int n, q; int a[N]; info operator + (const info &amp;l, const info &amp;r) { info a; a.mss = max(max(l.mss, r.mss), l.msuf + r.mpre); a.mpre = max(l.mpre, l.s + r.mpre); a.msuf = max(r.msuf, r.s + l.msuf); a.s = l.s + r.s; return a; } void pushup(int u) { tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val; } void build(int u, int l, int r) { if(l == r) tr[u].val = info(a[l]); else { int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void change(int u, int l, int r, int pos, int val) { if(l == r) tr[u].val = info(val); else { int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) change(u &lt;&lt; 1, l, mid, pos, val); else change(u &lt;&lt; 1 | 1, mid + 1, r, pos, val); pushup(u); } } info query(int u, int l, int r, int ql, int qr) { if(l == ql &amp;&amp; r == qr) return tr[u].val; int mid = l + r &gt;&gt; 1; if(qr &lt;= mid) return query(u &lt;&lt; 1, l, mid, ql, qr); else if(ql &gt; mid) return query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr); else { return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 1, n); while(q --) { ll a, b, c; scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c); if(a == 1) { change(1, 1, n, b, c); } else { auto a = query(1, 1, n, b, c); printf(&quot;%lld\\n&quot;, a.mss); } } } 3.åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢çº¿æ®µæ ‘ #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10; typedef long long ll; ll n, q; ll a[N]; struct info { ll maxv; }; struct tag { ll add; }; info operator + (const info &amp;l, const info &amp;r) { return {max(l.maxv, r.maxv)}; } info operator + (const info &amp;v, const tag &amp;t) { return {v.maxv + t.add}; } tag operator + (const tag &amp;t1, const tag &amp;t2) { return {t1.add + t2.add}; } struct node { tag t; info val; }tr[N * 4]; void pushup(int u) { tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val; } void settag(int u, tag t) { tr[u].val = tr[u].val + t; tr[u].t = tr[u].t + t; } void pushdown(int u) { if(tr[u].t.add != 0) { settag(u &lt;&lt; 1, tr[u].t); settag(u &lt;&lt; 1 | 1, tr[u].t); tr[u].t.add = 0; } } void build(int u, int l, int r) { if(l == r) tr[u].val = {a[l]}; else { ll mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int l, int r, int ql, int qr, tag t) { if(l == ql &amp;&amp; r == qr) { settag(u, t); return ; } ll mid = l + r &gt;&gt; 1; pushdown(u); if(qr &lt;= mid) modify(u &lt;&lt; 1, l, mid, ql, qr, t); else if(ql &gt; mid) modify(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr, t); else { modify(u &lt;&lt; 1, l, mid, ql, mid, t); modify(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr, t); } pushup(u); } info query(int u, int l, int r, int ql, int qr) { if(l == ql &amp;&amp; r == qr) return tr[u].val; ll mid = l + r &gt;&gt; 1; pushdown(u); if(qr &lt;= mid) query(u &lt;&lt; 1, l, mid, ql, qr); else if(ql &gt; mid) query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr); else { return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 1, n); while(q --) { int op; scanf(&quot;%d&quot;, &amp;op); if(op == 1) { int l, r, d; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d); modify(1, 1, n, l, r, (tag){d}); } else { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); auto a = query(1, 1, n, l, r); printf(&quot;%lld\\n&quot;, a.maxv); } } return 0; } åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢çº¿æ®µæ ‘ï¼ˆå¤æ‚æ ‡è®°ï¼‰ #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10, mod = 1e9 + 7; typedef long long ll; ll n, q; ll a[N]; struct tag { ll mul, add; }; tag operator + (const tag &amp;t1, const tag &amp;t2) { return {t1.mul * t2.mul % mod, (t1.add * t2.mul + t2.add) % mod}; } struct node { tag t; ll val; int siz; }tr[N * 4]; void pushup(int u) { tr[u].val = (tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val) % mod; } void settag(int u, tag t) { tr[u].val = (tr[u].val * t.mul + tr[u].siz * t.add) % mod; tr[u].t = tr[u].t + t; } void pushdown(int u) { if(tr[u].t.mul != 1 || tr[u].t.add != 0) { settag(u &lt;&lt; 1, tr[u].t); settag(u &lt;&lt; 1 | 1, tr[u].t); tr[u].t.add = 0; tr[u].t.mul = 1; } } void build(int u, int l, int r) { tr[u].t = {1, 0}; tr[u].siz = r - l + 1; if(l == r) tr[u].val = {a[l]}; else { ll mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int l, int r, int ql, int qr, tag t) { if(l == ql &amp;&amp; r == qr) { settag(u, t); return ; } ll mid = l + r &gt;&gt; 1; pushdown(u); if(qr &lt;= mid) modify(u &lt;&lt; 1, l, mid, ql, qr, t); else if(ql &gt; mid) modify(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr, t); else { modify(u &lt;&lt; 1, l, mid, ql, mid, t); modify(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr, t); } pushup(u); } ll query(int u, int l, int r, int ql, int qr) { if(l == ql &amp;&amp; r == qr) return tr[u].val; ll mid = l + r &gt;&gt; 1; pushdown(u); if(qr &lt;= mid) query(u &lt;&lt; 1, l, mid, ql, qr); else if(ql &gt; mid) query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr); else { return (query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr)) % mod; } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 1, n); while(q --) { int op; scanf(&quot;%d&quot;, &amp;op); if(op &lt;= 3) { int l, r, d; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d); if(op == 1) modify(1, 1, n, l, r, (tag){1, d}); if(op == 2) modify(1, 1, n, l, r, (tag){d, 0}); if(op == 3) modify(1, 1, n, l, r, (tag){0, d}); } else { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); ll res = query(1, 1, n, l, r); printf(&quot;%lld\\n&quot;, res); } } return 0; } 4. çº¿æ®µæ ‘ä¸ŠäºŒåˆ† 5. æ‰«æçº¿ä¸æƒå€¼çº¿æ®µæ ‘","categories":[],"tags":[],"keywords":[]},{"title":"AtCoderBeginnerContest046é¢˜è§£","slug":"AtCoderBeginnerContest046é¢˜è§£","date":"2022-10-15T14:12:03.000Z","updated":"2022-10-15T14:13:42.735Z","comments":true,"path":"2022/10/15/AtCoderBeginnerContest046é¢˜è§£/","link":"","permalink":"https://memsetray.github.io/2022/10/15/AtCoderBeginnerContest046é¢˜è§£/","excerpt":"","text":"AtCoder Beginner Contest 046 é¢˜è§£ A - AtCoDeer and Paint Cans ç»™å®šä¸‰ä¸ªæ•°ï¼Œæ±‚è¿™ä¸‰ä¸ªæ•°ä¸­æœ‰å¤šå°‘ä¸ªæ•°æ˜¯é‡å¤çš„ã€‚ å¼€ä¸€ä¸ªæ¡¶ç»Ÿè®¡å³å¯ã€‚ AC ä»£ç  #include&lt;bits/stdc++.h&gt; using namespace std; map&lt;int, int&gt; m; int main() { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; m[a] ++, m[b] ++, m[c] ++; int t = max(max(m[a], m[b]), m[c]); if(t == 1) cout &lt;&lt; 3 &lt;&lt; endl; else if(t == 2) cout &lt;&lt; 2 &lt;&lt; endl; else if(t == 3) cout &lt;&lt; 1 &lt;&lt; endl; return 0; } B - Painting Balls with AtCoDeer æœ‰nnnä¸ªçƒï¼Œç°åœ¨éœ€è¦ç”¨kkkç§é¢œè‰²ç»™æ¯ä¸ªçƒæŸ“è‰²ï¼Œè¦æ±‚ç›¸é‚»ä¸¤ä¸ªçƒçš„é¢œè‰²ä¸èƒ½ç›¸åŒï¼Œæ±‚å¯è¡Œçš„æ–¹æ¡ˆæ•°ã€‚ ç¬¬ä¸€æ¬¡å¯ä»¥ä½¿ç”¨å…¨éƒ¨kkkä¸ªé¢œè‰²ï¼Œä¹‹åæ¯æ¬¡éƒ½ä¸èƒ½ä½¿ç”¨ä¸Šä¸€æ¬¡çš„é¢œè‰²ï¼Œå› æ­¤åªèƒ½ä½¿ç”¨kâˆ’1k - 1kâˆ’1ç§é¢œè‰²ï¼Œæ ¹æ®ä¹˜æ³•åŸç†ï¼Œå°†å…¶ç´¯ä¹˜èµ·æ¥å³å¯ã€‚ AC ä»£ç  #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; signed main() { int n, k; cin &gt;&gt; n &gt;&gt; k; int res = 0; for(int i = 1; i &lt;= n; i ++) { if(i == 1) res += k; else { res *= (k - 1); } } cout &lt;&lt; res &lt;&lt; endl; return 0; } C - AtCoDeer and Election Report ç»™å®šnnnå’Œnnnå¯¹æ­£æ•´æ•°Ti,AiT_i,A_iTiâ€‹,Aiâ€‹ï¼Œå·²çŸ¥æ­£æ•´æ•°æ•°åˆ—ti,ait_i,a_itiâ€‹,aiâ€‹æ»¡è¶³ä¸€ä¸‹æ¡ä»¶ï¼š tiâ‰¤ti+1,aiâ‰¤ai+1t_i \\leq t_{i + 1}, a_i \\leq a_{i + 1}tiâ€‹â‰¤ti+1â€‹,aiâ€‹â‰¤ai+1â€‹ ti/ai=Ti/Ait_i / a_i = T_i / A_itiâ€‹/aiâ€‹=Tiâ€‹/Aiâ€‹ æ±‚tn+ant_n + a_ntnâ€‹+anâ€‹çš„æœ€å°å€¼ã€‚ AC ä»£ç  #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 1010; int a[N], t[N]; int ceill(int u, int v) { return (u - 1) / v + 1; } signed main() { int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; t[i] &gt;&gt; a[i]; } int u = t[1], v = a[1]; for(int i = 2; i &lt;= n; i ++) { u = t[i] * ceill(u, t[i]); v = a[i] * ceill(v, a[i]); if(u / t[i] &lt; v / a[i]) u = v / a[i] * t[i]; else v = u / t[i] * a[i]; } cout &lt;&lt; u + v &lt;&lt; endl; return 0; } AtCoDeer and Rock-Paper ä½ å’Œå¯¹æ‰‹éƒ½åªæœ‰ä¸¤ç§å‡ºæ‹³æ–¹å¼ï¼šçŸ³å¤´(g)(g)(g)å’Œå¸ƒ(p)(p)(p)ï¼Œå¸ƒå¯ä»¥æˆ˜èƒœçŸ³å¤´ï¼Œèµ¢äº†å¾—ä¸€åˆ†ï¼Œè¾“äº†æ‰£ä¸€åˆ†ï¼Œå¹³å±€å¾—000åˆ†ï¼Œç°åœ¨ç»™ä½ å¯¹æ‰‹çš„å‡ºæ‹³æ–¹å¼ï¼Œè®¾ä½ åˆ°ç¬¬iiiæ¬¡å‡ºæ‹³å…±å‡ºäº†xix_ixiâ€‹æ¬¡çŸ³å¤´ï¼Œyiy_iyiâ€‹æ¬¡å¸ƒï¼Œåœ¨å¯¹äºä»»æ„ä½ç½®iiiæ»¡è¶³xiâ‰¥yix_i \\geq y_ixiâ€‹â‰¥yiâ€‹çš„æ¡ä»¶ä¸‹ï¼Œè¾“å‡ºä½ èƒ½å¾—åˆ°çš„æœ€å¤§åˆ†æ•°ã€‚ è´ªå¿ƒï¼Œé¦–å…ˆåœ¨æ»¡è¶³æ¡ä»¶çš„æƒ…å†µä¸‹ï¼Œå‡ºæ‹³æˆ–å¸ƒçš„å…ˆåé¡ºåºå¯¹ç­”æ¡ˆæ²¡æœ‰å½±å“ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥æŒ‰æ¯ä¸€ä½è€ƒè™‘ï¼Œæˆ‘ä»¬ç»Ÿè®¡ä¹‹å‰å‡ºæ‹³å’Œå‡ºå¸ƒçš„æ¬¡æ•°ï¼Œç„¶åå¯¹äºå½“å‰å¯¹æ‰‹çš„å‡ºæ³•ï¼Œæˆ‘ä»¬è€ƒè™‘ï¼š å¦‚æœå¯¹æ‰‹æ­¤æ—¶å‡ºæ‹³ï¼šå¦‚æœæˆ‘ä»¬æ­¤æ—¶å¯ä»¥å‡ºå¸ƒï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å‡ºå¸ƒï¼Œå¦åˆ™å‡ºæ‹³ å¦‚æœå¯¹æ‰‹æ­¤æ—¶å‡ºå¸ƒï¼Œå¦‚æœæˆ‘ä»¬æ­¤æ—¶å¯ä»¥å‡ºå¸ƒï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å‡ºå¸ƒï¼Œå¦åˆ™å‡ºæ‹³ã€‚ æ¨¡æ‹Ÿä¸€ä¸‹å³å¯ã€‚ AC ä»£ç  #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 1e5 + 10; string s; int main() { cin &gt;&gt; s; int cnt_g = 0, cnt_p = 0; int res = 0; for(int i = 0; i &lt; s.size(); i ++) { if(s[i] == 'g') { if(cnt_p &lt; cnt_g) { res ++; cnt_p ++; } else cnt_g ++; } else if(s[i] == 'p') { if(cnt_p &lt; cnt_g) { cnt_p ++; } else { res --; cnt_g ++; } } } cout &lt;&lt; res &lt;&lt; endl; return 0; }","categories":[],"tags":[],"keywords":[]},{"title":"æ ‘å½¢DPç¬”è®°","slug":"æ ‘å½¢DPç¬”è®°","date":"2022-10-14T18:31:45.000Z","updated":"2022-10-15T11:15:43.252Z","comments":true,"path":"2022/10/15/æ ‘å½¢DPç¬”è®°/","link":"","permalink":"https://memsetray.github.io/2022/10/15/æ ‘å½¢DPç¬”è®°/","excerpt":"","text":"æ ‘å½¢DPç¬”è®° 1. æ ‘å½¢èƒŒåŒ… ç»™å®šä¸€ä¸ªnnnä¸ªç‚¹çš„æœ‰æ ¹æ ‘ï¼Œå…¶ä¸­111å·ç‚¹ä¸ºæ ¹èŠ‚ç‚¹ï¼Œæ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªæƒå€¼aia_iaiâ€‹ï¼Œæƒå€¼å¯èƒ½ä¸ºè´Ÿæ•°ã€‚ ä½ éœ€è¦å›ç­”qqqä¸ªè¯¢é—®ï¼Œåœ¨uuuçš„å­æ ‘ä¸­ï¼Œé€‰æ‹©ä¸€ä¸ªå¤§å°æ°å¥½ä¸ºmmmçš„åŒ…å«uuuç‚¹çš„è¿é€šå—ï¼Œæœ€å¤§çš„æƒå€¼å’Œã€‚ä¿è¯mmmä¸ä¼šè¶…è¿‡uuuçš„å­æ ‘å¤§å°ã€‚ æ•°æ®èŒƒå›´ï¼š 1â‰¤nâ‰¤20001 \\leq n \\leq 20001â‰¤nâ‰¤2000 âˆ’105â‰¤aiâ‰¤105-10^5 \\leq a_i \\leq 10^5âˆ’105â‰¤aiâ€‹â‰¤105 1â‰¤mâ‰¤n1 \\leq m \\leq n1â‰¤mâ‰¤n 1â‰¤qâ‰¤1051 \\leq q \\leq 10^51â‰¤qâ‰¤105 è€ƒè™‘DPï¼Œè®¾dp[i][j]dp[i][j]dp[i][j]è¡¨ç¤ºä»ä»¥iiiä¸ºæ ¹çš„å­æ ‘é‡Œé€‰jjjä¸ªç‚¹ä¸”åŒ…å«iiiç‚¹ï¼Œæƒå€¼çš„æœ€å¤§å€¼ã€‚ å¾ˆæ˜æ˜¾çš„èƒŒåŒ…é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦æŠŠä¸åŒå„¿å­çš„èƒŒåŒ…åˆå¹¶ï¼Œè€ƒè™‘æ ‘å½¢DPæ—¶å¦‚ä½•æ›´æ–°çŠ¶æ€ æšä¸¾å·²ç»éå†è¿‡çš„è¿é€šå—ä¸­é€‰æ‹©iiiä¸ªç‚¹ï¼Œåœ¨å½“å‰æšä¸¾åˆ°çš„å­æ ‘ä¸­é€‰æ‹©jjjä¸ªç‚¹ï¼Œå°†å®ƒä»¬çš„å’Œdp[u][i]+dp[v][j]dp[u][i] + dp[v][j]dp[u][i]+dp[v][j]å­˜å…¥temptemptempæ•°ç»„ä¸­ï¼Œæœ€åç”¨temptemptempçš„å€¼æ•´ä½“æ›´æ–°dpdpdpæ•°ç»„çš„å€¼ã€‚ ç”±æ­¤å¯è§ï¼Œæ¯æ¬¡åˆå¹¶ä¸¤ä¸ªèƒŒåŒ…éƒ½éœ€è¦ä¸€ä¸ªåŒé‡å¾ªç¯ï¼Œè¡¨é¢ä¸Šæ—¶é—´å¤æ‚åº¦ä¸ºO(n3)O(n^3)O(n3)ï¼Œç„¶è€Œå®é™…ä¸Šæ—¶é—´å¤æ‚åº¦åªæœ‰O(n2)O(n^2)O(n2) å‡è®¾æˆ‘ä»¬å½“å‰åˆå¹¶çš„ä¸¤ä¸ªèƒŒåŒ…çš„å¤§å°ä¸ºsizeuå’Œsizevsize_uå’Œsize_vsizeuâ€‹å’Œsizevâ€‹ï¼Œé‚£ä¹ˆåˆå¹¶è¿™ä¸¤ä¸ªèƒŒåŒ…çš„å¤æ‚åº¦æ˜¯O(sizeuÃ—sizev)O(size_u Ã— size_v)O(sizeuâ€‹Ã—sizevâ€‹)çš„ æˆ‘ä»¬è€ƒè™‘æ•°å­¦å«ä¹‰ï¼Œå¯ä»¥ç†è§£ä¸ºå½“ä¸¤ä¸ªèƒŒåŒ…åˆå¹¶æ—¶ï¼Œæ¯å¯¹å…ƒç´ éƒ½è´¡çŒ®äº†111çš„ä»£ä»·ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå½“ä¸¤ä¸ªå­æ ‘åˆå¹¶çš„æ—¶å€™ï¼Œæ¯å¯¹ç‚¹éƒ½è´¡çŒ®äº†111çš„è´¡çŒ®ã€‚ é‚£ä¹ˆå¯¹äºä»»æ„ä¸€å¯¹ç‚¹ï¼Œå®ƒä»¬åªä¼šåšå‡ºä¸€æ¬¡è´¡çŒ®ï¼Œè¢«åˆå¹¶ä¸€æ¬¡ï¼Œæ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(n2)O(n^2)O(n2)ã€‚ AC ä»£ç  #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2010; int n, m, q; vector&lt;int&gt; son[N]; int a[N]; int dp[N][N]; int sz[N]; int temp[N]; void dfs(int u) { sz[u] = 0; for(auto v : son[u]) { dfs(v); for(int i = 0; i &lt;= sz[u] + sz[v]; i ++) temp[i] = -0x3f3f3f3f; for(int i = 0; i &lt;= sz[u]; i ++) { for(int j = 0; j &lt;= sz[v]; j ++) temp[i + j] = max(temp[i + j], dp[u][i] + dp[v][j]); } for(int i = 0; i &lt;= sz[u] + sz[v]; i ++) dp[u][i] = temp[i]; sz[u] += sz[v]; } sz[u] ++; for(int i = sz[u]; i &gt;= 1; i --) dp[u][i] = dp[u][i - 1] + a[u]; } void solve() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;q); for(int i = 2; i &lt;= n; i ++) { int t; scanf(&quot;%lld&quot;, &amp;t); son[t].push_back(i); } for(int i = 1; i &lt;= n; i ++) scanf(&quot;%lld&quot;, &amp;a[i]); dfs(1); while(q --) { int u, m; scanf(&quot;%lld%lld&quot;, &amp;u, &amp;m); printf(&quot;%lld\\n&quot;, dp[u][m]); } } signed main() { //ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } å˜å¼1ï¼š ä¸Šè¿°é—®é¢˜çš„æ•°æ®èŒƒå›´æ›´æ”¹æˆï¼š 1â‰¤nâ‰¤500001 \\leq n \\leq 500001â‰¤nâ‰¤50000 1â‰¤mâ‰¤1001 \\leq m \\leq 1001â‰¤mâ‰¤100 å…¶ä»–æ¡ä»¶ä¸å˜ ç»§ç»­è®¾dp[i][j]dp[i][j]dp[i][j]è¡¨ç¤ºåœ¨iiiè¿™ä¸ªå­æ ‘é‡Œé¢é€‰äº†jjjä¸ªç‚¹ï¼Œå¹¶ä¸”åŒ…å«iiiç‚¹çš„æœ€å¤§æƒå€¼å’Œ å¯¹äºè¿™é“é¢˜ï¼Œç»´åº¦jjjåªéœ€è¦éå†åˆ°mmmå³å¯ï¼Œæ—¶é—´å¤æ‚åº¦O(nm)O(nm)O(nm) AC ä»£ç  #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 50010, M = 100, INF = 2e9; vector&lt;int&gt; son[N]; int dp[N][M + 10]; int sz[N]; int n, q; int temp[N]; int w[N]; void dfs(int u) { sz[u] = 0; for(auto v : son[u]) { dfs(v); for(int i = 0; i &lt;= sz[u] + sz[v] &amp;&amp; i &lt;= M; i ++) temp[i] = -INF; for(int i = 0; i &lt;= sz[u] &amp;&amp; i &lt;= M; i ++) { for(int j = 0; j &lt;= sz[v] &amp;&amp; i + j &lt;= M; j ++) temp[i + j] = max(temp[i + j], dp[u][i] + dp[v][j]); } for(int i = 0; i &lt;= sz[u] + sz[v] &amp;&amp; i &lt;= M; i ++) dp[u][i] = temp[i]; sz[u] += sz[v]; } sz[u] ++; for(int i = min(sz[u], M); i &gt;= 1; i --) dp[u][i] = dp[u][i - 1] + w[u]; dp[u][0] = 0; } void solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 2; i &lt;= n; i ++) { int x; scanf(&quot;%d&quot;, &amp;x); son[x].push_back(i); } for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;w[i]); dfs(1); while(q --) { int u, m; scanf(&quot;%d%d&quot;, &amp;u, &amp;m); printf(&quot;%d\\n&quot;, dp[u][m]); } } int main() { //ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } å˜å¼2ï¼š ç»™ä½ ä¸€ä¸ªnnnä¸ªç‚¹çš„æœ‰æ ¹æ ‘ï¼Œå…¶ä¸­111å·ç‚¹ä¸ºæ ¹ï¼Œæ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªæƒå€¼aia_iaiâ€‹å’Œé‡é‡wiw_iwiâ€‹ã€‚ ä½ éœ€è¦é€‰æ‹©ä¸€ä¸ªé‡é‡æ°å¥½ä¸ºkkkçš„åŒ…å«æ ¹çš„è¿é€šå—ï¼Œä¸”æƒå€¼å’Œæœ€å¤§ã€‚ å¯¹æ‰€æœ‰çš„k=0,1,2,...,mk = 0,1,2,...,mk=0,1,2,...,mè¾“å‡ºç­”æ¡ˆï¼Œä¸å­˜åœ¨åˆ™è¾“å‡º000 æ•°æ®èŒƒå›´ï¼š 1â‰¤nâ‰¤10001 \\leq n \\leq 10001â‰¤nâ‰¤1000 1â‰¤aiâ‰¤1051 \\leq a_i \\leq 10^51â‰¤aiâ€‹â‰¤105 1â‰¤wiâ‰¤1051 \\leq w_i \\leq 10^51â‰¤wiâ€‹â‰¤105 1â‰¤mâ‰¤100001 \\leq m \\leq 100001â‰¤mâ‰¤10000 æ›´åŠ æ ‡å‡†çš„æ ‘ä¸Š01èƒŒåŒ…é—®é¢˜ï¼Œå¦‚æœæˆ‘ä»¬ä»ç„¶åƒå‰ä¸¤é“é¢˜ä¸€æ ·è®¾è®¡DPçŠ¶æ€ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ‰§è¡Œåˆå¹¶ä¸¤ä¸ªå­æ ‘èƒŒåŒ…çš„æ“ä½œæ—¶ï¼Œç”±äºæ¯ä¸ªç‰©å“éƒ½æœ‰é‡é‡ï¼Œæ‰€ä»¥ä¸€ä¸ªå­æ ‘å¯èƒ½èŠ‚ç‚¹ä¸ªæ•°å¾ˆå°‘ï¼Œä½†æ˜¯çŠ¶æ€å¾ˆå¤šï¼ˆé‡é‡å¯èƒ½å¾ˆå¤§å¯¼è‡´ç¬¬äºŒç»´å¾ˆå¤§ï¼‰ï¼Œå› æ­¤æ— æ³•åƒä¹‹å‰ä¸€æ ·ä¿è¯æ—¶é—´å¤æ‚åº¦ã€‚ å› æ­¤è¦ä½¿ç”¨ç‰¹æ®Šçš„æŠ€å·§ï¼šåœ¨DFSDFSDFSåºä¸ŠåšDP æ±‚å‡ºæ•´æ£µæ ‘çš„DFSDFSDFSåºï¼Œè®¾rxr_xrxâ€‹è¡¨ç¤ºDFSDFSDFSåºä¸­è·³è¿‡xxxè¿™ä¸ªå­æ ‘çš„ä¸‹ä¸€ä¸ªä½ç½® eg:(1(2(3)(4))(5(6)(7)))eg:(1(2(3)(4))(5(6)(7)))eg:(1(2(3)(4))(5(6)(7)))ï¼Œåˆ™r2=5,r3=4,r5=8r_2 = 5, r_3 = 4, r_5 = 8r2â€‹=5,r3â€‹=4,r5â€‹=8 æˆ‘ä»¬ä»åå¾€å‰åšï¼Œè®¾dp[i][j]dp[i][j]dp[i][j]è¡¨ç¤ºè€ƒè™‘DFSDFSDFSåºä¸­[i,n][i,n][i,n]è¿™ä¸€æ®µèŠ‚ç‚¹ï¼Œé€‰çš„é‡é‡å’Œä¸è¶…è¿‡jjjçš„æœ€å¤§æƒå€¼å’Œï¼ŒåŒæ—¶æ»¡è¶³ä¸å­˜åœ¨ä¸€ä¸ªç‚¹é€‰äº†ï¼Œä½†æ˜¯å®ƒçš„ç¥–å…ˆæ²¡æœ‰è¢«é€‰çš„æƒ…å†µã€‚ çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šdp[i][j]=max(dp[ri][j],f[i+1][jâˆ’wi]+vi)dp[i][j] = max(dp[r_i][j], f[i + 1][j - w_i] + v_i)dp[i][j]=max(dp[riâ€‹][j],f[i+1][jâˆ’wiâ€‹]+viâ€‹) å³ï¼šå¦‚æœä¸é€‰è¿™ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆæ•´ä¸ªå­æ ‘éƒ½ä¼šè¢«è·³è¿‡ï¼Œä»rir_iriâ€‹è½¬ç§»è¿‡æ¥ï¼Œå¦åˆ™è€ƒè™‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦O(nm)O(nm)O(nm)ã€‚ AC ä»£ç  #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 2010, INF = 2e9; int w[N]; int n, m; int dp[N][N]; vector&lt;int&gt; son[N]; int dfn[N], tot; int a[N]; int l[N], r[N]; int id[N]; void dfs(int u) { l[u] = ++ tot; id[tot] = u; for(auto v : son[u]) { dfs(v); } r[u] = tot; } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 2; i &lt;= n; i ++) { int x; scanf(&quot;%d&quot;, &amp;x); son[x].push_back(i); } for(int i = 1; i &lt;= m; i ++) dp[n + 1][i] = -INF; for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;w[i]); dfs(1); for(int i = n; i &gt;= 1; i --) { int u = id[i]; for(int j = 0; j &lt;= m; j ++) { dp[i][j] = dp[r[u] + 1][j]; if(j &gt;= w[u]) dp[i][j] = max(dp[i][j], dp[i + 1][j - w[u]] + a[u]); } } for(int i = 0; i &lt;= m; i ++) if(dp[1][i] &gt;= 0) printf(&quot;%d\\n&quot;, dp[1][i]); else printf(&quot;0\\n&quot;); } &lt;/details&gt; 2.æ ‘ä¸Šè·¯å¾„ ç»™ä½ ä¸€ä¸ªnnnä¸ªç‚¹çš„æ ‘ã€‚ ç»™ä½ mmmæ¡æ ‘ä¸Šçš„ç®€å•è·¯å¾„ï¼Œæ¯ä¸ªè·¯å¾„éƒ½æœ‰ä¸€ä¸ªæƒå€¼aia_iaiâ€‹ï¼Œè¦æ±‚é€‰æ‹©ä¸€äº›è·¯å¾„ï¼Œä½¿å¾—æ¯ä¸ªç‚¹è‡³å¤šåœ¨ä¸€æ¡è·¯å¾„ä¸Šï¼Œå¹¶ä¸”è·¯å¾„çš„æƒå€¼å’Œæœ€å¤§ã€‚ æ•°æ®èŒƒå›´ï¼š 1â‰¤nâ‰¤20001 \\leq n \\leq 20001â‰¤nâ‰¤2000 1â‰¤mâ‰¤20001 \\leq m \\leq 20001â‰¤mâ‰¤2000 1â‰¤aiâ‰¤1091 \\leq a_i \\leq 10^91â‰¤aiâ€‹â‰¤109 æˆ‘ä»¬è€ƒè™‘åœ¨ä¸¤ä¸ªç‚¹çš„LCALCALCAå¤„å†³å®šè¿™æ¡è·¯å¾„æ˜¯å¦é€‰æ‹©ã€‚ è®¾dp[i]dp[i]dp[i]è¡¨ç¤ºè€ƒè™‘æ‰€æœ‰åœ¨iiiä¸ºæ ¹çš„å­æ ‘é‡Œçš„æ‰€æœ‰è·¯å¾„çš„æœ€å¤§æƒå€¼å’Œã€‚ æ¯æ¬¡è½¬ç§»çš„æ—¶å€™ï¼Œå¯¹äºç‚¹iiiï¼Œè€ƒè™‘æ‰€æœ‰LCALCALCAä¸ºiiiç‚¹çš„è·¯å¾„ï¼Œå¦‚æœé€‰æ‹©è¿™æ¡è·¯å¾„å°±ç›¸å½“äºåˆ é™¤è¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰çš„ç‚¹ï¼Œæ•´ä¸ªå­æ ‘è¢«æ‹†æˆä¸€ä¸ªæ£®æ—ï¼Œå°†è¿™äº›ç‚¹çš„dpdpdpå€¼åŠ ä¸Šè·¯å¾„çš„æƒå€¼å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦O(nm)O(nm)O(nm)ã€‚ AC ä»£ç  #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 2010; int n, m; vector&lt;int&gt; son[N]; vector&lt;array&lt;int, 3&gt;&gt; path[N]; int dp[N]; int son_dp[N]; int depth[N]; int f[N]; void dfs(int u) { for(auto v : son[u]) { dfs(v); son_dp[u] += dp[v]; //æ‰€æœ‰å„¿å­èŠ‚ç‚¹çš„DPå€¼ä¹‹å’Œ } dp[u] = son_dp[u]; //ä¸é€‰uï¼ŒDPå€¼å°±æ˜¯å„¿å­èŠ‚ç‚¹çš„DPå€¼ä¹‹å’Œ for(auto p : path[u]) //é€‰uï¼Œè€ƒè™‘LCAä¸Šçš„ä¸€æ¡è·¯å¾„ { int temp = son_dp[u]; int x = p[0]; while(x != u) { temp += son_dp[x] - dp[x]; x = f[x]; } x = p[1]; while(x != u) { temp += son_dp[x] - dp[x]; x = f[x]; } temp += p[2]; dp[u] = max(dp[u], temp); } } signed main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 2; i &lt;= n; i ++) { scanf(&quot;%lld&quot;, &amp;f[i]); son[f[i]].push_back(i); depth[i] = depth[f[i]] + 1; } for(int i = 1; i &lt;= m; i ++) { int u, v, a; scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;a); int x = u, y = v; while(x != y) { if(depth[x] &gt; depth[y]) x = f[x]; else y = f[y]; } path[x].push_back({u, v, a}); } dfs(1); printf(&quot;%lld\\n&quot;, dp[1]); return 0; } å˜å¼1ï¼š ç»™ä½ ä¸€ä¸ªnnnä¸ªç‚¹çš„æ ‘ã€‚ ç»™ä½ mmmæ¡æ ‘ä¸Šçš„ç®€å•è·¯å¾„ï¼Œæ¯ä¸ªè·¯å¾„éƒ½æœ‰æƒå€¼aia_iaiâ€‹ï¼Œä¿è¯æ¯æ¡è·¯å¾„éƒ½æ˜¯ä»ä¸€ä¸ªç‚¹åˆ°å®ƒçš„ç¥–å…ˆ è¦æ±‚é€‰æ‹©ä¸€äº›è·¯å¾„ï¼Œä½¿å¾—æ¯ä¸ªç‚¹è‡³å°‘åœ¨ä¸€æ¡è·¯å¾„ä¸Šï¼Œå¹¶ä¸”è·¯å¾„çš„æƒå€¼å’Œæœ€å°ï¼Œå¦‚æœä¸å­˜åœ¨è¾“å‡ºâˆ’1-1âˆ’1 æ•°æ®èŒƒå›´åŒä¸Š è¿™é“é¢˜ä¸€ä¸ªç‚¹å¯èƒ½ä¼šåœ¨å¤šæ¡è·¯å¾„ä¸Šé¢ï¼Œå› æ­¤æˆ‘ä»¬ä¸èƒ½ç›´æ¥è®°å½•åœ¨å“ªäº›è·¯å¾„ä¸Šã€‚ ç„¶è€Œå¦‚æœæœ‰ç‚¹uuuåœ¨å¾ˆå¤šæ¡è·¯å¾„ä¸Šé¢ï¼Œé‚£ä¹ˆæˆ‘ä»¬å®é™…ä¸Šåªè¦çŸ¥é“è¿™äº›è·¯å¾„æœ€å¤šèƒ½å¾€ä¸Šä¼¸å¤šå°‘å³å¯ã€‚ è®¾dp[i][j]dp[i][j]dp[i][j]è¡¨ç¤ºè€ƒè™‘iiiè¿™ä¸ªå­æ ‘é‡Œé¢é€‰æ‹©çš„è·¯å¾„ï¼Œæœ€å¤šå»¶ä¼¸åˆ°æ·±åº¦ä¸ºjjjçš„ä½ç½®æœ€å°çš„æƒå€¼å’Œã€‚ åœ¨è½¬ç§»çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥æšä¸¾æ¯ä¸ªå„¿å­çš„è·¯å¾„æœ€å¤šå»¶ä¼¸åˆ°å¤šå°‘ï¼Œå–æ·±åº¦çš„minminminå³å¯ã€‚ ç„¶è€Œè¿™æ ·åšçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n3)O(n^3)O(n3)ï¼Œè€ƒè™‘ä¼˜åŒ–ã€‚ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‰ç¼€æœ€å°å€¼æ¥è¿›è¡Œä¼˜åŒ–ï¼Œæ—¶é—´å¤æ‚åº¦O(n2)O(n^2)O(n2)","categories":[],"tags":[],"keywords":[]},{"title":"CodeForces1700-2000éš¾åº¦éƒ¨åˆ†é¢˜é¢˜è§£","slug":"Codeforces1700-2000éš¾åº¦éƒ¨åˆ†é¢˜é¢˜è§£","date":"2022-09-06T14:36:37.000Z","updated":"2022-10-04T12:32:11.156Z","comments":true,"path":"2022/09/06/Codeforces1700-2000éš¾åº¦éƒ¨åˆ†é¢˜é¢˜è§£/","link":"","permalink":"https://memsetray.github.io/2022/09/06/Codeforces1700-2000éš¾åº¦éƒ¨åˆ†é¢˜é¢˜è§£/","excerpt":"","text":"Codeforces 1700-2000éš¾åº¦éƒ¨åˆ†é¢˜é¢˜è§£ 1721D -Maximum AND é¢˜ç›®å¤§æ„:ç»™å‡ºä¸¤ä¸ªé•¿åº¦ä¸ºnnnçš„æ•°ç»„a,ba,ba,bï¼Œè§„å®šf(a,b)f(a,b)f(a,b)è¡¨ç¤ºä»¥ä¸‹æ“ä½œï¼š åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸ºnnnçš„æ•°ç»„ï¼Œæ»¡è¶³ci=aiâŠ•bic_i=a_i \\oplus b_iciâ€‹=aiâ€‹âŠ•biâ€‹ åˆ™ f(a,b)=c1&amp;c2&amp;...&amp;cnf(a,b) = c_1 \\&amp; c_2 \\&amp;...\\&amp;c_nf(a,b)=c1â€‹&amp;c2â€‹&amp;...&amp;cnâ€‹ ä½ å¯ä»¥å°†bbbæ•°ç»„è¿›è¡Œä»»æ„çš„æ’åˆ—ï¼Œæ±‚æœ€å¤§çš„f(a,b)f(a,b)f(a,b) æ•°æ®èŒƒå›´ï¼š1â‰¤nâ‰¤1051 \\leq n \\leq 10^51â‰¤nâ‰¤105 é¢˜è§£ï¼šäºŒè¿›åˆ¶æ„é€ é¢˜ï¼Œé¦–å…ˆè€ƒè™‘äºŒè¿›åˆ¶æ‹†ä½ï¼Œç”±äºf(a,b)f(a,b)f(a,b)ç”±æŒ‰ä½ä¸æ“ä½œå¾—åˆ°ï¼Œå› æ­¤æŸä¸€ä½ä¸º111å¿…ç„¶æœ‰ï¼š âˆ€ci\\forall c_iâˆ€ciâ€‹ï¼Œè¯¥ä½çš„äºŒè¿›åˆ¶ä¸º111 åˆç”±äºci=aiâŠ•bic_i=a_i \\oplus b_iciâ€‹=aiâ€‹âŠ•biâ€‹ï¼Œåˆ™aiä¸bia_i ä¸ b_iaiâ€‹ä¸biâ€‹å¿…ç„¶åœ¨è¯¥ä½ä¸Šæ»¡è¶³ï¼š000çš„ä¸ªæ•°ä¸111çš„ä¸ªæ•°ç›¸åŒ ç”±æ­¤è€ƒè™‘è´ªå¿ƒï¼šä»é«˜ä½å‘ä½ä½æšä¸¾ï¼Œå¦‚æœæ»¡è¶³è¯¥ä½ä¸Š000ä¸111çš„ä¸ªæ•°ç›¸åŒï¼Œå°±é€‰å–è¿™ä¸€ä½ï¼Œä½†æ˜¯è¿™ç§è´ªå¿ƒæ–¹å¼æ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºï¼š 2 3 0 2 1 å¦‚æœæŒ‰ä¸Šè¿°æ–¹å¼é€‰å–ï¼Œä¼šå‘ç°bbbä¸­ä¸€å®šæœ‰ä¸€ä¸ªæ•°è¢«é€‰æ‹©äº†ä¸¤æ¬¡ï¼Œè¿™æ˜¾ç„¶æ˜¯ä¸åˆæ³•çš„ äºæ˜¯è¿›ä¸€æ­¥è€ƒè™‘ä¸€ä¸ªæ•°èƒ½è¢«é€‰å–çš„æ¡ä»¶ï¼Œä¸å¦¨è®¾ç­”æ¡ˆä¸ºresresres å¦‚æœå­˜åœ¨bbbçš„æ’åºï¼Œâˆ€ai\\forall a_iâˆ€aiâ€‹æœ‰(ai&amp;res)âŠ•(bi&amp;res)=res(a_i \\&amp; res) \\oplus (b_i \\&amp; res) = res(aiâ€‹&amp;res)âŠ•(biâ€‹&amp;res)=resï¼ˆå³å‰iiiä½ä¸­aaaä¸­1çš„ä¸ªæ•°ä¸bbbä¸­0çš„ä¸ªæ•°ç›¸åŒï¼‰ï¼Œåˆ™resresreså³ä¸ºç­”æ¡ˆã€‚ æˆ‘ä»¬è€ƒè™‘æ¯ä¸€ä½ï¼Œå°†å…¶å¼‚æˆ–resresres,å¹¶å°†ä¸¤ä¸ªå¾—åˆ°çš„æ•°ç»„æ’åºï¼Œå¦‚æœç›¸åŒï¼Œåˆ™è¯¥ä½ä¸º111ï¼Œå¦åˆ™ä¸º000 // Problem: D. Maximum AND // Contest: Codeforces - Educational Codeforces Round 134 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1721/D // Memory Limit: 256 MB // Time Limit: 3000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int n; int a[N]; int b[N]; bool check(int x) { vector&lt;int&gt; c, d; for(int i = 1; i &lt;= n; i ++) { c.push_back(a[i] &amp; x); d.push_back((b[i] &amp; x) ^ x); } sort(c.begin(), c.end()); sort(d.begin(), d.end()); return c == d; } void solve() { cin &gt;&gt; n; int res = 0; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; b[i]; for(int i = 30; i &gt;= 0; i --) { if(check(res | (1 &lt;&lt; i))) res |= (1 &lt;&lt; i); } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1718A1/A2 - Burenka and Traditions (easy version)+(hard version) é¢˜ç›®å¤§æ„ï¼šæœ‰ä¸€ä¸ªé•¿åº¦ä¸ºnnnçš„æ•°ç»„aaaï¼Œæ¯ä¸€æ¬¡æ“ä½œå¯ä»¥é€‰æ‹©ä¸€æ®µåŒºé—´[l,r][l,r][l,r]å’Œä¸€ä¸ªéè´Ÿæ•´æ•°xxxï¼ŒèŠ±è´¹[(râˆ’l+1)/2][(r - l + 1) / 2][(râˆ’l+1)/2]ç§’ä½¿åŒºé—´å†…çš„æ•°éƒ½å¼‚æˆ–xxxï¼Œé—®æœ€å°‘å‡ ç§’æ‰èƒ½æŠŠæ•°ç»„ä¸­æ‰€æœ‰å…ƒç´ å˜æˆ000 æ•°æ®èŒƒå›´ï¼š1â‰¤nâ‰¤50001 \\leq n \\leq 50001â‰¤nâ‰¤5000ï¼Œ0â‰¤aiâ‰¤50000 \\leq a_i \\leq 50000â‰¤aiâ€‹â‰¤5000 é¢˜è§£ï¼šæˆ‘ä»¬å¯ä»¥å¯¹æ“ä½œåšç­‰ä»·å˜å½¢ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°æ“ä½œå…¶å®å¯ä»¥åˆ†ä¸ºä¸¤ç§ï¼š å¼‚æˆ–ä¸€ä¸ªæ•°ï¼Œä»£ä»·ä¸º111 å¼‚æˆ–è¿ç»­ä¸¤ä¸ªæ•°ï¼Œä»£ä»·ä¸º111 æ˜¾ç„¶ï¼Œæˆ‘ä»¬è‡³å¤šå¯¹æ¯ä¸ªæ•°è¿›è¡Œä¸€æ¬¡ç¬¬ä¸€ç§æ“ä½œï¼Œç­”æ¡ˆè‡³å¤šä¸ºnnnï¼Œè€ƒè™‘ç¬¬äºŒç§æ“ä½œå¯¹ç­”æ¡ˆçš„å½±å“ï¼Œå¯ä»¥å‘ç°ï¼Œå¦‚æœä¸€æ®µè¿ç»­çš„æ•°å¼‚æˆ–ä¸º000ï¼Œé‚£ä¹ˆå°±å¯ä»¥è¿ç»­ç”¨ç¬¬äºŒç§æ“ä½œï¼Œæ¯ç”¨ä¸€æ¬¡ç¬¬äºŒç§æ“ä½œï¼Œç­”æ¡ˆå°±ä¼šå‡å°‘111ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç»´æŠ¤æ‰€æœ‰å¼‚æˆ–å’Œä¸º000çš„å—ï¼Œè¿™å¯å‘æˆ‘ä»¬è€ƒè™‘å‰ç¼€å’Œã€‚ å¯¹åŸæ•°ç»„æ±‚å‰ç¼€å¼‚æˆ–å’Œsumsumsumï¼Œå¦‚æœsum(1,l)=sum(1,r)sum(1,l)=sum(1,r)sum(1,l)=sum(1,r)ï¼Œè¯´æ˜æ­¤æ—¶å¯ä»¥ä½¿ç”¨ä¸€æ¬¡ç¬¬äºŒç§æ“ä½œï¼Œç­”æ¡ˆå‡å°‘111ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨mapmapmapæ¥ç»´æŠ¤å‰ç¼€å¼‚æˆ–å’Œçš„å€¼æ˜¯å¦å‡ºç°è¿‡ï¼Œæ³¨æ„ç‰¹åˆ¤000çš„æƒ…å†µå³å¯ã€‚ // Problem: A1. Burenka and Traditions (easy version) // Contest: Codeforces - Codeforces Round #814 (Div. 1) // URL: https://codeforces.com/problemset/problem/1718/A1 // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;string&gt; #define int long long using namespace std; void solve() { int n; cin &gt;&gt; n; int res = n; map&lt;int, int&gt; m; m[0] = 1; int seg = 0; for(int i = 1; i &lt;= n; i ++) { int x; cin &gt;&gt; x; seg ^= x; if(m.count(seg)) { res --; m.clear(); m[0] = 1; seg = 0; } else m[seg] = 1; } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1718B - Fibonacci Strings é¢˜ç›®å¤§æ„ï¼šç»™å®šä¸€ä¸ªæ•°åˆ—ck{c_k}ckâ€‹ ä½ å¯ä»¥æ‰§è¡Œè‹¥å¹²æ¬¡æ“ä½œï¼Œå¯¹äºç¬¬iiiæ¬¡æ“ä½œï¼š é€‰å®šä¸€ä¸ª[1,n][1,n][1,n]èŒƒå›´å†…çš„æ•´æ•°did_idiâ€‹ï¼Œå½“iâ‰¥2i \\geq 2iâ‰¥2æ—¶ï¼Œå¿…é¡»ä¿è¯diâ‰ diâˆ’1d_i \\neq d_{i - 1}diâ€‹î€ â€‹=diâˆ’1â€‹ã€‚ å°†cdic_{d_i}cdiâ€‹â€‹å‡å»fif_ifiâ€‹ï¼Œå…¶ä¸­fif_ifiâ€‹æ˜¯æ–æ³¢é‚£å¥‘æ•°åˆ—ä¸­ç¬¬iiié¡¹ é—®ï¼šc1c_1c1â€‹è‡³ckc_kckâ€‹èƒ½å¦å…¨ä¸º0ï¼Ÿ æ•°æ®èŒƒå›´ï¼š1â‰¤kâ‰¤1061 \\leq k \\leq 10^61â‰¤kâ‰¤106 é¢˜è§£ï¼šé¦–å…ˆå¯ä»¥è§‚å¯Ÿåˆ°ï¼Œåªæœ‰å½“âˆ‘i=1kci\\sum_{i = 1}^k c_iâˆ‘i=1kâ€‹ciâ€‹ç­‰äºæ–æ³¢é‚£å¥‘æ•°åˆ—æŸé¡¹çš„å‰ç¼€å’Œæ—¶ï¼Œæ‰æœ‰å¯èƒ½å…¨ä¸º0 ä¹‹åè€ƒè™‘å¦‚ä½•é€‰æ‹©æœ€ä¼˜è§£ ä¼˜å…ˆè€ƒè™‘æ’å…¥æœ€å°çš„æ•°åˆ°æœ€å°çš„æ–æ³¢é‚£å¥‘æ•° ä¼˜å…ˆè€ƒè™‘æ’å…¥æœ€å¤§çš„æ•°åˆ°æœ€å¤§çš„æ–æ³¢é‚£å¥‘æ•° æ˜¾ç„¶æ–¹æ¡ˆ2ä¸ºæœ€ä¼˜è§£ï¼Œæ³¨æ„ç‰¹åˆ¤æ¯æ¬¡ä¸èƒ½é€‰ä¸¤ä¸ªç›¸åŒçš„ä¸‹æ ‡æ’å…¥å³å¯ // Problem: B. Fibonacci Strings // Contest: Codeforces - Codeforces Round #814 (Div. 1) // URL: https://codeforces.com/problemset/problem/1718/B // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;queue&gt; #define int long long using namespace std; const int N = 2e5 + 10; typedef pair&lt;int, int&gt; PII; int a[N]; int feb[N]; int sum[N]; int idx = 0; void init() { feb[1] = 1; feb[2] = 1; sum[1] = 1; sum[2] = 2; for(int i = 3; i &lt;= 50; i ++) { feb[i] = feb[i - 1] + feb[i - 2]; sum[i] = sum[i - 1] + feb[i]; } } bool check(int s) { for(int i = 1; i &lt;= 50; i ++) { if(sum[i] == s) { idx = i; return true; } } return false; } void solve() { priority_queue&lt;PII, vector&lt;PII&gt; &gt; heap; idx = 0; int n; cin &gt;&gt; n; int s = 0; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; s += a[i]; heap.push({a[i], i}); } bool flag = 1; if(!check(s)) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return ; } int back = -1; for(int i = idx; i &gt;= 1; i --) { auto t = heap.top(); heap.pop(); if(t.second == back &amp;&amp; heap.size() &amp;&amp; heap.top().first != t.first) flag = 0; else if(t.second == back &amp;&amp; heap.size() &amp;&amp; heap.top().first == t.first) { auto tt = heap.top(); heap.pop(); heap.push(t); t = tt; } else if(t.second == back &amp;&amp; heap.empty()) flag = 0; if(t.first &gt;= feb[i]) { t.first -= feb[i]; heap.push(t); back = t.second; } else { flag = 0; break; } } if(flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; init(); while(T --) { solve(); } return 0; } 1716D - Chip Move é¢˜ç›®å¤§æ„ï¼šç»™å®šä¸¤ä¸ªæ•°n,kn,kn,kï¼Œé—®ä»000å¼€å§‹ï¼Œç¬¬iiiæ­¥åªèƒ½èµ°(k+iâˆ’1)(k + i - 1)(k+iâˆ’1)çš„å€æ•°ï¼Œé—®åˆ†åˆ«èµ°åˆ°xâˆˆ[1,n]x \\in [1,n]xâˆˆ[1,n]çš„æ–¹æ¡ˆæ•°ï¼Œå¯¹998244353å–æ¨¡ã€‚ æ•°æ®èŒƒå›´ï¼š1â‰¤kâ‰¤nâ‰¤2âˆ—1051 \\leq k \\leq n \\leq 2*10^51â‰¤kâ‰¤nâ‰¤2âˆ—105 é¢˜è§£ï¼šå¾…è¡¥å……â€¦ // Problem: D. Chip Move // Contest: Codeforces - Educational Codeforces Round 133 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1716/D // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10, mod = 998244353; int dp[2][N], res[N]; void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; int sum = k, id = 1; dp[0][0] = 1; for(int i = k; sum &lt;= n; i ++) { id ^= 1; for(int j = i; j &lt;= n; j ++) dp[id][j] = (dp[id][j] + dp[id ^ 1][j - i] + dp[id][j - i]) % mod; dp[id][0] = 0, sum += i; for(int j = 1; j &lt;= n; j ++) { res[j] = (res[j] + dp[id][j]) % mod; dp[id ^ 1][j] = 0; } } for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } 1716C - Robot in a Hallway é¢˜ç›®å¤§æ„ï¼š é¢˜è§£ï¼š // Problem: C. Robot in a Hallway // Contest: Codeforces - Educational Codeforces Round 133 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1716/C // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int a[2][N], f[2][N]; int n; void solve() { cin &gt;&gt; n; for(int i = 0; i &lt;= 1; i ++) for(int j = 1; j &lt;= n; j ++) cin &gt;&gt; a[i][j]; a[0][1] = -1; f[0][n] = a[0][n], f[1][n] = a[1][n]; for(int i = 0; i &lt;= 1; i ++) for(int j = n - 1; j &gt;= 1; j --) f[i][j] = max(f[i][j + 1] - 1, a[i][j]); f[0][n] = max(a[1][n] - 1, a[0][n]); f[1][n] = max(a[0][n] - 1, a[1][n]); for(int i = 0; i &lt;= 1; i ++) for(int j = n - 1; j &gt;= 1; j --) f[i][j] = max(f[i][j + 1] - 1, max(a[i][j], a[i ^ 1][j] - 2 * (n - j) - 1)); int res = f[0][1] + 2 * n, rec = a[1][1] + 1;; for(int i = 2, p = 1; i &lt;= n; i ++, p ^= 1) { res = min(res, rec + (f[p][i] - rec &gt; 0 ? f[p][i] - rec : 0ll) + 2 * (n - i + 1)); rec = max(rec + 1, a[p][i] + 1); rec = max(rec + 1, a[p ^ 1][i] + 1); } res = min(res, rec); cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1700D -River Locks é¢˜ç›®å¤§æ„ï¼š é¢˜è§£ï¼š // Problem: D.River Locks // Contest: Codeforces - Codeforces Round #802 (Div. 2) // URL: https://codeforces.com/problemset/problem/1700/D // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int a[N], s[N]; int n, q; void solve() { cin &gt;&gt; n; double mmax = 0; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; s[i] = s[i - 1] + a[i]; mmax = max(mmax, (double)s[i] / i); } cin &gt;&gt; q; while(q --) { int x; cin &gt;&gt; x; if(mmax - x &gt; 1e-7) { cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; continue; } cout &lt;&lt; (s[n] + x - 1) / x &lt;&lt; endl; } } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } 1695C - Zero Path é¢˜ç›®å¤§æ„ï¼š é¢˜è§£ï¼š // Problem: C. Zero Path // Contest: Codeforces - Codeforces Round #801 (Div. 2) and EPIC Institute of Technology Round // URL: https://codeforces.com/problemset/problem/1695/C // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 1010, INF = 0x3f3f3f3f; int a[N][N]; int pd[N][N]; int dp[N][N]; void solve() { int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) cin &gt;&gt; a[i][j]; if((n + m - 1) &amp; 1) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return ; } int h = (n + m - 1) / 2; dp[1][1] = (a[1][1] == 1); for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + (a[i][j] == 1); for(int i = 2; i &lt;= n; i ++) pd[i][0] = INF; for(int i = 2; i &lt;= m; i ++) pd[0][i] = INF; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) pd[i][j] = min(pd[i - 1][j], pd[i][j - 1]) + (a[i][j] == 1); if(h &gt;= pd[n][m] &amp;&amp; h &lt;= dp[n][m]) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1592C - Bakry and Partitioning é¢˜ç›®å¤§æ„ï¼š é¢˜è§£ï¼š // Problem: C. Bakry and Partitioning // Contest: Codeforces - Codeforces Round #746 (Div. 2) // URL: https://codeforces.com/problemset/problem/1592/C // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10, M = N * 2; int h[N], e[M], ne[M], w[N], idx; int n, k; int dp[N]; bool v[N]; void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } void dfs(int u, int val) { dp[u] = w[u]; for(int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if(v[j]) continue; v[j] = true; dfs(j, val); if(dp[j] != val) dp[u] ^= dp[j]; } } void solve() { cin &gt;&gt; n &gt;&gt; k; memset(v, 0, sizeof v); idx = 0; int sum = 0; for(int i = 1; i &lt;= n; i ++) { h[i] = -1; dp[i] = 0; cin &gt;&gt; w[i]; sum ^= w[i]; } for(int i = 1; i &lt;= n - 1; i ++) { int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); add(b, a); } if(sum == 0) { cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; return; } else if(k == 2) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return; } dfs(1, sum); int cnt = 0; for(int i = 1; i &lt;= n; i ++) cnt += dp[i] == sum; if(cnt &gt;= 2) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1454 - E Number of Simple Paths é¢˜ç›®å¤§æ„ï¼šç»™å®šä¸€é¢—åŸºç¯æ ‘ï¼Œæ±‚åŸºç¯æ ‘ä¸­é•¿åº¦å¤§äºç­‰äº111çš„ä¸åŒç®€å•è·¯å¾„çš„æ•°é‡ é¢˜è§£: // Problem: E. Number of Simple Paths // Contest: Codeforces - Codeforces Round #686 (Div. 3) // URL: https://codeforces.com/problemset/problem/1454/E // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;queue&gt; #define int long long using namespace std; const int N = 2e5 + 10, M = N * 2; int h[N], e[M], ne[M], idx; int siz[N]; int n; bool v[N]; int d[N]; void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } void topsort() { queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i ++) if(d[i] == 1) q.push(i); while(q.size()) { int t = q.front(); q.pop(); for(int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if(-- d[j] == 1) q.push(j); } } } void dfs(int u, int fa) { siz[u] = 1; for(int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if(j != fa) { dfs(j, u); siz[u] += siz[j]; } } } void solve() { cin &gt;&gt; n; int res = 0, t = 0;; for(int i = 1; i &lt;= n; i ++) { h[i] = -1; v[i] = 0; siz[i] = 0; idx = 0; d[i] = 0; } for(int i = 1; i &lt;= n; i ++) { int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); add(b, a); d[a] ++; d[b] ++; } topsort(); for(int i = 1; i &lt;= n; i ++) if(d[i] &gt; 1) v[i] = true; for(int i = 1; i &lt;= n; i ++) { if(v[i]) { t = 0; for(int j = h[i]; ~j; j = ne[j]) { int p = e[j]; if(!v[p]) { dfs(p, i); t += siz[p]; } } res += t; res += t * (t - 1) / 2; } } cout &lt;&lt; n * (n - 1) - res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1619G - Unusual Minesweeper é¢˜ç›®å¤§æ„ï¼š é¢˜è§£ï¼š // Problem: G. Unusual Minesweeper // Contest: Codeforces - Codeforces Round #762 (Div. 3) // URL: https://codeforces.com/problemset/problem/1619/G // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10, INF = 1e18; typedef pair&lt;int, int&gt; PII; int n, k; pair&lt;pair&lt;int, int&gt;, int&gt; poi[N]; int p[N], t[N]; int res[N]; int x, y, id, l, i, ii, nn; int find(int x) { if(p[x] != x) p[x] = find(p[x]); return p[x]; } void solve() { cin &gt;&gt; n &gt;&gt; k; for(i = 1; i &lt;= n; i ++) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; t[i]; poi[i] = {{x, y}, i}; p[i] = i; } for(ii = 0; ii &lt; 2; ii ++) { sort(poi + 1, poi + 1 + n); for(i = 1; i &lt;= n; i ++) { y = poi[i].first.first; x = poi[i].first.second; id = poi[i].second; if(i &gt; 1 &amp;&amp; y == poi[i - 1].first.first &amp;&amp; x - poi[i - 1].first.second &lt;= k) { l = poi[i - 1].second; t[find(id)] = min(t[find(id)], t[find(l)]); p[find(l)] = find(id); } } for(int i = 1; i &lt;= n; i ++) swap(poi[i].first.first, poi[i].first.second); } nn = 0; for(i = 1; i &lt;= n; i ++) { if(find(i) == i) { nn ++; res[nn] = t[i]; } } sort(res + 1, res + nn + 1, greater&lt;int&gt; ()); res[nn + 1] = -INF; for(i = 1; i &lt;= nn; i ++) if(res[i + 1] &lt;= i - 1) break; cout &lt;&lt; i - 1 &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1728D - Letter Picking é¢˜ç›®å¤§æ„ï¼š é¢˜è§£ï¼š // Problem: D. Letter Picking // Contest: Codeforces - Educational Codeforces Round 135 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1728/D // Memory Limit: 512 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; void solve() { string s; cin &gt;&gt; s; s = '_' + s; int n = s.size() - 1; int i = 1, j = n; while(i &lt; j) { if(s[i] == s[j]) { i ++, j --; } else break; } while(i &lt; j) { if(s[i] == s[i + 1]) i += 2; else if(s[j] == s[j - 1]) j -= 2; else break; } if(i &lt; j) cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Draw&quot; &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1722F - L-shapes é¢˜ç›®å¤§æ„ï¼š é¢˜è§£ï¼šè‹¥ä¸€ä¸ªç‚¹æ˜¯Lå½¢çš„ä¸€éƒ¨åˆ†ï¼Œå…ˆç”¨BFSå››è¿é€šæ‰¾æ­¤è¿é€šå—æ˜¯å¦æ˜¯Lå½¢ï¼Œå†æ‰¾æ­¤ç‚¹çš„å…«è¿é€šçœ‹æ˜¯å¦åªæœ‰ä¸¤ä¸ªLå½¢çš„ä¸€éƒ¨åˆ†ï¼Œè‹¥ä¸æ˜¯ï¼Œåˆ™ä¸åˆæ³•ã€‚ // Problem: F. L-shapes // Contest: Codeforces - Codeforces Round #817 (Div. 4) // URL: https://codeforces.com/problemset/problem/1722/F // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;queue&gt; #define int long long using namespace std; const int N = 110; char g[N][N]; int n, m; bool v[N][N]; int dx4[4] = {1, -1, 0, 0}, dy4[4] = {0, 0, 1, -1}; int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1}, dy8[8] = {-1, 0, 1, 1, -1, -1, 0, 1}; int bfs_4(int sx, int sy) //åˆ¤æ–­Lå‹ { if(v[sx][sy]) return 3; int cnt = 0; v[sx][sy] = 1; queue&lt;pair&lt;int, int&gt;&gt; q; q.push({sx, sy}); while(q.size()) { int x = q.front().first, y = q.front().second; q.pop(); cnt ++; for(int i = 0; i &lt; 4; i ++) { int zx = x + dx4[i], zy = y + dy4[i]; if(zx &amp;&amp; zy &amp;&amp; zx &lt;= n &amp;&amp; zy &lt;= m &amp;&amp; !v[zx][zy] &amp;&amp; g[zx][zy] == '*' &amp;&amp; abs(zx - sx) &lt;= 1 &amp;&amp; abs(zy - sy) &lt;= 1) { v[zx][zy] = 1; q.push({zx, zy}); } } } return cnt; } int bfs_8(int sx, int sy) { int cnt = 0; for(int i = 0; i &lt; 8; i ++) { int zx = sx + dx8[i], zy = sy + dy8[i]; if(zx &amp;&amp; zy &amp;&amp; zx &lt;= n &amp;&amp; zy &lt;= m &amp;&amp; g[zx][zy] == '*') cnt ++; } return cnt; } void solve() { memset(v, 0, sizeof v); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) cin &gt;&gt; g[i][j]; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) if(g[i][j] == '*') { int cnt4 = bfs_4(i, j); int cnt8 = bfs_8(i, j); if(cnt4 != 3 || cnt8 != 2) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return ; } } cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1647D Madoka and the Best School in Russia é¢˜ç›®å¤§æ„ï¼š å¦‚æœnnnæ˜¯dddçš„å€æ•°ï¼Œåˆ™ç§°nnnä¸ºâ€œå¥½æ•°â€ å¦‚æœnnnæ˜¯å¥½æ•°ä¸”ä¸èƒ½å†™æˆä»»æ„ä¸¤ä¸ªå¥½æ•°ä¹‹ç§¯ï¼Œåˆ™ç§°nnnæ˜¯ç¾ä¸½æ•° Tç»„è¯¢é—®ï¼Œæ¯ç»„è¯¢é—®ç»™å®šä¸¤ä¸ªæ­£æ•´æ•°x,dx,dx,dï¼Œé—®xxxæ˜¯å¦æœ‰è‡³å°‘ä¸¤ç§æ–¹å¼å†™ä¸ºè‡³å°‘ä¸€ä¸ªç¾ä¸½æ•°ä¹‹ç§¯ã€‚å¦‚æœæ˜¯ï¼Œè¾“å‡ºâ€œYESâ€ï¼Œå¦åˆ™è¾“å‡ºâ€œNOâ€ é¢˜è§£ï¼šåˆ†ç±»è®¨è®º ä»¤$x = d^k \\times s ï¼Œå…¶ä¸­ï¼Œå…¶ä¸­ï¼Œå…¶ä¸­k &gt; 0, d | sï¼ˆé¢˜ä¸­ï¼ˆé¢˜ä¸­ï¼ˆé¢˜ä¸­xä¸€å®šæ»¡è¶³æ˜¯ä¸€å®šæ»¡è¶³æ˜¯ä¸€å®šæ»¡è¶³æ˜¯d$çš„å€æ•°ï¼‰ åˆ™kâˆ’1k - 1kâˆ’1ä¸ªdddå’Œä¸€ä¸ªdÃ—sd \\times sdÃ—så³ä¸ºä¸€ç§åˆ†è§£æ–¹æ¡ˆ è€ƒè™‘k=1k = 1k=1ï¼Œåˆ™æ˜¾ç„¶ä¸åˆæ³• æ­¤æ—¶k&gt;1k &gt; 1k&gt;1 â€‹ è‹¥sssä¸ºåˆæ•°ï¼Œåˆ™å°†å…¶åˆ†è§£ä¸ºä¸¤ä¸ªæ•°ï¼Œåˆ†åˆ«ä¹˜åœ¨ä¸¤ä¸ªdddä¸Šï¼Œå¾—åˆ°ç¬¬äºŒç§æ–¹æ¡ˆ æ­¤æ—¶sssä¸ºè´¨æ•°æˆ–111ï¼Œæ˜¾ç„¶åªèƒ½æ‹†ddd â€‹ è‹¥dddä¸ºè´¨æ•°ï¼Œåˆ™dddæ— æ³•æ‹†ï¼Œä¸åˆæ³• â€‹ è‹¥dddå«æœ‰ä¸sssä¸åŒçš„è´¨å› æ•°ï¼Œå°†è¿™ä¸ªè´¨å› å­ä¹˜dddï¼Œå‰©ä¸‹çš„éƒ¨åˆ†ä¸sssä¹˜åœ¨å¦ä¸€ä¸ªdddä¸Šï¼Œå¾—åˆ°ç¬¬äºŒç§æ–¹æ¡ˆï¼Œæ­¤æ—¶éœ€è¦3ä¸ªdddï¼Œå³k&gt;2k &gt; 2k&gt;2 â€‹ è‹¥d=sqd = s^qd=sqä¸”q&gt;1q &gt;1q&gt;1 è‹¥q=2q = 2q=2ï¼Œdddå¯ä»¥æ‹†æˆä¸¤ä¸ªsssï¼Œç„¶åå°†ä¸‰ä¸ªsssä¹˜åœ¨ä¸‰ä¸ªdddä¸Šï¼Œæ­¤æ—¶éœ€è¦4ä¸ªdddï¼Œå³k&gt;3k &gt; 3k&gt;3 è‹¥q&gt;2q &gt; 2q&gt;2ï¼Œåˆ™dddå¯ä»¥æ‹†ä¸ºssså’Œsqâˆ’1s^{q - 1}sqâˆ’1ï¼Œå°†s2s^2s2å’Œsqâˆ’1s^{q - 1}sqâˆ’1ä¹˜åœ¨ä¸€ä¸ªdddä¸Šï¼Œå¾—åˆ°ç¬¬äºŒç§æ–¹æ¡ˆï¼Œæ­¤æ—¶éœ€è¦3ä¸ªdddï¼Œå³k&gt;2k &gt; 2k&gt;2 // Problem: D. Madoka and the Best School in Russia // Contest: Codeforces - Codeforces Round #777 (Div. 2) // URL: https://codeforces.com/problemset/problem/1647/D // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; int x, d, k; bool check(int x) { if(x &lt; 4) return 1; if(x % 2 == 0 || x % 3 == 0) return 0; for(int i = 5; i * i &lt;= x; i += 6) if(x % i == 0 || x % (i + 2) == 0) return 0; return 1; } void solve() { cin &gt;&gt; x &gt;&gt; d; for(k = 0; x % d == 0; k ++, x /= d); if(k &lt; 2) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; else if(!check(x)) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else if(check(d)) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; else cout &lt;&lt; (k &gt; (x * x == d) + 2 ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 167B - Wizards and Huge Prize é¢˜ç›®å¤§æ„ï¼š æœ€å¼€å§‹ä½ æœ‰kçš„å®¹ç§¯ï¼Œæœ‰nè½®æ¯”èµ›ï¼Œæ¯”èµ›åˆ†ä¸ºä¸¤ç§(å…·ä½“ç§ç±»ç”±è¾“å…¥ç»™å‡º)ï¼Œä¸€ç§çš„å¥–å“æ˜¯å¢åŠ aiå®¹ç§¯ï¼Œå¦ä¸€ç§å¢åŠ ä¸€ä¸ªç‰©å“ï¼Œåªæœ‰åˆ°æœ€åçš„å®¹ç§¯è£…å¾—ä¸‹æ‰€æœ‰èµ¢å¾—çš„ç‰©å“æ‰ç®—åˆæ³•çš„æ–¹æ¡ˆï¼Œé—®èµ¢å¾—çš„æ¯”èµ›æ€»åœºæ•°&gt;=lçš„åˆæ³•æ–¹æ¡ˆçš„æ¦‚ç‡ã€‚ é¢˜è§£ï¼š æœŸæœ›DP å°†ç¬¬äºŒç§å¥–å“çœ‹æˆå®¹ç§¯ä¸ºâˆ’1-1âˆ’1ï¼Œä¹‹åè€ƒè™‘DP dp[i][j][k]dp[i][j][k]dp[i][j][k]è¡¨ç¤ºä»å‰iiiæ¬¡æ¯”èµ›ä¸­è·èƒœkkkæ¬¡ï¼Œå®¹ç§¯ä¸ºkkkæ—¶çš„æ¦‚ç‡ çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š å¦‚æœç¬¬i+1i+1i+1åœºæ¯”èµ›è¾“æ‰ï¼Œåˆ™æœ‰dp[i+1][j][k]+=dp[i][j][k]âˆ—(1âˆ’p[i+1])dp[i+1][j][k] += dp[i][j][k] * (1 - p[i + 1])dp[i+1][j][k]+=dp[i][j][k]âˆ—(1âˆ’p[i+1]) å¦‚æœç¬¬i+1i + 1i+1åœºæ¯”èµ›è·èƒœï¼Œåˆ™æœ‰dp[i+1][j+1][k+a[i+1]+=dp[i][j][k]âˆ—p[i+1]dp[i+1][j+1][k+a[i+1] += dp[i][j][k] * p[i + 1]dp[i+1][j+1][k+a[i+1]+=dp[i][j][k]âˆ—p[i+1] AC ä»£ç  // Problem: B. Wizards and Huge Prize // Contest: Codeforces - Codeforces Round #114 (Div. 1) // URL: https://codeforces.com/problemset/problem/167/B // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 210; int n, l, k; double dp[N][N][N * 2]; double res; int a[N]; double p[N]; void work() { dp[0][0][k + 200] = 1; //å°†-1è€ƒè™‘ä¸ºå®¹ç§¯ä¸º-1 for(int i = 0; i &lt; n; i ++) { for(int j = 0; j &lt;= i; j ++) { for(int q = 0; q &lt;= 400; q ++) { int t = min(400ll, q + a[i + 1]); dp[i + 1][j][q] += dp[i][j][q] * (1 - p[i + 1]); if(t &gt;= 0) dp[i + 1][j + 1][t] += dp[i][j][q] * p[i + 1]; } } } } void solve() { cin &gt;&gt; n &gt;&gt; l &gt;&gt; k; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; p[i]; p[i] /= 100; } for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; work(); for(int i = l; i &lt;= n; i ++) { for(int j = 200; j &lt;= 400; j ++) res += dp[n][i][j]; } printf(&quot;%.10lf\\n&quot;, res); } signed main() { //ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } CF730 - Bottles é¢˜ç›®å¤§æ„ï¼š æœ‰ nnn ç“¶æ°´ï¼Œç¬¬ iii ç“¶æ°´çš„æ°´é‡ä¸º aia_iaiâ€‹ï¼Œå®¹é‡ä¸º bib_ibiâ€‹ã€‚å°† 111 å•ä½æ°´ä»ä¸€ä¸ªç“¶å­è½¬ç§»åˆ°å¦ä¸€ä¸ªç“¶å­æ‰€æ¶ˆè€—æ—¶é—´ä¸º 111 ç§’ï¼Œä¸”å¯ä»¥è¿›è¡Œæ— é™æ¬¡è½¬ç§»ã€‚æ±‚å‚¨å­˜æ‰€æœ‰æ°´æ‰€éœ€æœ€å°ç“¶å­æ•° kkk ä»¥åŠè¯¥æƒ…å†µä¸‹æ‰€ç”¨æœ€å°æ—¶é—´ tttã€‚ é¢˜è§£ï¼š 01èƒŒåŒ… ç¬¬ä¸€é—®ç­”æ¡ˆæ˜¾ç„¶ï¼Œè€ƒè™‘ç¬¬äºŒé—® è®¾dp[i][j][k]dp[i][j][k]dp[i][j][k]ä¸ºå‰iiiä¸ªç“¶å­é‡Œå–kkkä¸ªç“¶å­ï¼Œæ€»å®¹ç§¯ä¸ºjjjçš„æœ€å¤§ä¸å€’å…¥æ¯ä¸­çš„ä½“ç§¯ çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šdp[i][j][k]=max(dp[iâˆ’1][j][k],dp[iâˆ’1][jâˆ’bi][k]+ai)dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - b_i][k] + a_i)dp[i][j][k]=max(dp[iâˆ’1][j][k],dp[iâˆ’1][jâˆ’biâ€‹][k]+aiâ€‹) ç¬¬ä¸€ç»´å¯ä»¥æ»šæ‰ï¼Œç­”æ¡ˆå³ä¸ºVsumâˆ’max(dp[j][k])V_{sum} - max(dp[j][k])Vsumâ€‹âˆ’max(dp[j][k]) AC ä»£ç  // Problem: J. Bottles // Contest: Codeforces - 2016-2017 ACM-ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) // URL: https://codeforces.com/problemset/problem/730/J // Memory Limit: 512 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 110; int res, sum1, sum2; int n; int dp[N * N][N]; PII a[N]; int k; bool cmp(PII a, PII b) { return a.second &gt; b.second; } void work() { memset(dp, 128, sizeof dp); dp[0][0] = 0; for(int i = 1; i &lt;= n; i ++) for(int j = sum2; j &gt;= a[i].second; j --) for(int p = 1; p &lt;= k; p ++) dp[j][p] = max(dp[j][p], dp[j - a[i].second][p - 1] + a[i].first); for(int i = sum1; i &lt;= sum2; i ++) res = max(res, dp[i][k]); cout &lt;&lt; sum1 - res &lt;&lt; endl; } void solve() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i].first; sum1 += a[i].first; } for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i].second; } sort(a + 1, a + n + 1, cmp); while(sum2 &lt; sum1) sum2 += a[++ k].second; cout &lt;&lt; k &lt;&lt; &quot; &quot;; work(); } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; }","categories":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://memsetray.github.io/categories/é¢˜è§£/"}],"tags":[],"keywords":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://memsetray.github.io/categories/é¢˜è§£/"}]},{"title":"3åˆ†é’Ÿäº†è§£çŒ«å®«Hinataçš„FPS","slug":"3åˆ†é’Ÿäº†è§£çŒ«å®«Hinataçš„FPS","date":"2022-09-06T12:16:05.000Z","updated":"2022-09-06T12:22:54.473Z","comments":true,"path":"2022/09/06/3åˆ†é’Ÿäº†è§£çŒ«å®«Hinataçš„FPS/","link":"","permalink":"https://memsetray.github.io/2022/09/06/3åˆ†é’Ÿäº†è§£çŒ«å®«Hinataçš„FPS/","excerpt":"","text":"çŒ«å®«èµ›é«˜ï¼","categories":[{"name":"éšæƒ³","slug":"éšæƒ³","permalink":"https://memsetray.github.io/categories/éšæƒ³/"}],"tags":[],"keywords":[{"name":"éšæƒ³","slug":"éšæƒ³","permalink":"https://memsetray.github.io/categories/éšæƒ³/"}]},{"title":"éšæƒ³test","slug":"éšæƒ³test","date":"2022-09-05T14:54:56.000Z","updated":"2022-09-05T14:57:17.992Z","comments":true,"path":"2022/09/05/éšæƒ³test/","link":"","permalink":"https://memsetray.github.io/2022/09/05/éšæƒ³test/","excerpt":"","text":"ä¸ºä»€ä¹ˆæˆ‘FPSç©çš„è¿™ä¹ˆèœï¼ï¼ï¼ï¼","categories":[{"name":"éšæƒ³","slug":"éšæƒ³","permalink":"https://memsetray.github.io/categories/éšæƒ³/"}],"tags":[],"keywords":[{"name":"éšæƒ³","slug":"éšæƒ³","permalink":"https://memsetray.github.io/categories/éšæƒ³/"}]},{"title":"CodeForces1500-1600éƒ¨åˆ†é¢˜é¢˜è§£","slug":"CodeForces1500-1600éƒ¨åˆ†é¢˜é¢˜è§£","date":"2022-09-05T04:02:58.000Z","updated":"2022-09-05T14:53:15.719Z","comments":true,"path":"2022/09/05/CodeForces1500-1600éƒ¨åˆ†é¢˜é¢˜è§£/","link":"","permalink":"https://memsetray.github.io/2022/09/05/CodeForces1500-1600éƒ¨åˆ†é¢˜é¢˜è§£/","excerpt":"","text":"Codeforces 1500 - 1600éš¾åº¦ç¬”è®° 1675E- Replace With the Previous, Minimize ç»™å®šä¸€ä¸ªé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²ï¼Œæœ‰kæ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥é€‰ä¸€ä¸ªå­—æ¯ï¼Œè®©æ‰€æœ‰è¯¥å­—æ¯å˜æˆå­—å…¸åºçš„å‰ä¸€ä¸ªå­—æ¯ï¼Œæ±‚èƒ½å¤Ÿé€šè¿‡kæ¬¡æ“ä½œå¾—åˆ°çš„æœ€å°å­—å…¸åºã€‚ è´ªå¿ƒï¼Œç»´æŠ¤ä¸€ä¸ªmax_idxè¡¨ç¤ºä»aåˆ°a + max_idxä¸­çš„å­—æ¯éƒ½å¯ä»¥é€šè¿‡max_idxæ¬¡æ“ä½œè½¬åŒ–ä¸ºa å¦‚æœå½“å‰å­—æ¯è½¬æ¢ä¸ºaçš„æ“ä½œæ•° â‰¤k\\leq kâ‰¤k ,åˆ™ç›´æ¥æ›´æ–°max_idx å¦‚æœå½“å‰å­—æ¯è½¬æ¢ä¸ºaçš„æ“ä½œæ•°&gt;k&gt; k&gt;kï¼Œåˆ™è¯¥å­—æ¯æœ€å¤šåªèƒ½è¿›è¡Œkâˆ’midxk - midxkâˆ’midxæ¬¡æ“ä½œï¼Œè®¾å½“å‰å­—æ¯ä¸ºsssï¼Œåˆ™sâˆ’(kâˆ’midx)s-(k - midx)sâˆ’(kâˆ’midx) åˆ°sssåŒºé—´å†…çš„å­—æ¯éƒ½å¯ä»¥è½¬åŒ–ä¸ºsâˆ’(kâˆ’midx)s - (k - midx)sâˆ’(kâˆ’midx)ï¼Œå› æ­¤ç›´æ¥å°†å…¶è½¬åŒ–ä¸ºsâˆ’(kâˆ’midx)s - (k - midx)sâˆ’(kâˆ’midx) // Problem: E. Replace With the Previous, Minimize // Contest: Codeforces - Codeforces Round #787 (Div. 3) // URL: https://codeforces.com/problemset/problem/1675/E // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; string s; cin &gt;&gt; s; int max_idx = 0; for(int i = 0; i &lt; s.size(); i ++) { int t = s[i] - 'a'; if(t &lt;= k) max_idx = max(max_idx, t); else { char min_c = s[i] - k + max_idx; char max_c = s[i]; for(int j = 0; j &lt; s.size(); j ++) { if(min_c &lt;= s[j] &amp;&amp; s[j] &lt;= max_c) s[j] = min_c; } break; } } for(int i = 0; i &lt; s.size(); i ++) { if(s[i] - 'a' &lt;= max_idx) s[i] = 'a'; } cout &lt;&lt; s &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1673C- Palindrome Basis ç»™å®šä¸€ä¸ªæ•°nï¼Œé—®æœ‰å¤šå°‘ç§æ‹¼æ³•æ»¡è¶³nå¯ä»¥è¢«è‹¥å¹²å›æ–‡æ•°æ‹¼æˆ å›æ–‡æ•°æŒ‡æ­£ç€çœ‹å’Œå€’ç€çœ‹çš„å€¼ç›¸åŒçš„æ•° 1â‰¤nâ‰¤400001 \\leq n \\leq 400001â‰¤nâ‰¤40000 é¦–å…ˆè§‚å¯Ÿåˆ°nçš„å€¼åŸŸå¾ˆå°ï¼Œç›´è§‰ä¸Šå‘Šè¯‰æˆ‘ä»¬40000ä»¥å†…çš„å›æ–‡æ•°æ•°é‡ä¸å¤šï¼ˆäº‹å®ä¸Šåªæœ‰500ä¸ªå·¦å³ï¼‰ï¼Œå› æ­¤æˆ‘ä»¬å…ˆå°†nä»¥å†…çš„å›æ–‡æ•°é¢„å¤„ç†å‡ºæ¥ã€‚ å‰©ä¸‹çš„é—®é¢˜å°±æ˜¯ï¼Œå¦‚ä½•å°†nç”¨å›æ–‡æ•°æ‹¼å‡ºæ¥ï¼Œè¿™æ˜¯ä¸€ä¸ªç»å…¸çš„DPé—®é¢˜ è®¾dp[i][j]è¡¨ç¤ºä»å‰iä¸ªå›æ–‡æ•°ä¸­é€‰ï¼Œæ‹¼æˆçš„æ•°ä¸ºjçš„æ–¹æ¡ˆæ•° äºæ˜¯çŠ¶æ€è½¬ç§»æ–¹ç¨‹éå¸¸æ˜¾ç„¶ï¼š dp[i][j]=dp[iâˆ’1][j]+dp[i][jâˆ’p[i]]dp[i][j] = dp[i - 1][j] + dp[i][j - p[i]]dp[i][j]=dp[iâˆ’1][j]+dp[i][jâˆ’p[i]] å…¶ä¸­p[i]è¡¨ç¤ºçš„æ˜¯ç¬¬iä¸ªå›æ–‡æ•°æ˜¯å¤šå°‘ è¾¹ç•Œï¼šâˆ‘i=1Mâˆ’1dp[i][0]=1\\sum_{i=1}^{M - 1}dp[i][0] = 1âˆ‘i=1Mâˆ’1â€‹dp[i][0]=1ï¼Œå…¶ä¸­M - 1ä¸ºå›æ–‡æ•°çš„ä¸ªæ•° ç›®æ ‡ï¼šdp[Mâˆ’1][n]dp[M - 1][n]dp[Mâˆ’1][n] // Problem: C. Palindrome Basis // Contest: Codeforces - Codeforces Round #785 (Div. 2) // URL: https://codeforces.com/problemset/problem/1673/C // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 4e4 + 10, M = 510, mod = 1e9 + 7; int dp[510][N]; vector&lt;int&gt; p; int reverse_i(int a) { int res = 0; while(a &gt; 0) { res = res * 10 + a % 10; a /= 10; } return res; } void init() { p.push_back(0); for(int i = 1; i &lt; N; i ++) { if(reverse_i(i) == i) p.push_back(i); } } void solve() { for(int i = 1; i &lt; M; i ++) dp[i][0] = 1; for(int i = 1; i &lt; M; i ++) { for(int j = 1; j &lt; N; j ++) { if(p[i] &lt;= j) dp[i][j] = (dp[i - 1][j] + dp[i][j - p[i]]) % mod; else dp[i][j] = dp[i - 1][j]; } } } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; init(); solve(); while(T --) { int n; cin &gt;&gt; n; cout &lt;&lt; dp[M - 1][n] % mod &lt;&lt; endl; } return 0; } 1665C- Tree Infection ç»™å®šä¸€ä¸ªnä¸ªèŠ‚ç‚¹çš„æ•°ï¼Œä¸€å¼€å§‹nä¸ªèŠ‚ç‚¹éƒ½æ˜¯å¥åº·çš„ï¼Œæ¯ç§’å¯ä»¥è¿›è¡Œä¸¤ç§æ“ä½œ é€‰å®šä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°†å…¶æ„ŸæŸ“ å¦‚æœèŠ‚ç‚¹væœ‰ä¸€ä¸ªå­èŠ‚ç‚¹è¢«æ„ŸæŸ“ï¼Œé‚£ä¹ˆå°†ä¼ æ’­åˆ°å¦ä¸€ä¸ªå­èŠ‚ç‚¹ æ±‚å°†æ‰€æœ‰èŠ‚ç‚¹ä¼ æŸ“æ‰€éœ€çš„æœ€å°ç§’æ•° é€šè¿‡è§‚å¯Ÿå¯ä»¥å‘ç°ï¼Œä»»æ„ä¸¤ä¸ªä¸åŒçš„èŠ‚ç‚¹ï¼Œå®ƒä»¬çš„å­èŠ‚ç‚¹äº’ç›¸ç‹¬ç«‹ï¼Œæˆ‘ä»¬åªå…³å¿ƒæ¯ä¸ªèŠ‚ç‚¹æœ‰å¤šå°‘ä¸ªå„¿å­ã€‚ äºæ˜¯é—®é¢˜ç®€åŒ–ä¸ºï¼šç»™å®škä¸ªæ•°ï¼Œæ¯ä¸ªæ•°è¡¨ç¤ºè¯¥èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡ï¼Œæ¯ç§’æ‰€æœ‰æ•°å‡å°‘1ï¼Œå¹¶ä¸”ä½ å¯ä»¥é¢å¤–é€‰æ‹©ä¸€ä¸ªæ•°ä½¿å…¶å‡å°‘1ï¼Œæ±‚è‡³å°‘éœ€è¦å¤šå°‘ç§’ä½¿å¾—æ•°ç»„ä¸­æ‰€æœ‰æ•°å°äºç­‰äº0 é¦–å…ˆé¢„å¤„ç†å‡ºæ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡ï¼Œå°†å…¶ä»å¤§åˆ°å°æ’åºå¹¶æ’é™¤æ‰€æœ‰çš„0, æ­¤æ—¶æ ¹æ®è´ªå¿ƒï¼Œæˆ‘ä»¬åº”è¯¥ä»å¤§åˆ°å°å°†æ‰€æœ‰å­æ ‘å…ˆæ„ŸæŸ“ä¸€éï¼Œç„¶åå†æ¬¡ä»å¤§åˆ°å°æ’åºå¹¶æ’é™¤æ‰€æœ‰å°äºç­‰äº0çš„æ•° ä¹‹åï¼Œæˆ‘ä»¬æ¯æ¬¡éœ€è¦å°†æ•°ç»„ä¸­çš„æ‰€æœ‰æ•°å‡1ï¼Œå¹¶é¢å¤–é€‰æ‹©ä¸€ä¸ªæ•°å‡1ï¼Œæ˜¾ç„¶æ¯æ¬¡é¢å¤–é€‰æ‹©éƒ½åº”è¯¥é€‰æ•°ç»„ä¸­æœ€å¤§çš„æ•°ï¼Œæˆ‘ä»¬ä¸æ–­æ¨¡æ‹Ÿè¿™ä¸ªè¿‡ç¨‹ï¼Œå¹¶ä¸”æ¯æ¬¡è®°å½•æœ€å¤§å€¼æœ€åå‡ºç°ä¸‹æ ‡lastï¼Œé¢å¤–æ“ä½œå°±åº”å½“é€‰æ‹©lastå¯¹åº”çš„æ•°ï¼Œè¿™æ ·å¯ä»¥ä¿è¯åºåˆ—å§‹ç»ˆä¸ºå•è°ƒé€’å‡ã€‚ // Problem: C. Tree Infection // Contest: Codeforces - Codeforces Round #781 (Div. 2) // URL: https://codeforces.com/problemset/problem/1665/C // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10, M = N * 2; int n; int res; void calc(vector&lt;int&gt; a) { if(a.empty()) return; int n = a.size(); int last = 0; for(int i = 0; i &lt; n; i ++) { if(a[i] == a[0]) last = i; else break; } -- a[last]; for(int i = 0; i &lt; n; i ++) a[i] --; res ++; while(a.size() &amp;&amp; a.back() &lt;= 0) a.pop_back(); calc(a); } void solve() { cin &gt;&gt; n; vector&lt;int&gt; a(n); for(int i = 1; i &lt; n; i ++) { int x; cin &gt;&gt; x; a[-- x] ++; } a.push_back(1); sort(a.begin(), a.end(), greater&lt;int&gt;()); while(a.size() &amp;&amp; a.back() &lt;= 0) a.pop_back(); n = a.size(); res = 0; for(int i = 0; i &lt; n; i ++) { a[i] = a[i] - (n - i); res ++; } sort(a.begin(), a.end(), greater&lt;int&gt;()); while(a.size() &amp;&amp; a.back() &lt;= 0) a.pop_back(); calc(a); cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1671D- Insert a Progression ç»™å®šä¸€ä¸ªæ•°ç»„aï¼Œå†ç»™å‡ºxä¸ªæ­£æ•´æ•°1-x å°†è¿™xä¸ªæ•°æ’å…¥åˆ°æ•°ç»„aä¸­ï¼ˆå¯ä»¥æ’å…¥åˆ°ä»»ä½•ä¸€ä¸ªä½ç½®ï¼ŒåŒ…æ‹¬è¾¹ç•Œï¼‰å¾—åˆ°aâ€˜ aâ€™çš„ä»£ä»·ä¸ºæ•°ç»„ä¸­æ‰€æœ‰å…ƒç´ å·®çš„ç»å¯¹å€¼ä¹‹å’Œï¼Œæ±‚aâ€™çš„æœ€å°ä»£ä»· è¿™é“é¢˜æœ€é‡è¦çš„æ˜¯è§‚å¯Ÿå‡ºç»“è®ºï¼šè®¾åŸæ•°ç»„æœ€å¤§å€¼ä¸ºaï¼Œæœ€å°å€¼ä¸ºbï¼Œä¸€å®šå­˜åœ¨ä¸€ç§æ’å…¥æ–¹å¼ï¼Œä½¿å¾—æ•°ç»„aâ€™ä¸­æ’å…¥äº†å¤§å°ä¸º[a,b]çš„æ‰€æœ‰æ•°ï¼Œä¸”æ»¡è¶³ä»£ä»·ä¸å˜ã€‚ ä¸€ç§æ¯”è¾ƒå¥½ç†è§£çš„æ–¹å¼æ˜¯ï¼šå‡è®¾åŸæ•°ç»„aä¸­å­˜åœ¨ç›¸é‚»çš„ä¸¤ä¸ªæ•°axa_xaxâ€‹,aya_yayâ€‹,ä¸å¦¨è®¾ax&lt;aya_x &lt; a_yaxâ€‹&lt;ayâ€‹,é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å°è¯•åœ¨è¿™ä¸¤ä¸ªæ•°ä¹‹é—´æ’å…¥ayâˆ’axâˆ’1a_y - a_x - 1ayâ€‹âˆ’axâ€‹âˆ’1ä¸ªæ­£æ•´æ•°ï¼Œè€Œä»£ä»·ä¸å˜ï¼Œå› æ­¤æ‰€æœ‰åœ¨æœ€å€¼èŒƒå›´å†…çš„æ•°éƒ½å¯ä»¥èµ·åˆ°â€œæ¡¥æ¢â€çš„ä½œç”¨ã€‚ å› æ­¤æˆ‘ä»¬éœ€è¦å…ˆç®—å‡ºåŸæ•°ç»„çš„ä»£ä»·tï¼Œç„¶ååªéœ€è¦çœ‹æœ€å€¼æ‰€è¦†ç›–çš„åŒºé—´æ˜¯å¦å®Œå…¨åŒ…å«åŒºé—´[1,x] å¦‚æœå®Œå…¨è¦†ç›–ï¼Œåˆ™ç­”æ¡ˆä¸ºtï¼Œå¦åˆ™è€ƒè™‘å‰©ä¸‹çš„æ•°å¦‚ä½•æ”¾ç½® å®¹æ˜“å‘ç°ï¼Œé™¤äº†1å’Œxï¼Œå‰©ä¸‹çš„æ‰€æœ‰æ•°éƒ½æ˜¯â€œæ¡¥æ¢â€ï¼Œå¯¹ç­”æ¡ˆæ²¡æœ‰å½±å“ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦æšä¸¾1å’Œxå‡ºç°çš„ä½ç½®ï¼Œå–æœ€å°å€¼å³å¯ã€‚ // Problem: D. Insert a Progression // Contest: Codeforces - Educational Codeforces Round 127 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1671/D // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int a[N]; int n, x; void solve() { cin &gt;&gt; n &gt;&gt; x; memset(a, 0, sizeof a); int res = 0; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; if(i &gt; 1) res += abs(a[i] - a[i - 1]); } int max_num = 0, min_num = 0x3f3f3f3f; for(int i = 1; i &lt;= n; i ++) { if(a[i] &gt; max_num) max_num = a[i]; if(a[i] &lt; min_num) min_num = a[i]; } if(x &gt; max_num) { if(n == 1) { res += x - a[1]; } else { int plus = 0x3f3f3f3f; for(int i = 1; i &lt; n; i ++) { plus = min(plus, x - a[i] + x - a[i + 1] - abs(a[i + 1] - a[i])); } plus = min(plus, min(x - a[n], x - a[1])); res += plus; } } if(min_num != 1) { if(n == 1) { res += a[1] - 1; } else { int plus = 0x3f3f3f3f; for(int i = 1; i &lt; n; i ++) { plus = min(plus, a[i] - 1 + a[i + 1] - 1 - abs(a[i + 1] - a[i])); } plus = min(plus, min(a[n] - 1, a[1] - 1)); res += plus; } } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1659C- Line Empire ä½ æ˜¯ä¸€ä¸ªå›½ç‹ï¼Œä½ æœ‰nä¸ªå›½å®¶éœ€è¦å é¢†ï¼Œèµ·åˆä½ çš„é¦–éƒ½åœ¨0ä½ç½®å¤„ï¼Œç°åœ¨ä½ æœ‰ä¸¤ç§æ“ä½œï¼š å°†ä¸€ä¸ªå·²ç»è¢«å é¢†çš„å›½å®¶è§†ä¸ºé¦–éƒ½ï¼Œä»£ä»·ä¸ºaâˆ—âˆ£c1âˆ’c2âˆ£a *|c_1 - c_2|aâˆ—âˆ£c1â€‹âˆ’c2â€‹âˆ£ å é¢†ä¸€ä¸ªæœªè¢«å é¢†çš„å›½å®¶ï¼Œå‰ææ˜¯è¿™ä¸ªå›½å®¶ä¸é¦–éƒ½ä¹‹é—´çš„æ‰€æœ‰å›½å®¶éƒ½è¢«å é¢†ï¼Œä»£ä»·ä¸ºbâˆ—âˆ£c1âˆ’c2âˆ£b * |c_1 - c_2|bâˆ—âˆ£c1â€‹âˆ’c2â€‹âˆ£ å…¶ä¸­c1,c2c_1,c_2c1â€‹,c2â€‹ä¸ºä¸¤ä¸ªå›½å®¶çš„ä½ç½®ï¼Œæ±‚å é¢†æ‰€æœ‰å›½å®¶æ‰€éœ€è¦çš„æœ€å°ä»£ä»·ï¼Œæœ€ç»ˆé¦–éƒ½å¯ä»¥åœ¨ä»»ä½•åœ°æ–¹ã€‚ å¯¹äºæ¯ä¸ªå‡ºç°è¿‡çš„ä½ç½®ï¼ˆåŒ…æ‹¬0ï¼‰æˆ‘ä»¬éƒ½å¯ä»¥é¢„å¤„ç†å‡ºå‰ç¼€å’Œsumä»¥åŠä¸¤ä¸ªæ•°ç»„ï¼š ä»¥è¯¥ä½ç½®ä¸ºé¦–éƒ½ï¼Œä¹‹åçš„æ‰€æœ‰å›½å®¶éƒ½é‡‡ç”¨ç›´æ¥å é¢†æ‰€éœ€è¦çš„èŠ±è´¹back[i]back[i]back[i] åœ¨è¯¥ä½ç½®ä¹‹å‰ï¼Œé€šè¿‡äº¤æ›¿è¿›è¡Œå é¢†å’Œæ›¿æ¢é¦–éƒ½ä½¿å¾—è¯¥ä½ç½®æˆä¸ºé¦–éƒ½æ‰€éœ€è¦çš„èŠ±è´¹pre[i]pre[i]pre[i] å…¶ä¸­back[i]=(sum[n]âˆ’sum[i]âˆ’(nâˆ’i)âˆ—x[i])âˆ—bback[i] = (sum[n] - sum[i] - (n - i) * x[i]) * bback[i]=(sum[n]âˆ’sum[i]âˆ’(nâˆ’i)âˆ—x[i])âˆ—b pre[i]=x[i]âˆ—(a+b)pre[i] = x[i] * (a + b)pre[i]=x[i]âˆ—(a+b) æšä¸¾æ‰€æœ‰çš„ä½ç½®ï¼Œç­”æ¡ˆå³ä¸ºmin(pre[i]+back[i])min(pre[i] + back[i])min(pre[i]+back[i]) ä¸ºä»€ä¹ˆäº¤æ›¿è¿›è¡Œæ“ä½œçš„æ–¹å¼ä¸€å®šæ˜¯æœ€ä¼˜çš„ï¼šå¦‚æœæˆ‘ä»¬å¹¶æ²¡æœ‰é‡‡ç”¨äº¤æ›¿çš„æ–¹å¼è¿›è¡Œæ“ä½œï¼Œå°±ä¸€å®šä¼šè¿ç»­è¿›è¡Œè‹¥å¹²æ¬¡å é¢†æ“ä½œï¼Œä¹‹åä»ç„¶è¦é€šè¿‡æ›¿æ¢æ“ä½œä½¿å¾—é¦–éƒ½åˆ°è¾¾ç›®æ ‡ä½ç½®ï¼Œæ˜¾ç„¶è¿›è¡Œäº†å¤šä½™çš„å é¢†æ“ä½œï¼Œä»£ä»·å˜å¤§ã€‚ // Problem: C. Line Empire // Contest: Codeforces - Codeforces Round #782 (Div. 2) // URL: https://codeforces.com/problemset/problem/1659/C // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int n, a, b; int x[N]; int sum[N]; int back[N]; int pre[N]; void solve() { cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; x[i]; for(int i = 1; i &lt;= n; i ++) { sum[i] = sum[i - 1] + x[i]; } for(int i = 0; i &lt;= n; i ++) { pre[i] = x[i] * (a + b); back[i] = (sum[n] - sum[i] - (n - i) * x[i]) * b; } int res = 1e18; for(int i = 0; i &lt;= n; i ++) { res = min(res, pre[i] + back[i]); } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1658D1- 388535 (Easy Version) ç»™å®šä¸€ä¸ªåŒºé—´[l,r][l,r][l,r]ï¼Œå·²çŸ¥åŸæ•°ç»„æ˜¯[l,r][l,r][l,r]çš„æ’åˆ—ï¼Œç°åœ¨ç»™å‡ºåŸæ•°ç»„å¼‚æˆ–xxxåçš„æ•°ç»„ï¼Œæ±‚å‡ºä»»æ„ä¸€ä¸ªxxxçš„å¯èƒ½å€¼ Easy Versonæ•°æ®èŒƒå›´ï¼š0=lâ‰¤r&lt;2170 = l \\leq r &lt; 2^{17}0=lâ‰¤r&lt;217 ç”±äºä½è¿ç®—æ¯ä¸€ä½ç‹¬ç«‹ï¼Œæˆ‘ä»¬è€ƒè™‘æ¯ä¸€ä½æŒ‰ä½å¼‚æˆ–çš„å€¼ã€‚ å¯¹äºæ¯ä¸ªäºŒè¿›åˆ¶ä½ï¼Œåˆ†åˆ«ç»Ÿè®¡å½“å‰æ’åˆ—ï¼ˆä¸‹æ ‡ï¼‰ä¸­1çš„ä¸ªæ•°ï¼Œä»¥åŠå½“å‰æ•°ç»„å…ƒç´ ä¸­1çš„ä¸ªæ•°ï¼Œå¦‚æœä¸ç›¸åŒï¼Œè¯´æ˜å½“å‰è¿™ä¸€ä½éœ€è¦è¿›è¡Œä¸€æ¬¡å¼‚æˆ–ï¼Œå³xxxçš„å½“å‰ä½ä¸º1ï¼Œè€ƒè™‘å®Œæ‰€æœ‰çš„ä½å°±å¾—åˆ°äº†xxx. // Problem: D1. 388535 (Easy Version) // Contest: Codeforces - Codeforces Round #779 (Div. 2) // URL: https://codeforces.com/problemset/problem/1658/D1 // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = (1 &lt;&lt; 17) + 5; int l, r; int a[N]; void solve() { cin &gt;&gt; l &gt;&gt; r; for(int i = l; i &lt;= r; i ++) cin &gt;&gt; a[i]; int res = 0; for(int j = 0; j &lt;= 17; j ++) { int cnt_idx = 0, cnt_num = 0; for(int i = l; i &lt;= r; i ++) { if(i &amp; (1 &lt;&lt; j)) cnt_idx ++; if(a[i] &amp; (1 &lt;&lt; j)) cnt_num ++; } if(cnt_idx != cnt_num) res += 1 &lt;&lt; j; } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1658D2- 388535 (Hard Version) ç»™å®šä¸€ä¸ªåŒºé—´[l,r][l,r][l,r]ï¼Œå·²çŸ¥åŸæ•°ç»„æ˜¯[l,r][l,r][l,r]çš„æ’åˆ—ï¼Œç°åœ¨ç»™å‡ºåŸæ•°ç»„å¼‚æˆ–xxxåçš„æ•°ç»„ï¼Œæ±‚å‡ºä»»æ„ä¸€ä¸ªxxxçš„å¯èƒ½å€¼ Easy Versonæ•°æ®èŒƒå›´ï¼š0â‰¤lâ‰¤r&lt;2170 \\leq l \\leq r &lt; 2 ^ {17}0â‰¤lâ‰¤r&lt;217 é€šè¿‡è§‚å¯Ÿï¼ˆæˆ–è®¸ï¼‰å¯ä»¥å‘ç°ï¼šaaaä¸­ä¸€å®šå­˜åœ¨ä¸€ä¸ªæ•°aia_iaiâ€‹ï¼Œä½¿å¾—aiâŠ•x=la_i \\oplus x = laiâ€‹âŠ•x=lï¼Œäºæ˜¯æˆ‘ä»¬å¯ä»¥ç¡®å®šå­˜åœ¨ä¸€ä¸ªaia_iaiâ€‹ä½¿å¾—x=aiâŠ•lx = a_i\\oplus lx=aiâ€‹âŠ•l ç”±äºaaaä¸­çš„æ•°äº’ä¸ç›¸åŒï¼Œæ‰€ä»¥å…¶ä¸­çš„æ•°å¼‚æˆ–ä¸Šxxxä¹Ÿäº’ä¸ç›¸åŒï¼Œæˆ‘ä»¬ç”¨æ•°ç»„bbbæ¥å­˜å‚¨aiâŠ•la_i \\oplus laiâ€‹âŠ•lçš„å€¼ï¼Œç„¶åç»´æŠ¤ä¸€ä¸ª01Trieæ¥æŸ¥æ‰¾biâŠ•aib_i \\oplus a_ibiâ€‹âŠ•aiâ€‹çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ï¼Œè¿™ä¸ªå€¼bib_ibiâ€‹éœ€è¦æ»¡è¶³æœ€å¤§å€¼ä¸ºlllï¼Œæœ€å°å€¼ä¸ºrrr #include&lt;bits/stdc++.h&gt; #define N 1000005 #define int long long using namespace std; int T,l,r,a[N],cnt,trie[N][30],b[N]; void insert(int sum){ int now=0; for(int i=17;i&gt;=0;i--){ bool tmp=(1&lt;&lt;i)&amp;sum; if(!trie[now][tmp])trie[now][tmp]=++cnt; now=trie[now][tmp]; } } int Max(int sum){ int now=0,res=0; for(int i=17;i&gt;=0;i--){ bool tmp=(1&lt;&lt;i)&amp;sum; if(!trie[now][tmp^1])now=trie[now][tmp]; else now=trie[now][tmp^1],res+=(1&lt;&lt;i); } return res; } int Min(int sum){ int now=0,res=0; for(int i=17;i&gt;=0;i--){ bool tmp=(1&lt;&lt;i)&amp;sum; if(!trie[now][tmp])now=trie[now][tmp^1],res+=(1&lt;&lt;i); else now=trie[now][tmp]; } return res; } signed main() { cin&gt;&gt;T; while(T--){ cin&gt;&gt;l&gt;&gt;r; for(int i=0;i&lt;=cnt;i++)trie[i][0]=trie[i][1]=0; cnt=0; for(int i=l;i&lt;=r;i++)cin&gt;&gt;a[i],b[i]=a[i]^l; for(int i=l;i&lt;=r;i++)insert(a[i]); for(int i=l;i&lt;=r;i++){ if(Max(b[i])==r&amp;&amp;Min(b[i])==l){ cout&lt;&lt;b[i]&lt;&lt;endl; break; } } } } 1651C- Fault-tolerant Network ç»™å®šä¸¤ä¸ªæ•°ç»„a,ba,ba,bï¼Œæ•°ç»„aaaç›¸é‚»ä¸¤ä¸ªå…ƒç´ ä¹‹é—´é€šè¿‡çº¿ç›¸è¿ï¼Œæ•°ç»„bbbåŒç†ï¼Œç°åœ¨è¦å°†a,ba,ba,bä¸¤ä¸ªæ•°ç»„äº’ç›¸è¿æ¥ï¼Œè¿æ¥çš„ä»£ä»·ä¸ºâˆ£a[i]âˆ’b[j]âˆ£|a[i]-b[j]|âˆ£a[i]âˆ’b[j]âˆ£è¦æ±‚å½“åˆ é™¤ä¸¤ä¸ªæ•°ç»„ä¸­ä»»æ„ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œå‰©ä¸‹çš„æ‰€æœ‰å…ƒç´ ä»ç„¶èƒ½é€šè¿‡çº¿è¿é€šï¼Œä¸”ä»£ä»·æœ€å°ã€‚ é€šè¿‡è§‚å¯Ÿå¯ä»¥å‘ç°ï¼Œæƒ³è¦è®©ä¸¤ä¸ªæ•°ç»„åœ¨åˆ é™¤ä¸€ä¸ªä»»æ„ä¸€ä¸ªæ•°çš„æƒ…å†µä¸‹ä¿æŒè¿é€šï¼Œåˆ™ä¸¤ä¸ªæ•°ç»„çš„å¼€å¤´å’Œæœ«å°¾ä¸€å®šè¦æœ‰çº¿æ¥è¿æ¥ã€‚ å‡è®¾æŸä¸€ä¸ªæ•°ç»„çš„å¼€å¤´æˆ–ç»“å°¾æ²¡æœ‰æ•°è¿æ¥ï¼Œé‚£ä¹ˆå½“æˆ‘ä»¬åˆ é™¤è¿™ä¸ªæ•°çš„æ—¶å€™ï¼Œä¼šå‘ç°è¿™ä¸ªæ•°ä¸€å®šæ˜¯å­¤ç«‹çš„çŠ¶æ€ï¼Œæ‰€ä»¥ä¸Šé¢ç»“è®ºæˆç«‹ã€‚ è¿›ä¸€æ­¥è§‚å¯Ÿå¯ä»¥å‘ç°ï¼Œåªè¦ä¿è¯ä¸¤ä¸ªæ•°çš„å¼€å¤´æˆ–ç»“å°¾å¤„äºè¿æ¥çŠ¶æ€ï¼Œæ­¤æ—¶ä¸¤ä¸ªæ•°ç»„å·²ç»å¯ä»¥ä¿è¯åœ¨åˆ é™¤ä»»æ„æ•°çš„æ¡ä»¶ä¸‹ä¿æŒè¿é€šï¼Œä¸éœ€è¦æ·»åŠ é¢å¤–çš„è¾¹ã€‚å› æ­¤æˆ‘ä»¬åªéœ€è¦åˆ†åˆ«æ±‚è¿™å››ä¸ªç‚¹è¿›è¡Œè¿çº¿çš„æœ€å°ä»£ä»·ï¼Œæœ€åæ±‚å’Œå³å¯ã€‚ æœ¬é¢˜è¿˜è¦æ³¨æ„è¾¹ç•Œé—®é¢˜ï¼šå››ä¸ªç‚¹äº’ç›¸è¿çº¿çš„æƒ…å†µä¸‹éœ€è¦ç‰¹åˆ¤æœ€å°å€¼ã€‚ // Problem: C. Fault-tolerant Network // Contest: Codeforces - Educational Codeforces Round 124 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1651/C // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10, INF = 2e18; int a[N], b[N]; int n; void solve() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; b[i]; int st1 = a[1], ed1 = a[n], st2 = b[1], ed2 = b[n]; int t1, t2, t3, t4; t1 = t2 = t3 = t4 = INF; int idx1, idx2, idx3, idx4; for(int i = 1; i &lt;= n; i ++) { t1 = min(t1, abs(b[i] - st1)); t2 = min(t2, abs(b[i] - ed1)); t3 = min(t3, abs(a[i] - st2)); t4 = min(t4, abs(a[i] - ed2)); } int res = t1 + t2 + t3 + t4; res = min(res, min(abs(st1 - ed2) + abs(st2 - ed1), abs(st1 - st2) + abs(ed1 - ed2))); res = min(res, min(abs(st1 - st2) + t2 + t4, abs(ed1 - ed2) + t1 + t3)); res = min(res, min(abs(st1 - ed2) + t2 + t3, abs(st2 - ed1) + t1 + t4)); cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1646C- Factorials and Powers of Two å®šä¹‰å¥½æ•°ï¼šå¦‚æœæŸä¸ªæ•°å¯ä»¥è¢«è¡¨ç¤ºä¸ºd!d!d!æˆ–2d2^d2dï¼Œåˆ™è¿™ä¸ªæ•°è¢«ç§°ä¸ºå¥½æ•° ç»™å®šä¸€ä¸ªæ•°nnnï¼Œæ±‚nnnæœ€å°‘å¯ä»¥è¢«æ‹†åˆ†æˆå¤šå°‘ä¸ªå¥½æ•°çš„å’Œ æ•°æ®èŒƒå›´ï¼š1â‰¤nâ‰¤10121 \\leq n \\leq 10^{12}1â‰¤nâ‰¤1012 é¦–å…ˆä»»ä½•ä¸€ä¸ªæ­£æ•´æ•°ä¸€å®šå¯ä»¥è¢«æ‹†åˆ†æˆè‹¥å¹²ä¸ªå¥½æ•°çš„å’Œï¼Œå› ä¸ºè¯¥æ•°ä¸€å®šå¯ä»¥ç”±äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œä¸”æœ€å¤šæ‹†ä¸ºäºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•° ç„¶åå¯ä»¥å‘ç°ï¼Œ101210^{12}1012ä»¥å†…çš„é˜¶ä¹˜æ•°å¾ˆå°‘ï¼Œæœ€å¤šåªæœ‰15ä¸ª äºæ˜¯æ–¹æ³•éå¸¸æ˜¾ç„¶ï¼šæšä¸¾é˜¶ä¹˜æ•°çš„æ‰€æœ‰ä½¿ç”¨æƒ…å†µçš„æ€»å’Œï¼Œå‰©ä¸‹çš„æ•°ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œç­”æ¡ˆå–æœ€å°å€¼ï¼Œé‡‡ç”¨DFSæš´æœå³å¯ // Problem: C. Factorials and Powers of Two // Contest: Codeforces - Codeforces Round #774 (Div. 2) // URL: https://codeforces.com/problemset/problem/1646/C // Memory Limit: 256 MB // Time Limit: 3000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int n; int p[50], cnt; bool v[50]; void init() { int t = 1; for(int i = 1; i &lt;= 15; i ++) { t *= i; p[i] = t; } } int dfs(int fac, int val, int idx) { if(val &lt; 0) return 1e18; else if(fac == 16) { int res = 0; while(val &gt; 0) { if(val &amp; 1) res ++; val &gt;&gt;= 1; } return res + idx; } else return min(dfs(fac + 1, val, idx), dfs(fac + 1, val - p[fac], idx + 1)); } void solve() { int n; cin &gt;&gt; n; cout &lt;&lt; dfs(1, n, 0) &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; init(); while(T --) { solve(); } return 0; }","categories":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://memsetray.github.io/categories/é¢˜è§£/"}],"tags":[],"keywords":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://memsetray.github.io/categories/é¢˜è§£/"}]},{"title":"CodeForces2000-2300éš¾åº¦éƒ¨åˆ†é¢˜é¢˜è§£","slug":"CodeForces2000-2300éš¾åº¦éƒ¨åˆ†é¢˜é¢˜è§£","date":"2022-09-05T00:35:49.000Z","updated":"2022-09-05T14:53:28.406Z","comments":true,"path":"2022/09/05/CodeForces2000-2300éš¾åº¦éƒ¨åˆ†é¢˜é¢˜è§£/","link":"","permalink":"https://memsetray.github.io/2022/09/05/CodeForces2000-2300éš¾åº¦éƒ¨åˆ†é¢˜é¢˜è§£/","excerpt":"","text":"Codeforces 2000-2300 éš¾åº¦é¢˜è§£ 808G-Anthem of Berland é¢˜ç›®æè¿°ï¼šç»™å®š sss ä¸²å’Œ ttt ä¸²ï¼Œå…¶ä¸­ sss ä¸²åŒ…å«å°å†™å­—æ¯å’Œé—®å·ï¼Œttt ä¸²åªåŒ…å«å°å†™å­—æ¯ã€‚ å‡è®¾å…±æœ‰ kkk ä¸ªé—®å·ã€‚ ä½ éœ€è¦ç»™æŠŠæ¯ä¸ªé—®å·å˜æˆä¸€ä¸ªå°å†™å­—æ¯ï¼Œå…±æœ‰ 26k26^k26k ç§å¯èƒ½ã€‚ å¯¹äºæ¯ç§å¯èƒ½ï¼Œè®¾ ttt åŒ¹é… sss çš„æ¬¡æ•°ä¸º fif_ifiâ€‹ï¼Œè¯·è¾“å‡º maxâ¡(fi)\\max(f_i)max(fiâ€‹) ã€‚ æ•°æ®èŒƒå›´ï¼š1â‰¤âˆ£sâˆ£,âˆ£tâˆ£â‰¤105,âˆ£sâˆ£âˆ—âˆ£tâˆ£â‰¤1071 \\leq |s|,|t| \\leq 10^5,|s|*|t| \\leq 10^71â‰¤âˆ£sâˆ£,âˆ£tâˆ£â‰¤105,âˆ£sâˆ£âˆ—âˆ£tâˆ£â‰¤107 é¢˜è§£ï¼šKMPè‡ªåŠ¨æœºï¼šæ„å»ºä¸€ä¸ªæ•°ç»„aut[i][c]aut[i][c]aut[i][c]ï¼Œè¡¨ç¤ºæ¨¡å¼ä¸²çš„å‰iâˆ’1i - 1iâˆ’1ä½å·²ç»åŒ¹é…å®Œæˆï¼Œç”¨cccä¸tit_itiâ€‹åŒ¹é…åçš„åŒ¹é…é•¿åº¦ æ„é€ æ–¹å¼ï¼šå…ˆæ±‚å‡ºnextnextnextæ•°ç»„ aut[i][c]={aut[next[iâˆ’1]+1][c],i=1âˆ£âˆ£tiâ‰ ci+[ti=c],a&lt;1aut[i][c] = \\begin{cases} aut[next[i - 1] + 1][c],&amp;i = 1 || t_i \\neq c \\\\ i + [t_i = c],&amp;a &lt; 1 \\end{cases} aut[i][c]={aut[next[iâˆ’1]+1][c],i+[tiâ€‹=c],â€‹i=1âˆ£âˆ£tiâ€‹î€ â€‹=ca&lt;1â€‹ é¦–å…ˆæ„å»ºKMPè‡ªåŠ¨æœºï¼Œç„¶åè€ƒè™‘DP è®¾dp[i][j]dp[i][j]dp[i][j]ä¸ºå½“å‰æ‰«æåˆ°sssçš„ç¬¬iiiä½ï¼Œåœ¨KMPè‡ªåŠ¨æœºä¸Šçš„èŠ‚ç‚¹jjjåŒ¹é…çš„æœ€å¤§æ¬¡æ•° çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š dp[i][j]=max(dp[i][j],dp[iâˆ’1][j]+(j==m))dp[i][j] = max(dp[i][j], dp[i - 1][j] + (j == m))dp[i][j]=max(dp[i][j],dp[iâˆ’1][j]+(j==m)) ç­”æ¡ˆä¸ºâˆ‘âˆ£tâˆ£1max(dp[âˆ£sâˆ£][i])\\sum^1_{|t|} max(dp[|s|][i])âˆ‘âˆ£tâˆ£1â€‹max(dp[âˆ£sâˆ£][i])ï¼Œæ—¶é—´å¤æ‚åº¦O(âˆ£sâˆ£âˆ—âˆ£tâˆ£âˆ—26)O(|s|*|t|*26)O(âˆ£sâˆ£âˆ—âˆ£tâˆ£âˆ—26) // Problem: G. Anthem of Berland // Contest: Codeforces - Educational Codeforces Round 21 // URL: https://codeforces.com/contest/808/problem/G // Memory Limit: 256 MB // Time Limit: 3000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 1e5 + 10; int n, m; int dp[2][N]; int ne[N], aut[N][26]; char s[N], t[N]; void init_ne() { ne[1] = 0; for(int i = 2, j = 0; i &lt;= m; i ++) { while(j &amp;&amp; t[i] != t[j + 1]) j = ne[j]; if(t[i] == t[j + 1]) j ++; ne[i] = j; } } void init_KMPAM() { for(int i = 1; i &lt;= m; i ++) { for(int c = 0; c &lt; 26; c ++) { if(i &gt; 1 &amp;&amp; t[i] != c + 'a') aut[i][c] = aut[ne[i - 1] + 1][c]; else aut[i][c] = i + (t[i] == c + 'a'); } } } void dp_KMP() { memset(dp, 0xcf, sizeof dp); //åˆå§‹åŒ–è´Ÿæ— ç©· dp[0][1] = 0; for(int i = 1; i &lt;= n; i ++) { if(s[i] == '?') { for(int j = 1; j &lt;= m; j ++) { for(int c = 0; c &lt; 26; c ++) dp[i &amp; 1][aut[j][c]] = max(dp[i &amp; 1][aut[j][c]], dp[(i - 1) &amp; 1][j] + (aut[j][c] == m)); } } else { for(int j = 1; j &lt;= m; j ++) dp[i &amp; 1][aut[j][s[i] - 'a']] = max(dp[i &amp; 1][aut[j][s[i] - 'a']], dp[(i - 1) &amp; 1][j] + (aut[j][s[i] - 'a'] == m)); } for(int j = 1; j &lt;= m; j ++) dp[(i - 1) &amp; 1][j] = -0x3f3f3f3f; } } void solve() { cin &gt;&gt; (s + 1) &gt;&gt; (t + 1); n = strlen(s + 1), m = strlen(t + 1); t[++ m] = '#'; //åŠ ç‰¹æ®Šå­—ç¬¦ init_ne(); init_KMPAM(); dp_KMP(); int mmax = 0; for(int j = 1; j &lt;= m; j ++) mmax = max(mmax, dp[n &amp; 1][j]); cout &lt;&lt; mmax &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } 1721E- Prefix Function Queries é¢˜ç›®å¤§æ„ï¼šç»™å®šå­—ç¬¦ä¸²sss,ä»¥åŠqqqä¸ªä¸²tit_itiâ€‹ï¼Œæ±‚å°†sssåˆ†åˆ«ä¸æ¯ä¸ªtit_itiâ€‹æ‹¼æ¥èµ·æ¥åï¼Œæœ€é å³çš„âˆ£tiâˆ£|t_i|âˆ£tiâ€‹âˆ£ä¸ªå‰ç¼€çš„borderé•¿åº¦ï¼Œæ¯ä¸ªè¯¢é—®ç›¸äº’ç‹¬ç«‹ æ•°æ®èŒƒå›´ï¼šâˆ£sâˆ£â‰¤106,qâ‰¤105,âˆ£tiâˆ£â‰¤10|s| \\leq 10^6, q \\leq 10^5, |t_i| \\leq 10âˆ£sâˆ£â‰¤106,qâ‰¤105,âˆ£tiâ€‹âˆ£â‰¤10 é¢˜è§£ï¼šå¯¹åŸä¸²sssæ±‚KMPè‡ªåŠ¨æœºï¼Œæ¯æ¬¡è¯¢é—®åœ¨çº¿æ„é€ s+ts + ts+tä¸­tttéƒ¨åˆ†çš„KMPè‡ªåŠ¨æœºï¼Œè¾“å‡ºå¯¹åº”çš„nextå€¼å³å¯ // Problem: E. Prefix Function Queries // Contest: Codeforces - Educational Codeforces Round 134 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1721/E // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; using namespace std; const int N = 1e6 + 10; char s[N]; int ne[N], aut[N][27]; int n, m; void init_next() { ne[1] = 0; for(int i = 2, j = 0; i &lt;= n; i ++) { while(j &amp;&amp; s[i] != s[j + 1]) j = ne[j]; if(s[i] == s[j + 1]) j ++; ne[i] = j; } } void init_KMPAM() { for(int i = 0; i &lt; n; i ++) { for(int c = 1; c &lt;= 26; c ++) { aut[i][c] = aut[ne[i]][c]; } aut[i][s[i + 1] - 'a' + 1] = i; } } void solve() { int q; cin &gt;&gt; (s + 1); n = strlen(s + 1); init_next(); init_KMPAM(); cin &gt;&gt; q; while(q --) { cin &gt;&gt; (s + n + 1); m = n + strlen(s + n + 1); for(int i = n + 1, k = ne[n]; i &lt;= m; i ++) { int id = i - 1; k = aut[k][s[i] - 'a' + 1]; if(s[i] == s[k + 1]) k ++; ne[i] = k; cout &lt;&lt; k &lt;&lt; &quot; &quot;; for(int c = 1; c &lt;= 26; c ++) aut[id][c] = aut[ne[id]][c]; aut[id][s[i] - 'a' + 1] = id; } cout &lt;&lt; endl; } } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } 1712D- Empty Graph é¢˜ç›®å¤§æ„ï¼šç»™å®šä¸€ä¸ªé•¿åº¦ä¸ºnnnçš„åºåˆ—aaa å®šä¹‰ä¸€ä¸ªnnnä¸ªç‚¹çš„æ— å‘å®Œå…¨å›¾ï¼Œç‚¹lllå’Œç‚¹rrrä¹‹é—´çš„è·ç¦»ä¸ºminlâ‰¤iâ‰¤r{a[i]}\\underset{l\\leq i \\leq r}{min} \\{a[i]\\}lâ‰¤iâ‰¤rminâ€‹{a[i]} ä½ å¯ä»¥è¿›è¡Œkkkæ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥é€‰å®š1âˆ’n1-n1âˆ’nä¸­ä»»æ„ä¸€ä¸ªæ•°å¹¶å°†aia_iaiâ€‹èµ‹å€¼ä¸ºä¸€ä¸ª[1,109][1,10^9][1,109]çš„æ•´æ•°ï¼Œè¯·æœ€å¤§åŒ–è¿™ä¸ªå›¾çš„ç›´å¾„ã€‚ å›¾çš„ç›´å¾„å®šä¹‰ä¸ºmax1â‰¤uâ‰¤vâ‰¤nd(u,v)\\underset{1 \\leq u \\leq v \\leq n}{max}d(u,v)1â‰¤uâ‰¤vâ‰¤nmaxâ€‹d(u,v)ï¼Œå…¶ä¸­d(u,v)d(u,v)d(u,v)ä¸ºuuuåˆ°vvvçš„æœ€çŸ­è·¯é•¿åº¦ã€‚ é¢˜è§£ï¼šæœ¬é¢˜çš„ç­”æ¡ˆå…·æœ‰æœ€å¤§å€¼æœ€å°çš„æ€§è´¨ï¼Œè€ƒè™‘äºŒåˆ†ç­”æ¡ˆ é¦–å…ˆéœ€è¦å‘ç°ä¸€ä¸ªæ€§è´¨ï¼šå¯¹äºä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯ï¼Œæœ€å¤šèµ°ä¸¤æ¡è¾¹ï¼Œè¦ä¹ˆèµ°ä¸¤ç‚¹ç›´æ¥ç›¸è¿çš„è¾¹ï¼Œè¦ä¹ˆå…ˆèµ°ä¸€ä¸ªæœ€å°è¾¹èµ°åˆ°æŸä¸ªç‚¹ï¼Œå†ä»è¿™ä¸ªç‚¹èµ°åˆ°ç›®æ ‡ç‚¹ ï¼Œå³ d(u,v)=min(e(u,v),2âˆ—mmin)d(u,v) = min(e(u,v),2*mmin) d(u,v)=min(e(u,v),2âˆ—mmin) å…¶ä¸­mminmminmminä¸ºmin1â‰¤iâ‰¤n{ai}\\underset{1 \\leq i \\leq n}{min} \\{ai\\}1â‰¤iâ‰¤nminâ€‹{ai},e(u,v)=minuâ‰¤iâ‰¤vâˆ’1(e(ai,ai+1))e(u,v) = \\underset{u \\leq i \\leq v - 1}{min}(e(a_i,a_{i + 1}))e(u,v)=uâ‰¤iâ‰¤vâˆ’1minâ€‹(e(aiâ€‹,ai+1â€‹)) è®¾å›¾çš„ç›´å¾„ä¸ºlllï¼Œç”±æ­¤å¯å¾—ï¼š \\begin{align} l &amp;= max(min(e(u,v), 2*mmin)) \\\\ &amp;= min(max(e(u,v)), 2*mmin) \\\\ &amp;= min(max(\\underset{1 \\leq i \\leq n - 1}{min}(a_i, a_{i + 1})), 2 * mmin) \\end{align} è‡³æ­¤æˆ‘ä»¬å·²ç»çŸ¥é“å¦‚ä½•äºŒåˆ†ç­”æ¡ˆï¼š è®¾å½“å‰äºŒåˆ†çš„ç­”æ¡ˆä¸ºmidmidmidï¼Œæˆ‘ä»¬éœ€è¦å°†æ‰€æœ‰å€¼å°äºç­‰äºmid2\\frac{mid}{2}2midâ€‹çš„ç‚¹èµ‹å€¼ä¸º10910^9109ï¼Œå› ä¸ºè¿™äº›ç‚¹èµ°ä¸¤æ¬¡ä¹‹åä¾ç„¶æ¯”ç­”æ¡ˆå°ï¼Œæˆ‘ä»¬å°±ä¸€å®šè¦ä¿®æ”¹è¿™äº›è¾¹ï¼ŒåŒæ—¶è®°å½•ä¿®æ”¹çš„æ¬¡æ•° å¦‚æœè¢«ä¿®æ”¹æ¬¡æ•°å¤§äºkkkï¼Œåˆ™æ˜¾ç„¶ä¸åˆæ³• å¦‚æœè¢«ä¿®æ”¹æ¬¡æ•°ç­‰äºkkkï¼Œæˆ‘ä»¬éœ€è¦æ±‚å‡ºæ­¤æ—¶çš„ç›´å¾„lllï¼Œå¦‚æœl&gt;=midl &gt;= midl&gt;=midï¼Œé‚£ä¹ˆmidmidmidæ˜¾ç„¶åˆæ³• å¦‚æœè¢«ä¿®æ”¹æ¬¡æ•°å°äºkkkï¼Œæˆ‘ä»¬éœ€è¦åˆ†ç±»è®¨è®ºä¸€ä¸‹ï¼š â€‹ å¦‚æœk&gt;1k &gt;1k&gt;1ï¼Œè¯´æ˜æˆ‘ä»¬è¿˜æœ‰æ›´å¤šä¿®æ”¹ä½™åœ°ï¼Œå·²ç»ä¸éœ€è¦ä¿®æ”¹äº†ï¼Œé‚£ä¹ˆä¸€å®šåˆæ³• â€‹ å¦‚æœk=1k = 1k=1ï¼Œè¯´æ˜ä¸å­˜åœ¨å°äºç­‰äºmid2\\frac{mid}{2}2midâ€‹çš„ç‚¹ï¼Œæ­¤æ—¶æˆ‘ä»¬ä»…èƒ½ä¿®æ”¹ä¸€æ¡è¾¹ï¼Œè§‚å¯Ÿä¸Šé¢çš„å…¬å¼ï¼Œæˆ‘ä»¬éœ€è¦æ±‚å‡ºmax(min1â‰¤iâ‰¤nâˆ’1(ai,ai+1))max(\\underset{1 \\leq i \\leq n - 1}{min}(a_i, a_{i + 1}))max(1â‰¤iâ‰¤nâˆ’1minâ€‹(aiâ€‹,ai+1â€‹)) â€‹ æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬åªéœ€è¦æ±‚å‡ºæ˜¯å¦å­˜åœ¨aiâ‰¥mida_i \\geq midaiâ€‹â‰¥midï¼Œå¦‚æœå­˜åœ¨ï¼Œæˆ‘ä»¬å°±è¦æŠŠä¸ä»–ç›¸é‚»çš„å¦ä¸€ä¸ªæ”¹æˆ10910^9109å³å¯ã€‚ // Problem: D. Empty Graph // Contest: Codeforces - Codeforces Round #813 (Div. 2) // URL: https://codeforces.com/problemset/problem/1712/D // Memory Limit: 256 MB // Time Limit: 1500 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 1e5 + 10; int n, k; bool check(vector&lt;int&gt; a, int mid, int t) { for(int i = 0; i &lt; a.size(); i ++) if(a[i] * 2 &lt; mid) t --, a[i] = 1e9; if(t &lt; 0) return false; if(t == 0) { for(int i = 0; i &lt; a.size() - 1; i ++) if(min(a[i], a[i + 1]) &gt;= mid) return true; } else if(t == 1) return *max_element(a.begin(), a.end()) &gt;= mid; else return true; return false; } void solve() { vector&lt;int&gt; a; cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i ++) { int x; cin &gt;&gt; x; a.push_back(x); } int l = 1, r = 1e9; while(l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if(check(a, mid, k)) l = mid; else r = mid - 1; } cout &lt;&lt; l &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1706E- Qpwoeirut and Vertices é¢˜ç›®å¤§æ„ï¼šç»™å‡ºnnnä¸ªç‚¹ï¼Œmmmæ¡è¾¹çš„ä¸å¸¦æƒè¿é€šæ— å‘å›¾ï¼Œqqqæ¬¡è¯¢é—®è‡³å°‘è¦åŠ å®Œç¼–å·å‰å¤šå°‘çš„è¾¹ï¼Œæ‰èƒ½ä½¿å¾—[l,r][l,r][l,r]ä¸­çš„æ‰€æœ‰ç‚¹ä¸¤ä¸¤è¿é€šã€‚ é¢˜è§£ï¼šå‰ç½®çŸ¥è¯†ï¼šKruskalé‡æ„æ ‘\\textcolor{pink}{Kruskalé‡æ„æ ‘}Kruskalé‡æ„æ ‘ KruskalKruskalKruskalé‡æ„æ ‘æ˜¯å°†ä¸€å¼ æ— å‘å›¾ç»è¿‡KruskalKruskalKruskalç®—æ³•å¾—åˆ°æœ€å°ç”Ÿæˆæ ‘åï¼Œå†å°†å…¶é‡å»ºæˆä¸€é¢—äºŒå‰æ ‘ï¼ŒåŸå›¾ä¸­æ‰€æœ‰çš„å¶å­ç»“ç‚¹éƒ½æ˜¯åŸå›¾ä¸­çš„ç‚¹ï¼Œå…¶ä»–ç‚¹å…·æœ‰ä¸€ä¸ªç‚¹æƒwwwï¼Œè¡¨ç¤ºå·¦é›†åˆåˆ°å³é›†åˆçš„è¾¹æƒã€‚ KruskalKruskalKruskalé‡æ„æ ‘çš„æ€§è´¨ï¼šåŸå›¾ä¸­ä¸¤ç‚¹ä¹‹é—´æ‰€æœ‰ç®€å•è·¯å¾„ä¸Šæœ€å¤§è¾¹æƒçš„æœ€å°å€¼=æœ€å°ç”Ÿæˆæ ‘ä¸Šä¸¤ä¸ªç‚¹ä¹‹é—´çš„ç®€å•è·¯å¾„ä¸Šçš„æœ€å¤§å€¼=KruskalKruskalKruskalé‡æ„æ ‘ä¸Šä¸¤ç‚¹ä¹‹é—´LCAçš„æƒå€¼ eg1eg_1eg1â€‹ï¼šæ±‚èŠ‚ç‚¹uuuåˆ°èŠ‚ç‚¹vvvè·¯å¾„çš„æœ€å¤§è¾¹æƒï¼Œå°±æ˜¯æ±‚LCA(u,v)LCA(u,v)LCA(u,v)çš„ç‚¹æƒ eg2eg_2eg2â€‹:ä»ç‚¹uuuå‡ºå‘ï¼Œç»™å®šä¸€ä¸ªå€¼tttï¼Œåœ¨é€šè¿‡æ‰€æœ‰è¾¹çš„æƒå€¼å°äºç­‰äºtttæ—¶ï¼Œèµ°è¿‡äº†å¤šå°‘ä¸ªç‚¹ =&gt;=&gt;=&gt;ä»ç‚¹uuuå‘ä¸Šæ‰¾ï¼Œæ‰¾åˆ°æœ€åä¸€ä¸ªå°äºç­‰äºtttçš„è™šç‚¹ï¼Œå­æ ‘ä¸­çš„ç‚¹éƒ½å¯ä»¥é€šè¿‡ï¼ˆå› ä¸ºé‡æ„æ ‘ä¸Šçš„ç‚¹ä»ä¸Šå¾€ä¸‹ç‚¹æƒå•è°ƒä¸å‡ï¼‰ å›åˆ°è¿™é“é¢˜ï¼Œç»“è®ºæ˜¾è€Œæ˜“è§ï¼šä½¿å¾—(u,v)(u,v)(u,v)ä¹‹é—´ä¸¤ä¸¤è¿é€šçš„æœ€å°è¾¹æƒä¸ºé‡æ„æ ‘ä¸Šçš„v(LCA(u,v))v(LCA(u,v))v(LCA(u,v))ï¼Œå…¶ä¸­vvvä¸ºç‚¹æƒã€‚ å‰©ä¸‹çš„é—®é¢˜æ˜¯å¤„ç†æ‰€æœ‰è¯¢é—®ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨STè¡¨é¢„å¤„ç†æ‰€æœ‰è¯¢é—®ï¼Œæˆ–è€…é‡‡ç”¨çº¿æ®µæ ‘ã€‚å¤šä¸ªç‚¹çš„LCALCALCAçš„æ±‚æ³•ï¼šå–å‡ºå…¶ä¸­dfndfndfnæœ€å°å’Œæœ€å¤§çš„ç‚¹æ±‚LCALCALCAå³ä¸ºç­”æ¡ˆã€‚ // Problem: E. Qpwoeirut and Vertices // Contest: Codeforces - Codeforces Round #809 (Div. 2) // URL: https://codeforces.com/problemset/problem/1706/E // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 1e5 + 10, M = N * 2; struct Edge{ int x, y; }e[M]; struct D{ int l, r, c; int fa[20]; int p; int depth; }d[M]; int n, m, q; int t[N * 4]; void init() { for(int i = 1; i &lt;= n; i ++) { memset(d[i].fa, 0, sizeof d[i].fa); d[i].p = d[i].l = d[i].r = d[i].c = 0; } } int find(int x) { if(d[x].p != x) d[x].p = find(d[x].p); return d[x].p; } void merge_seg(int x, int y, int c) { int px = find(x), py = find(y); if(px == py) return ; else n ++; d[px].p = d[py].p = d[n].p = n; d[px].fa[0] = d[py].fa[0] = n; d[n].l = px, d[n].r = py, d[n].c = c; } void kruskal() { for(int i = 1; i &lt;= n; i ++) d[i].p = i; for(int i = 1; i &lt;= m; i ++) merge_seg(e[i].x, e[i].y, i); } void dfs(int x) { if(x == 0) return ; d[x].depth = d[d[x].fa[0]].depth + 1; for(int i = 1; i &lt;= 18; i ++) d[x].fa[i] = d[d[x].fa[i - 1]].fa[i - 1]; dfs(d[x].l); dfs(d[x].r); } int lca(int x, int y) { if(d[x].depth &lt; d[y].depth) swap(x, y); for(int i = 18; i &gt;= 0; i --) if(d[d[x].fa[i]].depth &gt;= d[y].depth) x = d[x].fa[i]; if(x == y) return y; for(int i = 18; i &gt;= 0; i --) if(d[x].fa[i] != d[y].fa[i]) { x = d[x].fa[i]; y = d[y].fa[i]; } return d[y].fa[0]; } int build(int x, int l ,int r) { int mid = l + r &gt;&gt; 1; if(l == r) t[x] = mid; else t[x] = lca(build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r)); return t[x]; } int query(int x, int l, int r, int a, int b) { int mid = l + r &gt;&gt; 1; if(a == l &amp;&amp; b == r) return t[x]; else { if(b &lt;= mid) return query(x &lt;&lt; 1, l, mid, a, b); if(a &gt; mid) return query(x &lt;&lt; 1 | 1, mid + 1, r, a, b); return lca(query(x &lt;&lt; 1, l, mid, a, mid), query(x &lt;&lt; 1 | 1, mid + 1, r, mid + 1, b)); } } void solve() { init(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; int nn = n; for(int i = 1; i &lt;= m; i ++) cin &gt;&gt; e[i].x &gt;&gt; e[i].y; kruskal(); dfs(n); build(1, 1, nn); for(int i = 1; i &lt;= q; i ++) { int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; d[query(1, 1, nn, l, r)].c &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; }","categories":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://memsetray.github.io/categories/é¢˜è§£/"}],"tags":[],"keywords":[{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://memsetray.github.io/categories/é¢˜è§£/"}]}]}