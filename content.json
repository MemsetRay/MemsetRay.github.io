{"meta":{"title":"Ray's Blog","subtitle":null,"description":"少女祈祷中...","author":"Ray","url":"https://memsetray.github.io"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2022-09-05T05:22:49.110Z","comments":false,"path":"about/index.html","permalink":"https://memsetray.github.io/about/index.html","excerpt":"","text":"[Ray的个人介绍] 与&nbsp; Ray&nbsp; （ 菜 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2022-09-05T07:08:19.594Z","comments":false,"path":"bangumi/index.html","permalink":"https://memsetray.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"client/index.html","permalink":"https://memsetray.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2022-09-04T13:36:18.224Z","comments":false,"path":"music/index.html","permalink":"https://memsetray.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"comment/index.html","permalink":"https://memsetray.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"donate/index.html","permalink":"https://memsetray.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2022-09-05T11:48:37.852Z","comments":false,"path":"lab/index.html","permalink":"https://memsetray.github.io/lab/index.html","excerpt":"","text":"Blog更新日志 2022年9月4日：博客搭建完成，正式开始使用 2022年9月5日：修复了个人介绍，添加了Waline评论系统，修复了各种图片裂开问题 ToDo 完善清单：番组与图集 完善归档：技术、随想、生活等 添加说说 修复或者移除打赏 修复社交链接 添加视频 …","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2022-09-05T07:22:01.793Z","comments":true,"path":"links/index.html","permalink":"https://memsetray.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"rss/index.html","permalink":"https://memsetray.github.io/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"tags/index.html","permalink":"https://memsetray.github.io/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"video/index.html","permalink":"https://memsetray.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://memsetray.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"随想test","slug":"随想test","date":"2022-09-05T14:54:56.000Z","updated":"2022-09-05T14:57:17.992Z","comments":true,"path":"2022/09/05/随想test/","link":"","permalink":"https://memsetray.github.io/2022/09/05/随想test/","excerpt":"","text":"为什么我FPS玩的这么菜！！！！","categories":[{"name":"随想","slug":"随想","permalink":"https://memsetray.github.io/categories/随想/"}],"tags":[],"keywords":[{"name":"随想","slug":"随想","permalink":"https://memsetray.github.io/categories/随想/"}]},{"title":"CodeForces1500-1600部分题题解","slug":"CodeForces1500-1600部分题题解","date":"2022-09-05T04:02:58.000Z","updated":"2022-09-05T14:53:15.719Z","comments":true,"path":"2022/09/05/CodeForces1500-1600部分题题解/","link":"","permalink":"https://memsetray.github.io/2022/09/05/CodeForces1500-1600部分题题解/","excerpt":"","text":"Codeforces 1500 - 1600难度笔记 1675E- Replace With the Previous, Minimize 给定一个长度为n的字符串，有k次操作，每次操作可以选一个字母，让所有该字母变成字典序的前一个字母，求能够通过k次操作得到的最小字典序。 贪心，维护一个max_idx表示从a到a + max_idx中的字母都可以通过max_idx次操作转化为a 如果当前字母转换为a的操作数 ≤k\\leq k≤k ,则直接更新max_idx 如果当前字母转换为a的操作数&gt;k&gt; k&gt;k，则该字母最多只能进行k−midxk - midxk−midx次操作，设当前字母为sss，则s−(k−midx)s-(k - midx)s−(k−midx) 到sss区间内的字母都可以转化为s−(k−midx)s - (k - midx)s−(k−midx)，因此直接将其转化为s−(k−midx)s - (k - midx)s−(k−midx) // Problem: E. Replace With the Previous, Minimize // Contest: Codeforces - Codeforces Round #787 (Div. 3) // URL: https://codeforces.com/problemset/problem/1675/E // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; string s; cin &gt;&gt; s; int max_idx = 0; for(int i = 0; i &lt; s.size(); i ++) { int t = s[i] - 'a'; if(t &lt;= k) max_idx = max(max_idx, t); else { char min_c = s[i] - k + max_idx; char max_c = s[i]; for(int j = 0; j &lt; s.size(); j ++) { if(min_c &lt;= s[j] &amp;&amp; s[j] &lt;= max_c) s[j] = min_c; } break; } } for(int i = 0; i &lt; s.size(); i ++) { if(s[i] - 'a' &lt;= max_idx) s[i] = 'a'; } cout &lt;&lt; s &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1673C- Palindrome Basis 给定一个数n，问有多少种拼法满足n可以被若干回文数拼成 回文数指正着看和倒着看的值相同的数 1≤n≤400001 \\leq n \\leq 400001≤n≤40000 首先观察到n的值域很小，直觉上告诉我们40000以内的回文数数量不多（事实上只有500个左右），因此我们先将n以内的回文数预处理出来。 剩下的问题就是，如何将n用回文数拼出来，这是一个经典的DP问题 设dp[i][j]表示从前i个回文数中选，拼成的数为j的方案数 于是状态转移方程非常显然： dp[i][j]=dp[i−1][j]+dp[i][j−p[i]]dp[i][j] = dp[i - 1][j] + dp[i][j - p[i]]dp[i][j]=dp[i−1][j]+dp[i][j−p[i]] 其中p[i]表示的是第i个回文数是多少 边界：∑i=1M−1dp[i][0]=1\\sum_{i=1}^{M - 1}dp[i][0] = 1∑i=1M−1​dp[i][0]=1，其中M - 1为回文数的个数 目标：dp[M−1][n]dp[M - 1][n]dp[M−1][n] // Problem: C. Palindrome Basis // Contest: Codeforces - Codeforces Round #785 (Div. 2) // URL: https://codeforces.com/problemset/problem/1673/C // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 4e4 + 10, M = 510, mod = 1e9 + 7; int dp[510][N]; vector&lt;int&gt; p; int reverse_i(int a) { int res = 0; while(a &gt; 0) { res = res * 10 + a % 10; a /= 10; } return res; } void init() { p.push_back(0); for(int i = 1; i &lt; N; i ++) { if(reverse_i(i) == i) p.push_back(i); } } void solve() { for(int i = 1; i &lt; M; i ++) dp[i][0] = 1; for(int i = 1; i &lt; M; i ++) { for(int j = 1; j &lt; N; j ++) { if(p[i] &lt;= j) dp[i][j] = (dp[i - 1][j] + dp[i][j - p[i]]) % mod; else dp[i][j] = dp[i - 1][j]; } } } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; init(); solve(); while(T --) { int n; cin &gt;&gt; n; cout &lt;&lt; dp[M - 1][n] % mod &lt;&lt; endl; } return 0; } 1665C- Tree Infection 给定一个n个节点的数，一开始n个节点都是健康的，每秒可以进行两种操作 选定一个节点，将其感染 如果节点v有一个子节点被感染，那么将传播到另一个子节点 求将所有节点传染所需的最小秒数 通过观察可以发现，任意两个不同的节点，它们的子节点互相独立，我们只关心每个节点有多少个儿子。 于是问题简化为：给定k个数，每个数表示该节点的子节点数量，每秒所有数减少1，并且你可以额外选择一个数使其减少1，求至少需要多少秒使得数组中所有数小于等于0 首先预处理出每个节点的子节点数量，将其从大到小排序并排除所有的0, 此时根据贪心，我们应该从大到小将所有子树先感染一遍，然后再次从大到小排序并排除所有小于等于0的数 之后，我们每次需要将数组中的所有数减1，并额外选择一个数减1，显然每次额外选择都应该选数组中最大的数，我们不断模拟这个过程，并且每次记录最大值最后出现下标last，额外操作就应当选择last对应的数，这样可以保证序列始终为单调递减。 // Problem: C. Tree Infection // Contest: Codeforces - Codeforces Round #781 (Div. 2) // URL: https://codeforces.com/problemset/problem/1665/C // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10, M = N * 2; int n; int res; void calc(vector&lt;int&gt; a) { if(a.empty()) return; int n = a.size(); int last = 0; for(int i = 0; i &lt; n; i ++) { if(a[i] == a[0]) last = i; else break; } -- a[last]; for(int i = 0; i &lt; n; i ++) a[i] --; res ++; while(a.size() &amp;&amp; a.back() &lt;= 0) a.pop_back(); calc(a); } void solve() { cin &gt;&gt; n; vector&lt;int&gt; a(n); for(int i = 1; i &lt; n; i ++) { int x; cin &gt;&gt; x; a[-- x] ++; } a.push_back(1); sort(a.begin(), a.end(), greater&lt;int&gt;()); while(a.size() &amp;&amp; a.back() &lt;= 0) a.pop_back(); n = a.size(); res = 0; for(int i = 0; i &lt; n; i ++) { a[i] = a[i] - (n - i); res ++; } sort(a.begin(), a.end(), greater&lt;int&gt;()); while(a.size() &amp;&amp; a.back() &lt;= 0) a.pop_back(); calc(a); cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1671D- Insert a Progression 给定一个数组a，再给出x个正整数1-x 将这x个数插入到数组a中（可以插入到任何一个位置，包括边界）得到a‘ a’的代价为数组中所有元素差的绝对值之和，求a’的最小代价 这道题最重要的是观察出结论：设原数组最大值为a，最小值为b，一定存在一种插入方式，使得数组a’中插入了大小为[a,b]的所有数，且满足代价不变。 一种比较好理解的方式是：假设原数组a中存在相邻的两个数axa_xax​,aya_yay​,不妨设ax&lt;aya_x &lt; a_yax​&lt;ay​,那么我们可以尝试在这两个数之间插入ay−ax−1a_y - a_x - 1ay​−ax​−1个正整数，而代价不变，因此所有在最值范围内的数都可以起到“桥梁”的作用。 因此我们需要先算出原数组的代价t，然后只需要看最值所覆盖的区间是否完全包含区间[1,x] 如果完全覆盖，则答案为t，否则考虑剩下的数如何放置 容易发现，除了1和x，剩下的所有数都是“桥梁”，对答案没有影响，因此我们只需要枚举1和x出现的位置，取最小值即可。 // Problem: D. Insert a Progression // Contest: Codeforces - Educational Codeforces Round 127 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1671/D // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int a[N]; int n, x; void solve() { cin &gt;&gt; n &gt;&gt; x; memset(a, 0, sizeof a); int res = 0; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; if(i &gt; 1) res += abs(a[i] - a[i - 1]); } int max_num = 0, min_num = 0x3f3f3f3f; for(int i = 1; i &lt;= n; i ++) { if(a[i] &gt; max_num) max_num = a[i]; if(a[i] &lt; min_num) min_num = a[i]; } if(x &gt; max_num) { if(n == 1) { res += x - a[1]; } else { int plus = 0x3f3f3f3f; for(int i = 1; i &lt; n; i ++) { plus = min(plus, x - a[i] + x - a[i + 1] - abs(a[i + 1] - a[i])); } plus = min(plus, min(x - a[n], x - a[1])); res += plus; } } if(min_num != 1) { if(n == 1) { res += a[1] - 1; } else { int plus = 0x3f3f3f3f; for(int i = 1; i &lt; n; i ++) { plus = min(plus, a[i] - 1 + a[i + 1] - 1 - abs(a[i + 1] - a[i])); } plus = min(plus, min(a[n] - 1, a[1] - 1)); res += plus; } } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1659C- Line Empire 你是一个国王，你有n个国家需要占领，起初你的首都在0位置处，现在你有两种操作： 将一个已经被占领的国家视为首都，代价为a∗∣c1−c2∣a *|c_1 - c_2|a∗∣c1​−c2​∣ 占领一个未被占领的国家，前提是这个国家与首都之间的所有国家都被占领，代价为b∗∣c1−c2∣b * |c_1 - c_2|b∗∣c1​−c2​∣ 其中c1,c2c_1,c_2c1​,c2​为两个国家的位置，求占领所有国家所需要的最小代价，最终首都可以在任何地方。 对于每个出现过的位置（包括0）我们都可以预处理出前缀和sum以及两个数组： 以该位置为首都，之后的所有国家都采用直接占领所需要的花费back[i]back[i]back[i] 在该位置之前，通过交替进行占领和替换首都使得该位置成为首都所需要的花费pre[i]pre[i]pre[i] 其中back[i]=(sum[n]−sum[i]−(n−i)∗x[i])∗bback[i] = (sum[n] - sum[i] - (n - i) * x[i]) * bback[i]=(sum[n]−sum[i]−(n−i)∗x[i])∗b pre[i]=x[i]∗(a+b)pre[i] = x[i] * (a + b)pre[i]=x[i]∗(a+b) 枚举所有的位置，答案即为min(pre[i]+back[i])min(pre[i] + back[i])min(pre[i]+back[i]) 为什么交替进行操作的方式一定是最优的：如果我们并没有采用交替的方式进行操作，就一定会连续进行若干次占领操作，之后仍然要通过替换操作使得首都到达目标位置，显然进行了多余的占领操作，代价变大。 // Problem: C. Line Empire // Contest: Codeforces - Codeforces Round #782 (Div. 2) // URL: https://codeforces.com/problemset/problem/1659/C // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int n, a, b; int x[N]; int sum[N]; int back[N]; int pre[N]; void solve() { cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; x[i]; for(int i = 1; i &lt;= n; i ++) { sum[i] = sum[i - 1] + x[i]; } for(int i = 0; i &lt;= n; i ++) { pre[i] = x[i] * (a + b); back[i] = (sum[n] - sum[i] - (n - i) * x[i]) * b; } int res = 1e18; for(int i = 0; i &lt;= n; i ++) { res = min(res, pre[i] + back[i]); } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1658D1- 388535 (Easy Version) 给定一个区间[l,r][l,r][l,r]，已知原数组是[l,r][l,r][l,r]的排列，现在给出原数组异或xxx后的数组，求出任意一个xxx的可能值 Easy Verson数据范围：0=l≤r&lt;2170 = l \\leq r &lt; 2^{17}0=l≤r&lt;217 由于位运算每一位独立，我们考虑每一位按位异或的值。 对于每个二进制位，分别统计当前排列（下标）中1的个数，以及当前数组元素中1的个数，如果不相同，说明当前这一位需要进行一次异或，即xxx的当前位为1，考虑完所有的位就得到了xxx. // Problem: D1. 388535 (Easy Version) // Contest: Codeforces - Codeforces Round #779 (Div. 2) // URL: https://codeforces.com/problemset/problem/1658/D1 // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = (1 &lt;&lt; 17) + 5; int l, r; int a[N]; void solve() { cin &gt;&gt; l &gt;&gt; r; for(int i = l; i &lt;= r; i ++) cin &gt;&gt; a[i]; int res = 0; for(int j = 0; j &lt;= 17; j ++) { int cnt_idx = 0, cnt_num = 0; for(int i = l; i &lt;= r; i ++) { if(i &amp; (1 &lt;&lt; j)) cnt_idx ++; if(a[i] &amp; (1 &lt;&lt; j)) cnt_num ++; } if(cnt_idx != cnt_num) res += 1 &lt;&lt; j; } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1658D2- 388535 (Hard Version) 给定一个区间[l,r][l,r][l,r]，已知原数组是[l,r][l,r][l,r]的排列，现在给出原数组异或xxx后的数组，求出任意一个xxx的可能值 Easy Verson数据范围：0≤l≤r&lt;2170 \\leq l \\leq r &lt; 2 ^ {17}0≤l≤r&lt;217 通过观察（或许）可以发现：aaa中一定存在一个数aia_iai​，使得ai⊕x=la_i \\oplus x = lai​⊕x=l，于是我们可以确定存在一个aia_iai​使得x=ai⊕lx = a_i\\oplus lx=ai​⊕l 由于aaa中的数互不相同，所以其中的数异或上xxx也互不相同，我们用数组bbb来存储ai⊕la_i \\oplus lai​⊕l的值，然后维护一个01Trie来查找bi⊕aib_i \\oplus a_ibi​⊕ai​的最大值和最小值，这个值bib_ibi​需要满足最大值为lll，最小值为rrr #include&lt;bits/stdc++.h&gt; #define N 1000005 #define int long long using namespace std; int T,l,r,a[N],cnt,trie[N][30],b[N]; void insert(int sum){ int now=0; for(int i=17;i&gt;=0;i--){ bool tmp=(1&lt;&lt;i)&amp;sum; if(!trie[now][tmp])trie[now][tmp]=++cnt; now=trie[now][tmp]; } } int Max(int sum){ int now=0,res=0; for(int i=17;i&gt;=0;i--){ bool tmp=(1&lt;&lt;i)&amp;sum; if(!trie[now][tmp^1])now=trie[now][tmp]; else now=trie[now][tmp^1],res+=(1&lt;&lt;i); } return res; } int Min(int sum){ int now=0,res=0; for(int i=17;i&gt;=0;i--){ bool tmp=(1&lt;&lt;i)&amp;sum; if(!trie[now][tmp])now=trie[now][tmp^1],res+=(1&lt;&lt;i); else now=trie[now][tmp]; } return res; } signed main() { cin&gt;&gt;T; while(T--){ cin&gt;&gt;l&gt;&gt;r; for(int i=0;i&lt;=cnt;i++)trie[i][0]=trie[i][1]=0; cnt=0; for(int i=l;i&lt;=r;i++)cin&gt;&gt;a[i],b[i]=a[i]^l; for(int i=l;i&lt;=r;i++)insert(a[i]); for(int i=l;i&lt;=r;i++){ if(Max(b[i])==r&amp;&amp;Min(b[i])==l){ cout&lt;&lt;b[i]&lt;&lt;endl; break; } } } } 1651C- Fault-tolerant Network 给定两个数组a,ba,ba,b，数组aaa相邻两个元素之间通过线相连，数组bbb同理，现在要将a,ba,ba,b两个数组互相连接，连接的代价为∣a[i]−b[j]∣|a[i]-b[j]|∣a[i]−b[j]∣要求当删除两个数组中任意一个元素时，剩下的所有元素仍然能通过线连通，且代价最小。 通过观察可以发现，想要让两个数组在删除一个任意一个数的情况下保持连通，则两个数组的开头和末尾一定要有线来连接。 假设某一个数组的开头或结尾没有数连接，那么当我们删除这个数的时候，会发现这个数一定是孤立的状态，所以上面结论成立。 进一步观察可以发现，只要保证两个数的开头或结尾处于连接状态，此时两个数组已经可以保证在删除任意数的条件下保持连通，不需要添加额外的边。因此我们只需要分别求这四个点进行连线的最小代价，最后求和即可。 本题还要注意边界问题：四个点互相连线的情况下需要特判最小值。 // Problem: C. Fault-tolerant Network // Contest: Codeforces - Educational Codeforces Round 124 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1651/C // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10, INF = 2e18; int a[N], b[N]; int n; void solve() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; b[i]; int st1 = a[1], ed1 = a[n], st2 = b[1], ed2 = b[n]; int t1, t2, t3, t4; t1 = t2 = t3 = t4 = INF; int idx1, idx2, idx3, idx4; for(int i = 1; i &lt;= n; i ++) { t1 = min(t1, abs(b[i] - st1)); t2 = min(t2, abs(b[i] - ed1)); t3 = min(t3, abs(a[i] - st2)); t4 = min(t4, abs(a[i] - ed2)); } int res = t1 + t2 + t3 + t4; res = min(res, min(abs(st1 - ed2) + abs(st2 - ed1), abs(st1 - st2) + abs(ed1 - ed2))); res = min(res, min(abs(st1 - st2) + t2 + t4, abs(ed1 - ed2) + t1 + t3)); res = min(res, min(abs(st1 - ed2) + t2 + t3, abs(st2 - ed1) + t1 + t4)); cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1646C- Factorials and Powers of Two 定义好数：如果某个数可以被表示为d!d!d!或2d2^d2d，则这个数被称为好数 给定一个数nnn，求nnn最少可以被拆分成多少个好数的和 数据范围：1≤n≤10121 \\leq n \\leq 10^{12}1≤n≤1012 首先任何一个正整数一定可以被拆分成若干个好数的和，因为该数一定可以由二进制表示，且最多拆为二进制中1的个数 然后可以发现，101210^{12}1012以内的阶乘数很少，最多只有15个 于是方法非常显然：枚举阶乘数的所有使用情况的总和，剩下的数用二进制表示，答案取最小值，采用DFS暴搜即可 // Problem: C. Factorials and Powers of Two // Contest: Codeforces - Codeforces Round #774 (Div. 2) // URL: https://codeforces.com/problemset/problem/1646/C // Memory Limit: 256 MB // Time Limit: 3000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int n; int p[50], cnt; bool v[50]; void init() { int t = 1; for(int i = 1; i &lt;= 15; i ++) { t *= i; p[i] = t; } } int dfs(int fac, int val, int idx) { if(val &lt; 0) return 1e18; else if(fac == 16) { int res = 0; while(val &gt; 0) { if(val &amp; 1) res ++; val &gt;&gt;= 1; } return res + idx; } else return min(dfs(fac + 1, val, idx), dfs(fac + 1, val - p[fac], idx + 1)); } void solve() { int n; cin &gt;&gt; n; cout &lt;&lt; dfs(1, n, 0) &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; init(); while(T --) { solve(); } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://memsetray.github.io/categories/题解/"}],"tags":[],"keywords":[{"name":"题解","slug":"题解","permalink":"https://memsetray.github.io/categories/题解/"}]},{"title":"CodeForces2000-2300难度部分题题解","slug":"CodeForces2000-2300难度部分题题解","date":"2022-09-05T00:35:49.000Z","updated":"2022-09-05T14:53:28.406Z","comments":true,"path":"2022/09/05/CodeForces2000-2300难度部分题题解/","link":"","permalink":"https://memsetray.github.io/2022/09/05/CodeForces2000-2300难度部分题题解/","excerpt":"","text":"Codeforces 2000-2300 难度题解 808G-Anthem of Berland 题目描述：给定 sss 串和 ttt 串，其中 sss 串包含小写字母和问号，ttt 串只包含小写字母。 假设共有 kkk 个问号。 你需要给把每个问号变成一个小写字母，共有 26k26^k26k 种可能。 对于每种可能，设 ttt 匹配 sss 的次数为 fif_ifi​，请输出 max⁡(fi)\\max(f_i)max(fi​) 。 数据范围：1≤∣s∣,∣t∣≤105,∣s∣∗∣t∣≤1071 \\leq |s|,|t| \\leq 10^5,|s|*|t| \\leq 10^71≤∣s∣,∣t∣≤105,∣s∣∗∣t∣≤107 题解：KMP自动机：构建一个数组aut[i][c]aut[i][c]aut[i][c]，表示模式串的前i−1i - 1i−1位已经匹配完成，用ccc与tit_iti​匹配后的匹配长度 构造方式：先求出nextnextnext数组 aut[i][c]={aut[next[i−1]+1][c],i=1∣∣ti≠ci+[ti=c],a&lt;1aut[i][c] = \\begin{cases} aut[next[i - 1] + 1][c],&amp;i = 1 || t_i \\neq c \\\\ i + [t_i = c],&amp;a &lt; 1 \\end{cases} aut[i][c]={aut[next[i−1]+1][c],i+[ti​=c],​i=1∣∣ti​​=ca&lt;1​ 首先构建KMP自动机，然后考虑DP 设dp[i][j]dp[i][j]dp[i][j]为当前扫描到sss的第iii位，在KMP自动机上的节点jjj匹配的最大次数 状态转移方程： dp[i][j]=max(dp[i][j],dp[i−1][j]+(j==m))dp[i][j] = max(dp[i][j], dp[i - 1][j] + (j == m))dp[i][j]=max(dp[i][j],dp[i−1][j]+(j==m)) 答案为∑∣t∣1max(dp[∣s∣][i])\\sum^1_{|t|} max(dp[|s|][i])∑∣t∣1​max(dp[∣s∣][i])，时间复杂度O(∣s∣∗∣t∣∗26)O(|s|*|t|*26)O(∣s∣∗∣t∣∗26) // Problem: G. Anthem of Berland // Contest: Codeforces - Educational Codeforces Round 21 // URL: https://codeforces.com/contest/808/problem/G // Memory Limit: 256 MB // Time Limit: 3000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 1e5 + 10; int n, m; int dp[2][N]; int ne[N], aut[N][26]; char s[N], t[N]; void init_ne() { ne[1] = 0; for(int i = 2, j = 0; i &lt;= m; i ++) { while(j &amp;&amp; t[i] != t[j + 1]) j = ne[j]; if(t[i] == t[j + 1]) j ++; ne[i] = j; } } void init_KMPAM() { for(int i = 1; i &lt;= m; i ++) { for(int c = 0; c &lt; 26; c ++) { if(i &gt; 1 &amp;&amp; t[i] != c + 'a') aut[i][c] = aut[ne[i - 1] + 1][c]; else aut[i][c] = i + (t[i] == c + 'a'); } } } void dp_KMP() { memset(dp, 0xcf, sizeof dp); //初始化负无穷 dp[0][1] = 0; for(int i = 1; i &lt;= n; i ++) { if(s[i] == '?') { for(int j = 1; j &lt;= m; j ++) { for(int c = 0; c &lt; 26; c ++) dp[i &amp; 1][aut[j][c]] = max(dp[i &amp; 1][aut[j][c]], dp[(i - 1) &amp; 1][j] + (aut[j][c] == m)); } } else { for(int j = 1; j &lt;= m; j ++) dp[i &amp; 1][aut[j][s[i] - 'a']] = max(dp[i &amp; 1][aut[j][s[i] - 'a']], dp[(i - 1) &amp; 1][j] + (aut[j][s[i] - 'a'] == m)); } for(int j = 1; j &lt;= m; j ++) dp[(i - 1) &amp; 1][j] = -0x3f3f3f3f; } } void solve() { cin &gt;&gt; (s + 1) &gt;&gt; (t + 1); n = strlen(s + 1), m = strlen(t + 1); t[++ m] = '#'; //加特殊字符 init_ne(); init_KMPAM(); dp_KMP(); int mmax = 0; for(int j = 1; j &lt;= m; j ++) mmax = max(mmax, dp[n &amp; 1][j]); cout &lt;&lt; mmax &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } 1721E- Prefix Function Queries 题目大意：给定字符串sss,以及qqq个串tit_iti​，求将sss分别与每个tit_iti​拼接起来后，最靠右的∣ti∣|t_i|∣ti​∣个前缀的border长度，每个询问相互独立 数据范围：∣s∣≤106,q≤105,∣ti∣≤10|s| \\leq 10^6, q \\leq 10^5, |t_i| \\leq 10∣s∣≤106,q≤105,∣ti​∣≤10 题解：对原串sss求KMP自动机，每次询问在线构造s+ts + ts+t中ttt部分的KMP自动机，输出对应的next值即可 // Problem: E. Prefix Function Queries // Contest: Codeforces - Educational Codeforces Round 134 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1721/E // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; using namespace std; const int N = 1e6 + 10; char s[N]; int ne[N], aut[N][27]; int n, m; void init_next() { ne[1] = 0; for(int i = 2, j = 0; i &lt;= n; i ++) { while(j &amp;&amp; s[i] != s[j + 1]) j = ne[j]; if(s[i] == s[j + 1]) j ++; ne[i] = j; } } void init_KMPAM() { for(int i = 0; i &lt; n; i ++) { for(int c = 1; c &lt;= 26; c ++) { aut[i][c] = aut[ne[i]][c]; } aut[i][s[i + 1] - 'a' + 1] = i; } } void solve() { int q; cin &gt;&gt; (s + 1); n = strlen(s + 1); init_next(); init_KMPAM(); cin &gt;&gt; q; while(q --) { cin &gt;&gt; (s + n + 1); m = n + strlen(s + n + 1); for(int i = n + 1, k = ne[n]; i &lt;= m; i ++) { int id = i - 1; k = aut[k][s[i] - 'a' + 1]; if(s[i] == s[k + 1]) k ++; ne[i] = k; cout &lt;&lt; k &lt;&lt; &quot; &quot;; for(int c = 1; c &lt;= 26; c ++) aut[id][c] = aut[ne[id]][c]; aut[id][s[i] - 'a' + 1] = id; } cout &lt;&lt; endl; } } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } 1712D- Empty Graph 题目大意：给定一个长度为nnn的序列aaa 定义一个nnn个点的无向完全图，点lll和点rrr之间的距离为minl≤i≤r{a[i]}\\underset{l\\leq i \\leq r}{min} \\{a[i]\\}l≤i≤rmin​{a[i]} 你可以进行kkk次操作，每次操作可以选定1−n1-n1−n中任意一个数并将aia_iai​赋值为一个[1,109][1,10^9][1,109]的整数，请最大化这个图的直径。 图的直径定义为max1≤u≤v≤nd(u,v)\\underset{1 \\leq u \\leq v \\leq n}{max}d(u,v)1≤u≤v≤nmax​d(u,v)，其中d(u,v)d(u,v)d(u,v)为uuu到vvv的最短路长度。 题解：本题的答案具有最大值最小的性质，考虑二分答案 首先需要发现一个性质：对于两点间的最短路，最多走两条边，要么走两点直接相连的边，要么先走一个最小边走到某个点，再从这个点走到目标点 ，即 d(u,v)=min(e(u,v),2∗mmin)d(u,v) = min(e(u,v),2*mmin) d(u,v)=min(e(u,v),2∗mmin) 其中mminmminmmin为min1≤i≤n{ai}\\underset{1 \\leq i \\leq n}{min} \\{ai\\}1≤i≤nmin​{ai},e(u,v)=minu≤i≤v−1(e(ai,ai+1))e(u,v) = \\underset{u \\leq i \\leq v - 1}{min}(e(a_i,a_{i + 1}))e(u,v)=u≤i≤v−1min​(e(ai​,ai+1​)) 设图的直径为lll，由此可得： \\begin{align} l &amp;= max(min(e(u,v), 2*mmin)) \\\\ &amp;= min(max(e(u,v)), 2*mmin) \\\\ &amp;= min(max(\\underset{1 \\leq i \\leq n - 1}{min}(a_i, a_{i + 1})), 2 * mmin) \\end{align} 至此我们已经知道如何二分答案： 设当前二分的答案为midmidmid，我们需要将所有值小于等于mid2\\frac{mid}{2}2mid​的点赋值为10910^9109，因为这些点走两次之后依然比答案小，我们就一定要修改这些边，同时记录修改的次数 如果被修改次数大于kkk，则显然不合法 如果被修改次数等于kkk，我们需要求出此时的直径lll，如果l&gt;=midl &gt;= midl&gt;=mid，那么midmidmid显然合法 如果被修改次数小于kkk，我们需要分类讨论一下： ​ 如果k&gt;1k &gt;1k&gt;1，说明我们还有更多修改余地，已经不需要修改了，那么一定合法 ​ 如果k=1k = 1k=1，说明不存在小于等于mid2\\frac{mid}{2}2mid​的点，此时我们仅能修改一条边，观察上面的公式，我们需要求出max(min1≤i≤n−1(ai,ai+1))max(\\underset{1 \\leq i \\leq n - 1}{min}(a_i, a_{i + 1}))max(1≤i≤n−1min​(ai​,ai+1​)) ​ 换句话说，我们只需要求出是否存在ai≥mida_i \\geq midai​≥mid，如果存在，我们就要把与他相邻的另一个改成10910^9109即可。 // Problem: D. Empty Graph // Contest: Codeforces - Codeforces Round #813 (Div. 2) // URL: https://codeforces.com/problemset/problem/1712/D // Memory Limit: 256 MB // Time Limit: 1500 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 1e5 + 10; int n, k; bool check(vector&lt;int&gt; a, int mid, int t) { for(int i = 0; i &lt; a.size(); i ++) if(a[i] * 2 &lt; mid) t --, a[i] = 1e9; if(t &lt; 0) return false; if(t == 0) { for(int i = 0; i &lt; a.size() - 1; i ++) if(min(a[i], a[i + 1]) &gt;= mid) return true; } else if(t == 1) return *max_element(a.begin(), a.end()) &gt;= mid; else return true; return false; } void solve() { vector&lt;int&gt; a; cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i ++) { int x; cin &gt;&gt; x; a.push_back(x); } int l = 1, r = 1e9; while(l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if(check(a, mid, k)) l = mid; else r = mid - 1; } cout &lt;&lt; l &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1706E- Qpwoeirut and Vertices 题目大意：给出nnn个点，mmm条边的不带权连通无向图，qqq次询问至少要加完编号前多少的边，才能使得[l,r][l,r][l,r]中的所有点两两连通。 题解：前置知识：Kruskal重构树\\textcolor{pink}{Kruskal重构树}Kruskal重构树 KruskalKruskalKruskal重构树是将一张无向图经过KruskalKruskalKruskal算法得到最小生成树后，再将其重建成一颗二叉树，原图中所有的叶子结点都是原图中的点，其他点具有一个点权www，表示左集合到右集合的边权。 KruskalKruskalKruskal重构树的性质：原图中两点之间所有简单路径上最大边权的最小值=最小生成树上两个点之间的简单路径上的最大值=KruskalKruskalKruskal重构树上两点之间LCA的权值 eg1eg_1eg1​：求节点uuu到节点vvv路径的最大边权，就是求LCA(u,v)LCA(u,v)LCA(u,v)的点权 eg2eg_2eg2​:从点uuu出发，给定一个值ttt，在通过所有边的权值小于等于ttt时，走过了多少个点 =&gt;=&gt;=&gt;从点uuu向上找，找到最后一个小于等于ttt的虚点，子树中的点都可以通过（因为重构树上的点从上往下点权单调不升） 回到这道题，结论显而易见：使得(u,v)(u,v)(u,v)之间两两连通的最小边权为重构树上的v(LCA(u,v))v(LCA(u,v))v(LCA(u,v))，其中vvv为点权。 剩下的问题是处理所有询问，我们可以采用ST表预处理所有询问，或者采用线段树。多个点的LCALCALCA的求法：取出其中dfndfndfn最小和最大的点求LCALCALCA即为答案。 // Problem: E. Qpwoeirut and Vertices // Contest: Codeforces - Codeforces Round #809 (Div. 2) // URL: https://codeforces.com/problemset/problem/1706/E // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 1e5 + 10, M = N * 2; struct Edge{ int x, y; }e[M]; struct D{ int l, r, c; int fa[20]; int p; int depth; }d[M]; int n, m, q; int t[N * 4]; void init() { for(int i = 1; i &lt;= n; i ++) { memset(d[i].fa, 0, sizeof d[i].fa); d[i].p = d[i].l = d[i].r = d[i].c = 0; } } int find(int x) { if(d[x].p != x) d[x].p = find(d[x].p); return d[x].p; } void merge_seg(int x, int y, int c) { int px = find(x), py = find(y); if(px == py) return ; else n ++; d[px].p = d[py].p = d[n].p = n; d[px].fa[0] = d[py].fa[0] = n; d[n].l = px, d[n].r = py, d[n].c = c; } void kruskal() { for(int i = 1; i &lt;= n; i ++) d[i].p = i; for(int i = 1; i &lt;= m; i ++) merge_seg(e[i].x, e[i].y, i); } void dfs(int x) { if(x == 0) return ; d[x].depth = d[d[x].fa[0]].depth + 1; for(int i = 1; i &lt;= 18; i ++) d[x].fa[i] = d[d[x].fa[i - 1]].fa[i - 1]; dfs(d[x].l); dfs(d[x].r); } int lca(int x, int y) { if(d[x].depth &lt; d[y].depth) swap(x, y); for(int i = 18; i &gt;= 0; i --) if(d[d[x].fa[i]].depth &gt;= d[y].depth) x = d[x].fa[i]; if(x == y) return y; for(int i = 18; i &gt;= 0; i --) if(d[x].fa[i] != d[y].fa[i]) { x = d[x].fa[i]; y = d[y].fa[i]; } return d[y].fa[0]; } int build(int x, int l ,int r) { int mid = l + r &gt;&gt; 1; if(l == r) t[x] = mid; else t[x] = lca(build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r)); return t[x]; } int query(int x, int l, int r, int a, int b) { int mid = l + r &gt;&gt; 1; if(a == l &amp;&amp; b == r) return t[x]; else { if(b &lt;= mid) return query(x &lt;&lt; 1, l, mid, a, b); if(a &gt; mid) return query(x &lt;&lt; 1 | 1, mid + 1, r, a, b); return lca(query(x &lt;&lt; 1, l, mid, a, mid), query(x &lt;&lt; 1 | 1, mid + 1, r, mid + 1, b)); } } void solve() { init(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; int nn = n; for(int i = 1; i &lt;= m; i ++) cin &gt;&gt; e[i].x &gt;&gt; e[i].y; kruskal(); dfs(n); build(1, 1, nn); for(int i = 1; i &lt;= q; i ++) { int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; d[query(1, 1, nn, l, r)].c &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://memsetray.github.io/categories/题解/"}],"tags":[],"keywords":[{"name":"题解","slug":"题解","permalink":"https://memsetray.github.io/categories/题解/"}]}]}