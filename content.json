{"meta":{"title":"Ray's Blog","subtitle":null,"description":"少女祈祷中...","author":"Ray","url":"https://memsetray.github.io"},"pages":[{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"comment/index.html","permalink":"https://memsetray.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"client/index.html","permalink":"https://memsetray.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"donate/index.html","permalink":"https://memsetray.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2022-09-07T06:28:38.365Z","comments":false,"path":"lab/index.html","permalink":"https://memsetray.github.io/lab/index.html","excerpt":"","text":"Blog更新日志 2022年9月4日：博客搭建完成，正式开始使用 2022年9月5日：修复了个人介绍，添加了Waline评论系统，修复了各种图片裂开问题 2022年9月6日：修复了评论系统导致网页挂掉的问题，完善了评论系统，修复了打赏二维码，修复了社交链接 2022年9月7日：添加了Live2d看板娘 ToDo 完善清单：番组与图集 添加说说 添加视频 …","keywords":"Lab实验室"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2022-09-05T05:22:49.110Z","comments":false,"path":"about/index.html","permalink":"https://memsetray.github.io/about/index.html","excerpt":"","text":"[Ray的个人介绍] 与&nbsp; Ray&nbsp; （ 菜 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"tags/index.html","permalink":"https://memsetray.github.io/tags/index.html","excerpt":"","text":""},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2022-09-07T11:12:50.613Z","comments":true,"path":"bangumi/index.html","permalink":"https://memsetray.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2022-09-04T13:36:18.224Z","comments":false,"path":"music/index.html","permalink":"https://memsetray.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2022-09-07T03:42:02.561Z","comments":true,"path":"links/index.html","permalink":"https://memsetray.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"rss/index.html","permalink":"https://memsetray.github.io/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://memsetray.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"video/index.html","permalink":"https://memsetray.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"网络流基础","slug":"网络流基础","date":"2022-12-26T14:07:36.000Z","updated":"2022-12-26T14:09:10.297Z","comments":true,"path":"2022/12/26/网络流基础/","link":"","permalink":"https://memsetray.github.io/2022/12/26/网络流基础/","excerpt":"","text":"网络流 1. 基本概念 1.1 最大流最小割定理： ​ （1）流fff是最大流 ​ （2）流fff的残留网络中不存在增广路 ​ （3）存在某个割[S,T],∣f∣=c(S,T)[S,T],|f| = c(S,T)[S,T],∣f∣=c(S,T) ​ 以上条件满足任何一个，其余条件均成立 ​ 证明：由（1）推理（2），假设流fff的残留网络中存在增广路f′f&#x27;f′，则可以根据f′f&#x27;f′与流fff构造更大的流，与fff是最大流矛盾，故（1）可以推出（2） 由（2）推（3），设SSS：在残留网络GfG_fGf​中，从sss出发沿着容量大于0的边走，所有能走到的点。 设T=V−ST = V - ST=V−S，得到一个合法的割。 对于原网络流中任意由SSS到TTT的边(x,y)(x,y)(x,y)，一定满足f(x,y)=c(x,y)f(x,y) = c(x,y)f(x,y)=c(x,y)，否则其残留网络的值不为0，与SSS和TTT的定义矛盾 对于原网络流中任意由TTT到SSS的边(a,b)(a, b)(a,b)，一定满足f(a,b)=0f(a,b) = 0f(a,b)=0，否则其残留网络会产生一条由SSS到TTT的反向边，值为原网络流中TTT到SSS的容量，与SSS和TTT的定义矛盾。 于是有∣f∣=f(S,T)=∑u∈S∑v∈Tf(u,v)−0=∑u∈S∑v∈Tc(u,v)=c(S,T)|f| = f(S,T) = \\sum_{u\\in S} \\sum_{v \\in T}f(u,v) - 0 = \\sum_{u\\in S} \\sum_{v \\in T}c(u,v) = c(S,T)∣f∣=f(S,T)=∑u∈S​∑v∈T​f(u,v)−0=∑u∈S​∑v∈T​c(u,v)=c(S,T) 由（3）推（1），因为∣f∣≤c(S,T)|f| \\leq c(S,T)∣f∣≤c(S,T)，设最大流为f′f&#x27;f′，则∣f′∣≤c(S,T)|f&#x27;| \\leq c(S,T)∣f′∣≤c(S,T)，之后证明∣f∣=∣f′∣|f| = |f&#x27;|∣f∣=∣f′∣，根据定义显然∣f′∣≥∣f∣|f&#x27;| \\geq |f|∣f′∣≥∣f∣，由于存在某个割使得∣f∣=c(S,T)|f|=c(S,T)∣f∣=c(S,T)，而∣f′∣≤c(S,T)|f&#x27;| \\leq c(S,T)∣f′∣≤c(S,T)，因此∣f∣≥∣f′∣|f| \\geq |f&#x27;|∣f∣≥∣f′∣，由此可得∣f∣=∣f′∣|f| = |f&#x27;|∣f∣=∣f′∣，即流fff是最大流 证毕。 2. EK算法求最大流 维护一个残留网络，每次尝试从SSS找到一条到达TTT的增广路径，将其流量从原网络流中移除，同时维护新的残留网络，将这条路径上的最小残留量（流量）累加到resresres中，直到无法找到增广路径，此时resresres即为最大流 时间复杂度O(nm2)O(nm^2)O(nm2) 模板 #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 1010, M = 2e5 + 10, INF = 1e8; int h[N], e[M], ne[M], f[M], idx; int d[N], pre[N]; int res; bool st[N]; int n, m, S, T; void add(int a, int b, int c) { e[idx] = b, ne[idx] = h[a], f[idx] = c, h[a] = idx ++; e[idx] = a, ne[idx] = h[b], f[idx] = 0, h[b] = idx ++; } bool bfs() { queue&lt;int&gt; q; memset(st, 0, sizeof st); q.push(S); d[S] = INF; st[S] = true; while(q.size()) { int t = q.front(); q.pop(); for(int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if(!st[j] &amp;&amp; f[i]) { st[j] = true; d[j] = min(d[t], f[i]); pre[j] = i; if(j == T) return true; q.push(j); } } } return false; } void EK() { while(bfs()) { res += d[T]; for(int i = T; i != S; i = e[pre[i] ^ 1]) { f[pre[i]] -= d[T]; f[pre[i] ^ 1] += d[T]; } } } int main() { memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T; while(m --) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); } EK(); cout &lt;&lt; res &lt;&lt; endl; return 0; } 3.Dinic算法求最大流 对EKEKEK算法的优化，主要采用分层图+当前弧优化的方式，在求增广路径时可以一次求出多条增广路从而降低时间复杂度，Dinic算法的时间复杂度为O(n2m)O(n^2m)O(n2m) 当前弧优化：在通过DFSDFSDFS遍历当前点到终点的流量时，如果某条路径已经被遍历过且流量已满，则跳过对这条路径的DFSDFSDFS，直接从第一个未满的路径搜索，避免了重复搜索 模板 #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 10010, M = 2e5 + 10, INF = 1e9; int h[N], e[M], ne[M], f[M], idx; int d[N], cur[N]; int res, flow; int n, m, S, T; void add(int a, int b, int c) { e[idx] = b, ne[idx] = h[a], f[idx] = c, h[a] = idx ++; e[idx] = a, ne[idx] = h[b], f[idx] = 0, h[b] = idx ++; } bool bfs() { queue&lt;int&gt; q; memset(d, -1, sizeof d); q.push(S); d[S] = 0; cur[S] = h[S]; //当前弧从第一个点开始 while(q.size()) { int t = q.front(); q.pop(); for(int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if(d[j] == -1 &amp;&amp; f[i]) { d[j] = d[t] + 1; cur[j] = h[j]; //当前点的当前弧是当前点的第一条边 if(j == T) return true; q.push(j); } } } return false; } int dfs(int u, int l) { if(u == T) return l; int flow = 0; for(int i = cur[u]; ~i &amp;&amp; flow &lt; l; i = ne[i]) { cur[u] = i; //当前弧优化 int j = e[i]; if(d[j] == d[u] + 1 &amp;&amp; f[i]) { int t = dfs(j, min(f[i], l - flow)); if(!t) d[j] = -1; //不存在增广路，将这个点删掉 f[i] -= t, f[i ^ 1] += t, flow += t; } } return flow; } void dinic() { while(bfs()) { while(flow = dfs(S, INF)) res += flow; } } int main() { memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T; while(m --) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); } dinic(); cout &lt;&lt; res &lt;&lt; endl; return 0; }","categories":[],"tags":[],"keywords":[]},{"title":"单片机复习笔记","slug":"单片机复习笔记","date":"2022-11-21T15:10:36.000Z","updated":"2022-12-26T14:09:34.737Z","comments":true,"path":"2022/11/21/单片机复习笔记/","link":"","permalink":"https://memsetray.github.io/2022/11/21/单片机复习笔记/","excerpt":"","text":"单片机复习 第一节 16位程序计数器(PC)：用于指示下一时刻CPU将要执行的程序在ROM空间中的地址位置，因此程序存储器空间大小64KB，最大地址0000-FFFFH EA = 1(5V)时，PC大于某值为访问外部程序 存储器，PC值小于某值为访问内部程序存储器 EA = 0(0V)时，内部存储器将被忽略。 EA接+5V时，PC 的有效地址范围在0000H ~ 0FFFH（没有外接ROM），0000H ~ FFFFH（外接ROM） 程序存储器的0000H单元地址是系统程序的启动地址，一般放一条绝对转移指令 00H - 1FH单元为工作寄存器(通用寄存器)组区，32字节，每组用R0-R7表示。 20H - 2FH为位寻址区，16字节128位，位地址范围00H - 7FH 30H - 7FH为一般RAM区(用户RAM区)，共80字节 堆栈是用片内数据存储器的一段区域，一般在2FH以后的单元，设置了一个堆栈指针SP 特殊功能寄存器：专门用于控制，管理片内算数逻辑部件，并行IO口，串行口，定时器计数器，中断系统等模块的工作，编程时可以给其设定值，但是不能移作他用，分布在80H - FFH地址空间 单片机中的CPU主要由运算器和控制器组成 8051单片机没有定时器/计数器T2 DPTR具有16位字长 ALE引脚：地址锁存和使能输出端引脚 哈佛结构的内部包括：4个物理空间和3个逻辑空间 单片机要使用片内存储器，EA引脚没有限定（悬空或接5V） 单片机内部程序存储器容量为4KB 第二节 P0口：双向输入/输出口 P2口：准双向口，通用IO接口和高8位地址线 P3口：具有第二功能 四个8位并行IO口，既可以作输入，也可以做输出，既可以按8位处理，也可以按位方式使用，输出时具有锁存能力，输入时具有缓冲功能。 在通用I/O方式下，欲从P1口读取引脚电平前应当先向P1口写1 程序状态寄存器中反映进位或借位状态的标志位符号是：CY 第三节 复位方式：当外部电路使得RST端出现两个机器周期以上的高电平，系统内部复位，复位有两种方式：上电自动复位和手动按钮复位 机器周期：机器周期是单片机的基本操作周期，每个机器周期包含6个状态，每个状态包含两拍，每一拍为一个一个时钟周期(振荡周期)机器周期包含12个时钟周期 即：时钟周期 = 振荡周期，一个机器周期 = 12个时钟周期 指令周期：计算机取一条指令至执行完该指令需要的时间为指令周期，不同的指令指令周期不同。 大部分指令为一个机器周期或两个机器周期，只有乘法除法指令要四个机器周期 单片机上电复位后，PC的内容和SP的内容为：0000H，07H 单片机上电复位后，PSW的初始值为0 单片机的XTAL1和XTAL2引脚是外接晶振引脚，Vss(20)V_{ss}(20)Vss​(20)引脚是接地引脚 PSW中的RS1和RS0用来：选择工作寄存器组号 PSW中的R0和R1分别为0和1时，系统选用的工作寄存器组为组2 若单片机的机器周期为12μs，则其晶振频率为1MHz 单片机具有复位功能的引脚是RST 单片机内部反映运行状态或运算结果特征的寄存器是PSW 当PSW为18H时，则当前工作寄存器是：第3组 18H -&gt; 00011000 RS1 = 1，RS0 = 1，第三组","categories":[],"tags":[],"keywords":[]},{"title":"整除分块","slug":"整除分块","date":"2022-11-12T11:32:16.000Z","updated":"2022-11-12T11:36:38.780Z","comments":true,"path":"2022/11/12/整除分块/","link":"","permalink":"https://memsetray.github.io/2022/11/12/整除分块/","excerpt":"","text":"整除分块 整除分块可以快速计算含有下取整除法的和式，时间复杂度O(n)O(\\sqrt n)O(n​) 结论： 对于常数nnn，使得式子⌊ni⌋=⌊nj⌋\\lfloor \\frac{n}{i} \\rfloor = \\lfloor \\frac{n}{j} \\rfloor⌊in​⌋=⌊jn​⌋成立的最大的满足i≤j≤ni \\leq j \\leq ni≤j≤n的值为 ⌊n⌊ni⌋⌋\\lfloor \\frac{n}{\\lfloor \\frac{n}{i} \\rfloor} \\rfloor ⌊⌊in​⌋n​⌋ 证明略，有时间的话再补一下吧。。 即对于左端点lll，满足值等于nl\\frac{n}{l}ln​的最大右端点rrr的值为上式 数论分块的过程： 对于和式∑i=1nf(i)⌊ni⌋\\sum_{i = 1}^{n}f(i)\\lfloor \\frac{n}{i} \\rfloor∑i=1n​f(i)⌊in​⌋ 先计算出f(i)f(i)f(i)的前缀和，然后每次进行分块，将分块求出的结果累加。 代码实现： int H(int n) { int res = 0; int l = 1, r = 0; while(l &lt;= n) { r = n / (n / l); res += (r - l + 1) * 1ll * (n / l); l = r + 1; } return res; }","categories":[],"tags":[],"keywords":[]},{"title":"每日两题2022-11-7","slug":"每日两题2022-11-7","date":"2022-11-07T13:16:22.000Z","updated":"2022-11-07T13:17:13.192Z","comments":true,"path":"2022/11/07/每日两题2022-11-7/","link":"","permalink":"https://memsetray.github.io/2022/11/07/每日两题2022-11-7/","excerpt":"","text":"每日两题2022-11-6 ABC130D -Enough Array 给出nnn个数，求这些数中有多少个连续子序列的和大于等于kkk 数据范围： 1≤ai≤1051 \\leq a_i \\leq 10^51≤ai​≤105 1≤n≤1051 \\leq n \\leq 10^51≤n≤105 1≤k≤10101 \\leq k \\leq 10^{10}1≤k≤1010 思路 前缀和+双指针 首先可以发现一个结论：对于一个连续子序列，如果其和大于等于kkk，那么在其加入其他任意非负整数时也一定满足大于等于kkk 如果我们用双指针枚举左端点，考虑右端点的位置在何处大于等于kkk，设该位置为rrr，则在rrr之前的所有连续子序列都不满足大于等于kkk，而在rrr之后的所有连续子序列都一定满足大于等于kkk，这个子序列的个数可以O(1)O(1)O(1)地计算出来，即ppp之后的元素个数n−r+1n - r + 1n−r+1 在遍历完所有的左端点后，上面的答案累加起来即为最终的答案 AC 代码 #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 1e5 + 10; int a[N]; int s[N]; int res; signed main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; s[i] = s[i - 1] + a[i]; } int l = 0, r = 0; while(r &lt;= n) { if(s[r] - s[l] &lt; k) r ++; else { res += (n - r + 1); l ++; } } cout &lt;&lt; res &lt;&lt; endl; return 0; } ABC130E - Common Subsequence 给出两个长度为nnn和mmm的整数序列SSS和TTT，求SSS与TTT的公共子序列的个数对1e9+71e9+71e9+7取模的结果。 数据范围： 1≤Si,Ti≤1051 \\leq S_i,T_i \\leq 10^51≤Si​,Ti​≤105 1≤n,m,≤20001 \\leq n,m, \\leq 20001≤n,m,≤2000 思路 线性$DP$，设$dp[i][j]$表示从$S$的前$i$个数中选，$T$的前$j$个数中选的公共子序列的个数 考虑当前的状态如何转移而来： 显然dp[i][j]dp[i][j]dp[i][j]的状态应该由dp[i−1][j]dp[i - 1][j]dp[i−1][j]与dp[i][j−1]dp[i][j - 1]dp[i][j−1]转移而来 然后考虑当前位是否相同，如果s[i]≠t[j]s[i] \\neq t[j]s[i]​=t[j]，说明dp[i−1][j]+dp[i][j−1]dp[i - 1][j] + dp[i][j - 1]dp[i−1][j]+dp[i][j−1]之后会有计算重复的部分(因为当前位不对答案有贡献)。因此要减去重复累加的dp[i−1][j−1]dp[i - 1][j - 1]dp[i−1][j−1] 即s[i]≠t[i]s[i] \\neq t[i]s[i]​=t[i]时dp[i][j]=dp[i−1][j]+dp[i][j−1]−dp[i−1][j−1]dp[i][j] = dp[i - 1][j]+dp[i][j - 1]-dp[i - 1][j - 1]dp[i][j]=dp[i−1][j]+dp[i][j−1]−dp[i−1][j−1] 如果s[i]=t[i]s[i] = t[i]s[i]=t[i]则当前位对答案具有贡献(因为产生了新的公共子序列)，因此不需要减去重复的部分，另外再加上当前位单独产生的子序列 即s[i]=t[i]s[i] = t[i]s[i]=t[i]时dp[i][j]=dp[i−1][j]+dp[i][j−1]+1dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + 1dp[i][j]=dp[i−1][j]+dp[i][j−1]+1 答案即为dp[n][m]dp[n][m]dp[n][m]，注意取模即可。 AC 代码 #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 2010, mod = 1e9 + 7; int dp[N][N]; int a[N], b[N]; int n, m; signed main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= m; i ++) cin &gt;&gt; b[i]; for(int i = 1; i &lt;= n; i ++) { for(int j = 1; j &lt;= m; j ++) { if(a[i] != b[j]) dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + mod) % mod; else dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + 1) % mod; } } cout &lt;&lt; (dp[n][m] + 1) % mod &lt;&lt; endl; return 0; }","categories":[],"tags":[],"keywords":[]},{"title":"每日一题2022-11-3","slug":"每日一题2022-11-3","date":"2022-11-03T15:26:53.000Z","updated":"2022-11-03T15:28:36.415Z","comments":true,"path":"2022/11/03/每日一题2022-11-3/","link":"","permalink":"https://memsetray.github.io/2022/11/03/每日一题2022-11-3/","excerpt":"","text":"每日两题2022-11-3 ABC129C - Typical Stairs 有nnn级台阶，有mmm级台阶不能走，分别为a1,...ama_1,...a_ma1​,...am​级台阶。 现在你要从第000级台阶出发，每次可以向上一格或两格，求走到第nnn级台阶的方案数，答案对109+710^9+7109+7取模。 数据范围： 1≤n≤1051 \\leq n \\leq 10^51≤n≤105 0≤m≤n−10 \\leq m \\leq n - 10≤m≤n−1 1≤a1≤a2≤...≤am≤n−11 \\leq a_1 \\leq a_2 \\leq ... \\leq a_m \\leq n - 11≤a1​≤a2​≤...≤am​≤n−1 思路 显然线性$DP$，考虑当前第$i$级台阶的答案由那些情况递推出来 本题中每次可以走一格或两格，因此第iii级台阶可以由第i−1i - 1i−1级台阶或者第i−2i - 2i−2级台阶走上来。 设dp[i]dp[i]dp[i]表示从走到第iii级台阶的方案数，则状态转移方程： dp[i]=dp[i−1]+dp[i−2]dp[i] = dp[i - 1] + dp[i - 2]dp[i]=dp[i−1]+dp[i−2] 之后考虑不能走的台阶，如果当前枚举到的台阶不能走，跳过即可，如果i−1i - 1i−1和i−2i - 2i−2级台阶不能走，我们无需额外考虑（因为dpdpdp值为0） 最后注意边界：dp[1]dp[1]dp[1]的值不能直接初始化为111，要考虑到该台阶不能走的情况。 AC 代码 #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 1e5 + 10, mod = 1e9 + 7; int dp[N], v[N]; int n, k; signed main() { cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= k; i ++) { int x; cin &gt;&gt; x; v[x] = 1; } //dp[i] = dp[i - 1] + dp[i - 2]; dp[0] = 1, dp[1] = (v[1] == 1 ? 0 : 1); for(int i = 2; i &lt;= n; i ++) { if(!v[i]) dp[i] = (dp[i - 1] + dp[i - 2]) % mod; } cout &lt;&lt; dp[n] % mod &lt;&lt; endl; return 0; } ABC129E -Sum Equals Xor 以二进制形式给出一个整数LLL，问有多少个非负整数对(a,b)(a,b)(a,b)满足： a+b=a⊕b≤La + b = a \\oplus b \\leq La+b=a⊕b≤L 答案对109+710^9 + 7109+7取模 思路 显然线性$DP$，考虑当前第$i$级台阶的答案由那些情况递推出来 数位$DP$，题目中给定的已经是二进制形式，显然按照二进制形式的每一位进行讨论。 观察可知a+b=a⊕b≤La + b = a \\oplus b \\leq La+b=a⊕b≤L等价于a,ba,ba,b的二进制表示上同一位上不能同时为111。 设dp[i][0]dp[i][0]dp[i][0]表示a⊕ba \\oplus ba⊕b的前iii位小于LLL的前iii为的方案数，dp[i][1]dp[i][1]dp[i][1]表示a⊕ba \\oplus ba⊕b的前iii位等于LLL的前iii位的方案数。 考虑状态如何递推而来： 若LLL的第iii位为1，符合等于条件的情况有：上一位等于LLL且这一位a=1,b=0a = 1,b = 0a=1,b=0或者a=0,b=1a = 0,b = 1a=0,b=1，符合小于条件的情况有：上一位小于LLL，且这一位a=0,b=0a = 0,b = 0a=0,b=0或者a=1,b=0a = 1,b = 0a=1,b=0或者a=0,b=1a = 0,b = 1a=0,b=1，上一位等于LLL且a=0,b=0a = 0,b = 0a=0,b=0 即：dp[i][0]=dp[i−1][0]∗3+dp[i−1][1]dp[i][0] = dp[i - 1][0] * 3 + dp[i - 1][1]dp[i][0]=dp[i−1][0]∗3+dp[i−1][1] dp[i][1]=dp[i−1][1]∗2dp[i][1] = dp[i - 1][1] * 2dp[i][1]=dp[i−1][1]∗2 若LLL的第iii位为000，符合等于条件的情况有：上一位等于LLL且a=0,b=0a = 0,b = 0a=0,b=0，符合小于条件的情况有：上一位小于LLL，且a=0,b=0a = 0,b = 0a=0,b=0或者a=0,b=1a = 0,b = 1a=0,b=1或者a=1,b=0a = 1,b = 0a=1,b=0 即：dp[i][0]=(dp[i−1][0]∗3)dp[i][0] = (dp[i - 1][0] * 3)dp[i][0]=(dp[i−1][0]∗3) dp[i][1]=dp[i−1][1]dp[i][1] = dp[i - 1][1]dp[i][1]=dp[i−1][1] 答案即为dp[n][0]+dp[n][1]dp[n][0] + dp[n][1]dp[n][0]+dp[n][1] AC 代码 #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 1e5 + 10, mod = 1e9 + 7; char s[N]; int dp[N][2]; signed main() { cin &gt;&gt; (s + 1); int n = strlen(s + 1); dp[0][1] = 1; for(int i = 1; i &lt;= n; i ++) { dp[i][0] = (dp[i - 1][0] * 3) % mod; if(s[i] == '1') { dp[i][0] = (dp[i][0] + dp[i - 1][1]) % mod; dp[i][1] = (dp[i - 1][1] * 2) % mod; } else dp[i][1] = dp[i - 1][1]; } cout &lt;&lt; (dp[n][1] + dp[n][0]) % mod; return 0; }","categories":[],"tags":[],"keywords":[]},{"title":"ACM算法模板","slug":"ACM算法模板","date":"2022-10-18T05:52:56.000Z","updated":"2022-10-18T05:56:22.974Z","comments":true,"path":"2022/10/18/ACM算法模板/","link":"","permalink":"https://memsetray.github.io/2022/10/18/ACM算法模板/","excerpt":"","text":"1. 基础算法 1.1求逆序对数量 long long m_sort(int l,int r) { if(l&gt;=r) return 0; int mid=l+r&gt;&gt;1; int i=l,j=mid+1; long long res=m_sort(l,mid)+m_sort(mid+1,r); int k=0; while(i&lt;=mid&amp;&amp;j&lt;=r) { if(q[i]&lt;=q[j]) temp[k++]=q[i++]; else { temp[k++]=q[j++]; res+=mid-i+1; } } while(i&lt;=mid) { temp[k++]=q[i++]; } while(j&lt;=r) temp[k++]=q[j++]; for(int i=l,j=0;i&lt;=r;i++,j++) q[i]=temp[j]; return res; } 1.2 二分 while(l&lt;r) { int mid=l+r&gt;&gt;1; if(q[mid]&gt;=k) r=mid; //二分，若右区间被替换，则mid为l+r&gt;&gt;1 else l=mid+1; } while(l&lt;r) { int mid=l+r+1 &gt;&gt; 1; if(q[mid]&lt;=k) l=mid; //若左区间被替换，则mid为l+r+1&gt;&gt;1 else r=mid-1; } 1.3 二维前缀和与差分与二维差分 /二维前缀和 for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=m;j++) S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j]; //一维差分 void insert(int l,int r,int c) { b[l]+=c; b[r+1]-=c; } for(int i=1;i&lt;=n;i++) insert(i,i,a[i]); while (m -- ){ int l,r,c; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c; insert(l,r,c); } for(int i=1;i&lt;=n;i++) b[i]+=b[i-1]; //二维差分 void insert(int x1,int y1,int x2,int y2,int c) { b[x1][y1]+=c; b[x2+1][y1]-=c; b[x1][y2+1]-=c; b[x2+1][y2+1]+=c; } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) insert(i,j,i,j,a[i][j]); while (q -- ){ int x1,y1,x2,y2,c; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c; insert(x1,y1,x2,y2,c); } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1]; 1.4 双指针典例 1.4.1 最长连续不重复子序列 int res=0; for(int i=0,j=0;i&lt;n;i++) { s[a[i]]++; while(s[a[i]]&gt;1) { s[a[j]]--; j++; } res=max(res,i-j+1); } 1.4.2 判断a是否为b的子序列（1e5） int i=0,j=0; while( i&lt;n &amp;&amp;j &lt; m) { if(a[i]==b[j]) i++;; j++; } 1.5 需要保序的离散化 typedef pair&lt;int, int&gt; PII; //每一次操作都是一个二元组，这里用pair int n,m; int a[N],s[N]; vector &lt;int&gt; alls; //alls数组内存的是所有需要进行离散化的数以及进行完离散化之后的数组 vector&lt;PII&gt; add,query; //add数组内存的是每次对数的操作，query数组内存的是每次询问的左右区间 int find (int x) //查找离散化后数组的下标 { int l = 0, r = alls.size()-1; while(l &lt; r) { int mid = (l+r) &gt;&gt; 1; if(alls[mid] &gt;= x) r = mid; //当该下标对应的值为待查找值（离散化前的大数）时，返回下标+1（为了从1开始便于求前缀和） else l = mid + 1; } return r + 1; } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=0;i &lt; n ; i++) { int x , c; scanf(&quot;%d%d&quot;,&amp;x, &amp;c); add.push_back({x,c}); //把对原数组的操作存放进去,即把x加上c alls.push_back(x); //将需要进行离散化的数存到alls里 } for(int i = 0; i &lt; m; i++) { int l, r; scanf(&quot;%d%d&quot;,&amp;l, &amp;r); query.push_back({l, r}); //把每次询问存放进去，即存放需要求和的左右区间 alls.push_back(l); //由于l,r也可能是大数，因此我们也需要将l和r进行离散化 alls.push_back(r); } //此处是离散化的核心，即进行离散化的过程 sort(alls.begin(), alls.end()); //将需要离散化的数组进行排序 alls.erase(unique(alls.begin(), alls.end()),alls.end()); //去重，目的是将数组中的存放的数量减少，节省内存空间 for(auto it : add) { int x = find(it.first); //寻找被加的数进行离散化之后的下标 a[x] += it.second; //求离散化后的数组a } for(int i=1;i&lt;=alls.size(); i++) s[i] = s[i-1] + a[i]; //求离散化后数组的前缀和 for(auto it : query) { //处理每次询问 int l = find(it.first); //寻找左区间进行离散化之后的下标 int r = find(it.second); //寻找右区间进行离散化之后的下标 printf(&quot;%d\\n&quot; ,s[r]-s[l-1]); //求区间和 } return 0; } 1.6 不需要保序的离散化 //待补充 1.7 区间合并 vector&lt;PII&gt; segs; void merge(vector&lt;PII&gt; &amp;segs) { vector&lt;PII&gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for(auto seg : segs) { if(ed &lt; seg.first) { if(st != -2e9) res.push_back({st , ed}); st = seg.first; ed = seg.second; } else ed=max(ed , seg.second); } if(st != -2e9) res.push_back({st , ed}); segs=res; } int main() { int n; cin&gt;&gt;n; for(int i = 0;i &lt; n; i++ ) { int l , r; cin&gt;&gt;l&gt;&gt;r; segs.push_back({l,r}); } merge(segs); cout&lt;&lt;segs.size()&lt;&lt;endl; return 0; } 1.8 区间最值问题（RMQ） int w[N]; int f[N][M]; int n, m; void init() { for(int j = 0; j &lt; M; j ++) //先枚举区间长度 { for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++) //枚举区间左端点 { if(!j) f[i][j] = w[i]; else f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; j - 1)][j - 1]); } } } int query(int l, int r) { int len = r - l + 1; int k = log(len) / log(2); return max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]); //这两个区间一定覆盖查询区间 } int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; w[i]; init(); cin &gt;&gt; m; while (m -- ) { int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(l, r) &lt;&lt; endl; } return 0; } 1.9 manacher算法 int n; char a[N], b[N]; int p[N]; int res; void init() { int k = 0; b[k ++] = '$'; b[k ++] = '#'; for(int i = 0; i &lt; n; i ++) { b[k ++] = a[i]; b[k ++] = '#'; } b[k ++] = '^'; n = k; } void manacher() { int mr = 0, mid; for(int i = 1; i &lt; n; i ++) { if(i &lt; mr) p[i] = min(p[mid * 2 - i], mr - i); else p[i] = 1; while(b[i - p[i]] == b[i + p[i]]) p[i] ++; if(i + p[i] &gt; mr) { mr = i + p[i]; mid = i; } } } int main() { scanf(&quot;%s&quot;, a); n = strlen(a); init(); manacher(); for(int i = 0; i &lt; n; i ++) res = max(res, p[i]); cout &lt;&lt; res - 1 &lt;&lt; endl; return 0; } 1.10 最小表示法 //用于求字符串的最小表示，可以用来判断两个环形字符串是否是同一个字符串 int get_min(char s[]) { int i = 0, j = 1; while(i &lt; n &amp;&amp; j &lt; n) { int k = 0; while(k &lt; n &amp;&amp; s[i + k] == s[j + k]) k ++; if(k == n) break; if(s[i + k] &gt; s[j + k]) i += k + 1; else j += k + 1; if(i == j) j ++; } int k = min(i, j); s[k + n] = 0; return k; } int main() { cin &gt;&gt; a &gt;&gt; b; n = strlen(a); memcpy(a + n, a, n); memcpy(b + n, b, n); int x = get_min(a); int y = get_min(b); if(strcmp(a + x, b + y)) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else { cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; cout &lt;&lt; a + x &lt;&lt; endl; } return 0; } 1.11 对顶堆维护动态中位数 /* 对顶堆，维护一个大根堆和一个小根堆，对于每个元素，如果大根堆为空或小于大根堆顶，则插入大根堆，否则插到小根堆，这两个堆需要时刻满足： 序列中从小到大排名为1 ~ M / 2 + 1的整数在大根堆中 序列中从小到大排名为M / 2 + 2 ~ M的整数存储在小根堆中 如果不满足，就把多出来的数放到另一个堆，由此序列的中位数一定是大根堆的堆顶 */ int main() { int T; cin &gt;&gt; T; while(T --) { priority_queue&lt;int&gt; b_heap; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; s_heap; int n, m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; (m + 1 &gt;&gt; 1) &lt;&lt; endl; int cnt = 0; for(int i = 0; i &lt; m; i ++) { int x; cin &gt;&gt; x; if(b_heap.empty() || x &lt;= b_heap.top()) //大根堆为空或x小于大根堆顶，插入大根堆 b_heap.push(x); else s_heap.push(x); //否则插入小根堆 if(b_heap.size() &gt; s_heap.size() + 1) { s_heap.push(b_heap.top()); b_heap.pop(); } if(s_heap.size() &gt; b_heap.size()) { b_heap.push(s_heap.top()); s_heap.pop(); } if(i % 2 == 0) { cout &lt;&lt; b_heap.top() &lt;&lt; &quot; &quot;; if(++ cnt % 10 == 0) cout &lt;&lt; endl; } } if(cnt % 10) cout &lt;&lt; endl; } return 0; } 1.12 二进制状态压缩求最短Hamilton路径 int n; int w[N][N]; //用w来存储整个图 int f[M][N]; //f[i][j]表示从0走到j，走过的点为i的所有路径长度，i是一个20位二进制数，如果第k位为1，表示这个点已经走过了 int main() { cin &gt;&gt; n; //n个点 for(int i = 0; i &lt; n; i ++) { for(int j = 0; j &lt; n; j ++) cin &gt;&gt; w[i][j]; //输入n个点 } memset(f, 0x3f, sizeof f); //初始化路径长度为无穷大 f[1][0] = 0; //初始化0号点的路径长度为0 for(int i = 0; i &lt; 1 &lt;&lt; n; i ++) //枚举所有的状态 for(int j = 0; j &lt; n; j ++) if(i &gt;&gt; j &amp; 1) //从0走到j时，i中一定要包含j，即i的第j位一定为1 for(int k = 0; k &lt; n; k ++) //枚举j点从哪一个点转移过来 if((i - (1 &lt;&lt; j)) &gt;&gt; k &amp; 1) //如果i除去第j个点之后包含第k个点 f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j]); //那么当前的状态就是从0走到k加上k走到j的所有路径取最小值 cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl; //输出走完所有的点，并且走到n-1号点时的距离 return 0; } 2. 数据结构 2.1 单调栈 //用于寻找一个数左边最近的比它大（小）的数 int stk[N],tt; int main() { int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { int x; cin&gt;&gt;x; while(tt &amp;&amp; stk[tt]&gt;=x) tt--; if(tt) cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;; else cout&lt;&lt;&quot;-1&quot;&lt;&lt;&quot; &quot;; stk[++tt] = x; } return 0; } 2.2 单调队列（滑动窗口） //维护区间内最大值和最小值 int n,k; int a[N],q[N]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); int hh=0,tt=-1; for(int i=0;i&lt;n;i++) { //首先判断队头是否滑出滑动窗口 if(hh &lt;=tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; q[++tt] = i; if(i &gt;= k-1) printf(&quot;%d &quot;,a[q[hh]]); } puts(&quot;&quot;); hh = 0, tt = -1; for(int i=0;i&lt;n;i++) { //首先判断队头是否滑出滑动窗口 if(hh &lt;=tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; q[++tt] = i; if(i &gt;= k - 1) printf(&quot;%d &quot;,a[q[hh]]); } puts(&quot;&quot;); return 0; } 2.3 KMP算法 /* KMP算法是一种在模式串中寻找给定模板串的一种算法，该算法的时间复杂度为O(M+N)，相较于暴力算法，该算法最大的特点是模板串指针不需要回溯即可判断两个串是否匹配 该算法需要注意的几个地方 1. next数组的含义：next[i]的含义为：当当前模式串与模板串的元素不匹配时，当前元素之前的模板串的元素中，前缀与后缀相同的最大串长度 2. 求next数组时，next数组从下标2开始求，因为next[0]和next[1]的值均为0, 3. 进行kmp匹配时，从i下标1开始，j从下标0开始 4. p数组和s数组均从下标1开始存放元素 */ int n,m; char p[N], s[M]; int ne[N]; int main() { cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1; //p数组和s数组均从下标1开始存放元素 //求next数组的过程 for(int i = 2 ,j = 0; i &lt;= n ; i++ ) { while(j &amp;&amp; p[i] != p[j+1]) j=ne[j]; //前缀与后缀不同时，记录前缀与后缀相同时的长度 if(p[i] == p[j+1]) j++; //如果前缀和后缀相同，那么ij继续右移，判断更大的前缀后缀是否相同 ne[i] = j; //next数组的含义是:当当前模式串与模板串的元素不匹配时，当前元素之前的模板串的元素中，前缀与后缀相同的最大串长度 } //kmp的匹配过程 for(int i = 1, j = 0; i &lt;= m; i ++) { while(j &amp;&amp; s[i] != p[j+1]) j = ne[j]; //当模板串与模式串不匹配时，将模板串右移ne[j]的距离 if(s[i] == p[j+1]) j++; //如果模板串与模式串匹配，那么就将它们的下一位进行匹配 if(j == n) //如果模板串所有的字符都被匹配了，那么匹配成功 { printf(&quot;%d &quot;,i-n); j=ne[j]; } } return 0; } 2.4 Trie统计字符串 //son数组第一维表示n号节点，第二维表示它的第几个儿子 int son[N][26],cnt[N],idx; char str[N]; void insert(char str[]) { int p=0; for(int i=0 ; str[i] ; i++) { int u = str[i] - 'a'; //将字母映射到下标 if(!son[p][u]) son[p][u]=++idx; //如果该节点的儿子不存在，那么就将它加入进去 p=son[p][u]; //转到p号节点的u号儿子 } cnt[p]++; //出现次数+1 } int query(char str[]) { int p=0; for(int i=0;str[i];i++) { int u = str[i] - 'a'; if(!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main() { int n; cin&gt;&gt;n; while (n -- ){ char op[2]; scanf(&quot;%s%s&quot;,op,str); if(op[0] == 'I') insert(str); else printf(&quot;%d\\n&quot;, query(str)); } return 0; } 2.5 并查集带维护集合大小 int find(int x) // 并查集 { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { p[i]=i; siz[i]=1; } cin&gt;&gt;m; while (m -- ) { char op[5]; int a,b; scanf(&quot;%s&quot;,op); if(op[0] == 'C') { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(find(a) == find(b)) continue; siz[find(b)] += siz[find(a)]; p[find(a)] = find(b); } else if(op[1] == '1') { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(find(a) == find(b)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } else if(op[1] == '2') { scanf(&quot;%d&quot;,&amp;a); cout&lt;&lt;siz[find(a)]&lt;&lt;endl; } } return 0; } 2.6 拓展域并查集（拆点） int find(int x) { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin &gt;&gt; n &gt;&gt; k; int res = 0; for(int i = 1; i &lt;= 3 * n; i ++) p[i] = i; while(k --) { int d, x, y; cin &gt;&gt; d &gt;&gt; x &gt;&gt; y; int xs = x, xe = x + n, xy = x + 2 * n; int ys = y, ye = y + n, yy = y + 2 * n; if(d == 1) { if(x &gt; n || y &gt; n) res ++; else if(find(xs) == find(yy)) res ++; else if(find(ye) == find(xs)) res ++; else { p[find(xs)] = find(ys); p[find(xe)] = find(ye); p[find(xy)] = find(yy); } } if(d == 2) { if(x &gt; n || y &gt; n) res ++; else if(x == y) res ++; else if(find(xs) == find(ys)) res ++; else if(find(ye) == find(xs)) res ++; else { p[find(xe)] = find(ys); p[find(xs)] = find(yy); p[find(xy)] = find(ye); } } } cout &lt;&lt; res &lt;&lt; endl; return 0; } 2.7 手写堆排序 int h[N]; int n,m; int siz; void down(int u) { int t = u; //t为最小值 if(u * 2 &lt;= siz &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; //如果左儿子存在并且左儿子的值小于父节点的值，那么最小值更新为左儿子 if(u * 2 + 1 &lt;= siz &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; //如果右儿子存在并且右儿子的值小于父节点的值，那么最小值更新为右儿子 if(u != t) //如果传入的值不是最小值，那么将该值与最小值互换，然后递归将该值放入堆中 { swap(h[u], h[t]); down(t); } } void up(int u) { while(u / 2 &amp;&amp; h[u / 2] &gt; h[u]) { swap(h[u / 2], h[u]); u /= 2; } } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;h[i]); siz = n; for(int i = n / 2; i; i--) down(i); while (m -- ) { cout &lt;&lt; h[1] &lt;&lt; &quot; &quot;; h[1] = h[siz]; siz--; down(1); } return 0; } 2.8 字符串哈希 //用于判断两个区间内的字符串是否完全相同 typedef unsigned long long ULL; const int N = 1e5 + 5, P = 131; ULL h[N], p[N]; ULL query(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; string x; cin &gt;&gt; x; p[0] = 1; h[0] = 0; for(int i = 0; i &lt; n; i ++) { p[i + 1] = p[i] * P; h[i + 1] = h[i] * P + x[i]; } while(m --) { int l1, r1, l2, r2; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2; if(query(l1, r1) == query(l2, r2)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; } return 0; } 2.9 树状数组 2.9.1 区间修改，单点查询 LL tr[N]; int a[N]; int n, m; int lowbit(int x) { return x &amp; -x; } void add(int x, int c) { for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; } LL sum(int x) { LL res = 0; for(int i = x; i ; i -= lowbit(i)) res += tr[i]; return res; } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n ; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n ;i ++) { add(i, a[i] - a[i - 1]); } while(m --) { char op[2]; int l; scanf(&quot;%s%d&quot;, op, &amp;l); if(op[0] == 'C') { int r, d; cin &gt;&gt; r &gt;&gt; d; add(l, d); add(r + 1, -d); } else cout &lt;&lt; sum(l) &lt;&lt; endl; } return 0; } 2.9.2 单点修改，区间查询 int lowbit(int x) { return x &amp; -x; } void add(int x, int c) { for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; } int sum(int x) { int res = 0; for(int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } 2.9.3 区间修改，区间查询 int a[N]; LL tr1[N], tr2[N]; int n, m; int lowbit(int x) { return x &amp; -x; } void add(LL tr[], int x, LL c) { for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; } LL sum(LL tr[], int x) { LL res = 0; for(int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } LL pre_sum(int x) //求原数组的前缀和 { return sum(tr1, x) * (x + 1) - sum(tr2, x); } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i ++) { int b = a[i] - a[i - 1]; add(tr1, i, b); add(tr2, i, (LL)b * i); } while(m --) { char op[2]; int l ,r, d; scanf(&quot;%s%d%d&quot;, op, &amp;l, &amp;r); if(op[0] == 'Q') printf(&quot;%lld\\n&quot;, pre_sum(r) - pre_sum(l - 1)); //原数组的区间查询 else { cin &gt;&gt; d; add(tr1, l, d), add(tr2, l, l * d); add(tr1, r + 1, -d), add(tr2, r + 1, (r + 1) * -d); } } return 0; } 2.10 线段树 2.10.1 单点修改，区间查询 #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10; struct info { int minv, cnt_min; }; struct Node { info val; }tr[N * 4]; int n, q; int a[N]; info operator + (const info &amp;l, const info &amp;r) { info a; a.minv = min(l.minv, r.minv); if(l.minv == r.minv) a.cnt_min = l.cnt_min + r.cnt_min; else if(l.minv &lt; r.minv) a.cnt_min = l.cnt_min; else a.cnt_min = r.cnt_min; return a; } void pushup(int u) { tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val; } void build(int u, int l, int r) { if(l == r) tr[u].val = {a[l], 1}; else { int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void change(int u, int l, int r, int pos, int val) { if(l == r) tr[u].val = {val, 1}; else { int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) change(u &lt;&lt; 1, l, mid, pos, val); else change(u &lt;&lt; 1 | 1, mid + 1, r, pos, val); pushup(u); } } info query(int u, int l, int r, int ql, int qr) { if(l == ql &amp;&amp; r == qr) return tr[u].val; int mid = l + r &gt;&gt; 1; if(qr &lt;= mid) return query(u &lt;&lt; 1, l, mid, ql, qr); else if(ql &gt; mid) return query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr); else { return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 1, n); while(q --) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if(a == 1) { change(1, 1, n, b, c); } else { auto a = query(1, 1, n, b, c); printf(&quot;%d %d\\n&quot;, a.minv, a.cnt_min); } } } 2.10.2 区间最大公约数（区间修改，区间查询） struct Node{ int l, r; LL sum, d; }tr[N * 4]; LL a[N]; LL gcd(LL a, LL b) { return b ? gcd(b, a % b) : a; } void build(int u, int l, int r) { if(l == r) { LL b = a[r] - a[r - 1]; tr[u] = {l, l, b, b}; } else { tr[u] = {l ,r}; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum; tr[u].d = gcd(tr[u &lt;&lt; 1].d, tr[u &lt;&lt; 1 | 1].d); } } Node query(int u, int l, int r) { if(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) return tr[u]; else { int mid = tr[u].l + tr[u].r &gt;&gt; 1; if(r &lt;= mid) return query(u &lt;&lt; 1, l, r); if(l &gt; mid) return query(u &lt;&lt; 1 | 1, l, r); else { auto left = query(u &lt;&lt; 1, l, r); auto right = query(u &lt;&lt; 1 | 1, l, r); Node res; res.sum = left.sum + right.sum; res.d = gcd(left.d, right.d); return res; } } } void modify(int u, int x, LL c) { if(tr[u].l == x &amp;&amp; tr[u].r == x) { LL b = tr[u].sum + c; tr[u] = {x, x, b, b}; } else { int mid = tr[u].l +tr[u].r &gt;&gt; 1; if(x &lt;= mid) modify(u &lt;&lt; 1, x, c); else modify(u &lt;&lt; 1 | 1, x, c); tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum; tr[u].d = gcd(tr[u &lt;&lt; 1].d, tr[u &lt;&lt; 1 | 1].d); } } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; build(1, 1, n); char op[2]; while(m --) { int l, r; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if(op[0] == 'C') { LL d; cin &gt;&gt; d; modify(1, l, d); if(r + 1 &lt;= n) modify(1, r + 1, -d); } else { auto left = query(1, 1, l); Node right({0, 0, 0, 0}); if(l + 1 &lt;= r) right = query(1, l + 1, r); cout &lt;&lt; abs(gcd(left.sum, right.d)) &lt;&lt; endl; } } return 0; } 2.10.3 带懒标记的区间修改，区间查询 #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10; typedef long long ll; ll n, q; ll a[N]; struct info { ll maxv; }; struct tag { ll add; }; info operator + (const info &amp;l, const info &amp;r) { return {max(l.maxv, r.maxv)}; } info operator + (const info &amp;v, const tag &amp;t) { return {v.maxv + t.add}; } tag operator + (const tag &amp;t1, const tag &amp;t2) { return {t1.add + t2.add}; } struct node { tag t; info val; }tr[N * 4]; void pushup(int u) { tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val; } void settag(int u, tag t) { tr[u].val = tr[u].val + t; tr[u].t = tr[u].t + t; } void pushdown(int u) { if(tr[u].t.add != 0) { settag(u &lt;&lt; 1, tr[u].t); settag(u &lt;&lt; 1 | 1, tr[u].t); tr[u].t.add = 0; } } void build(int u, int l, int r) { if(l == r) tr[u].val = {a[l]}; else { ll mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int l, int r, int ql, int qr, tag t) { if(l == ql &amp;&amp; r == qr) { settag(u, t); return ; } ll mid = l + r &gt;&gt; 1; pushdown(u); if(qr &lt;= mid) modify(u &lt;&lt; 1, l, mid, ql, qr, t); else if(ql &gt; mid) modify(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr, t); else { modify(u &lt;&lt; 1, l, mid, ql, mid, t); modify(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr, t); } pushup(u); } info query(int u, int l, int r, int ql, int qr) { if(l == ql &amp;&amp; r == qr) return tr[u].val; ll mid = l + r &gt;&gt; 1; pushdown(u); if(qr &lt;= mid) query(u &lt;&lt; 1, l, mid, ql, qr); else if(ql &gt; mid) query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr); else { return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 1, n); while(q --) { int op; scanf(&quot;%d&quot;, &amp;op); if(op == 1) { int l, r, d; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d); modify(1, 1, n, l, r, (tag){d}); } else { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); auto a = query(1, 1, n, l, r); printf(&quot;%lld\\n&quot;, a.maxv); } } return 0; } 2.10.4 扫描线求矩形的面积并 struct Segment { double x, y1, y2; int k; bool operator&lt; (const Segment &amp;t)const { return x &lt; t.x; } }seg[N * 2]; struct Node { int l, r; int cnt; double len; }tr[N * 8]; vector&lt;double&gt; ys; int find(double y) { return lower_bound(ys.begin(), ys.end(), y) - ys.begin(); } void pushup(int u) { if (tr[u].cnt) tr[u].len = ys[tr[u].r + 1] - ys[tr[u].l]; else if (tr[u].l != tr[u].r) { tr[u].len = tr[u &lt;&lt; 1].len + tr[u &lt;&lt; 1 | 1].len; } else tr[u].len = 0; } void build(int u, int l, int r) { tr[u] = {l, r, 0, 0}; if (l != r) { int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); } } void modify(int u, int l, int r, int k) { if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) { tr[u].cnt += k; pushup(u); } else { int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, k); if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, k); pushup(u); } } int main() { int T = 1; while (scanf(&quot;%d&quot;, &amp;n), n) { ys.clear(); for (int i = 0, j = 0; i &lt; n; i ++ ) { double x1, y1, x2, y2; scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); seg[j ++ ] = {x1, y1, y2, 1}; seg[j ++ ] = {x2, y1, y2, -1}; ys.push_back(y1), ys.push_back(y2); } sort(ys.begin(), ys.end()); ys.erase(unique(ys.begin(), ys.end()), ys.end()); build(1, 0, ys.size() - 2); sort(seg, seg + n * 2); double res = 0; for (int i = 0; i &lt; n * 2; i ++ ) { if (i &gt; 0) res += tr[1].len * (seg[i].x - seg[i - 1].x); modify(1, find(seg[i].y1), find(seg[i].y2) - 1, seg[i].k); } printf(&quot;Test case #%d\\n&quot;, T ++ ); printf(&quot;Total explored area: %.2lf\\n\\n&quot;, res); } return 0; } 2.10.5 动态开点与权值线段树 //待补充 2.11 可持久化数据结构 2.11.1 可持久化Trie //支持两种操作：末尾添加一个数，求一个位置p，使得p在l-r之间，且a[p] xor ... xor a[n] xor x的值最大 int tr[M][2], max_id[M]; int root[N]; int n, m, idx; int s[N]; void insert(int i, int k, int p, int q) //i为前缀和下标，k为当前第几位，p为上一个版本，q为当前版本 { if(k &lt; 0) { max_id[q] = i; return ; } int v = s[i] &gt;&gt; k &amp; 1; if(p) tr[q][v ^ 1] = tr[p][v ^ 1]; tr[q][v] = ++ idx; insert(i, k - 1, tr[p][v], tr[q][v]); max_id[q] = max(max_id[tr[q][0]], max_id[tr[q][1]]); } int query(int root, int c, int l) { int p = root; for(int i = 23; i &gt;= 0; i --) { int v = c &gt;&gt; i &amp; 1; if(max_id[tr[p][v ^ 1]] &gt;= l) p = tr[p][v ^ 1]; else p = tr[p][v]; } return c ^ s[max_id[p]]; } int main() { cin &gt;&gt; n &gt;&gt; m; max_id[0] = -1; root[0] = ++ idx; insert(0, 23, 0, root[0]); for(int i = 1; i &lt;= n; i ++) { int x; cin &gt;&gt; x; s[i] = s[i - 1] ^ x; root[i] = ++ idx; insert(i, 23, root[i - 1], root[i]); } char op[2]; int l, r, x; while(m --) { cin &gt;&gt; op; if(op[0] == 'A') { cin &gt;&gt; x; n ++; s[n] = s[n - 1] ^ x; root[n] = ++ idx; insert(n, 23, root[n - 1], root[n]); } else { cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; cout &lt;&lt; query(root[r - 1], s[n] ^ x, l - 1) &lt;&lt; endl; } } return 0; } 2.11.2 可持久化线段树(主席树) //求区间内第k小数 int n, m; int a[N]; vector&lt;int&gt; nums; struct Node { int l, r; int cnt; }tr[N * 4 + N * 17]; int root[N], idx; int build(int l, int r) //l,r表示左右儿子 { int p = ++ idx; if(l == r) return p; int mid = l + r &gt;&gt; 1; tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r); return p; } int insert(int p, int l, int r, int x) { int q = ++ idx; tr[q] = tr[p]; if(l == r) { tr[q].cnt ++; return q; } int mid = l + r &gt;&gt; 1; if(x &lt;= mid) tr[q].l = insert(tr[p].l, l, mid, x); else tr[q].r = insert(tr[p].r, mid + 1, r, x); tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt; return q; } int find(int x) { return lower_bound(nums.begin(), nums.end(), x) - nums.begin(); } int query(int q, int p, int l, int r, int k) { if(l == r) return r; int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt; int mid = l + r &gt;&gt; 1; if(k &lt;= cnt) return query(tr[q].l, tr[p].l, l, mid, k); else return query(tr[q].r, tr[p].r, mid + 1, r, k - cnt); } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; nums.push_back(a[i]); } sort(nums.begin(), nums.end()); nums.erase(unique(nums.begin(), nums.end()), nums.end()); root[0] = build(0, nums.size() - 1); for(int i = 1; i &lt;= n; i ++) root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i])); while(m --) { int l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &lt;&lt; endl; } } 2.12 平衡树 2.12.1 普通平衡树（Treap） /* 支持的操作： 1. 插入数值 x。 2. 删除数值 x(若有多个相同的数，应只删除一个)。 3. 查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。 4. 查询排名为 x 的数值。 5. 求数值 x 的前驱(前驱定义为小于 x 的最大的数)。 6. 求数值 x 的后继(后继定义为大于 x 的最小的数)。 */ struct Node { int l, r; int key, val; int cnt, size; //cnt表示某个数出现的次数，size表示子树中有多少个数 }tr[N]; int root, idx; //idx表示当前分配到第几个节点 void pushup(int p) { tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt; } int get_node(int key) //创建节点 { tr[++ idx].key = key; tr[idx].val = rand(); tr[idx].cnt = tr[idx].size = 1; //初始化cnt和size return idx; } void zig(int &amp;p) //右旋，传引用 { int q = tr[p].l; tr[p].l = tr[q].r, tr[q].r = p, p = q; pushup(tr[p].r), pushup(p); } void zag(int &amp;p) { int q = tr[p].r; tr[p].r = tr[q].l, tr[q].l = p, p = q; pushup(tr[p].l), pushup(p); } void build() { get_node(-INF), get_node(INF); //插入正无穷和无负穷哨兵 root = 1, tr[1].r = 2; //根节点是一号点，右儿子是二号点 pushup(root); if(tr[1].val &lt;tr[2].val) zag(root); } void insert(int &amp;p, int key) { if(!p) p = get_node(key); else if(tr[p].key == key) tr[p].cnt ++; else if(tr[p].key &gt; key) { insert(tr[p].l, key); if(tr[tr[p].l].val &gt; tr[p].val) zig(p); } else { insert(tr[p].r, key); if(tr[tr[p].r].val &gt; tr[p].val) zag(p); } pushup(p); } void remove(int &amp;p, int key) { if(!p) return ; if(tr[p].key == key) { if(tr[p].cnt &gt; 1) tr[p].cnt --; else if(tr[p].l || tr[p].r) { if(!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val) { zig(p); remove(tr[p].r, key); } else { zag(p); remove(tr[p].l, key); } } else p = 0; } else if(tr[p].key &gt; key) remove(tr[p].l, key); else remove(tr[p].r, key); pushup(p); } int get_rank_by_key(int &amp;p, int key) //通过排名找数值 { if(!p) return 0; if(tr[p].key == key) return tr[tr[p].l].size + 1; if(tr[p].key &gt; key) return get_rank_by_key(tr[p].l, key); return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r, key); } int get_key_by_rank(int &amp;p, int rank) //通过数值找排名 { if(!p) return INF; if(tr[tr[p].l].size &gt;= rank) return get_key_by_rank(tr[p].l, rank); if(tr[tr[p].l].size + tr[p].cnt &gt;= rank) return tr[p].key; return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt); } int get_prev(int &amp;p, int key) //找到严格小于key的最大数 { if(!p) return -INF; if(tr[p].key &gt;= key) return get_prev(tr[p].l, key); return max(tr[p].key, get_prev(tr[p].r, key)); } int get_next(int &amp;p, int key) //找到严格大于key的最小数 { if(!p) return INF; if(tr[p].key &lt;= key) return get_next(tr[p].r, key); return min(tr[p].key, get_next(tr[p].l, key)); } int main() { build(); cin &gt;&gt; n; while(n --) { int op, x; cin &gt;&gt; op &gt;&gt; x; if(op == 1) insert(root, x); else if(op == 2) remove(root, x); else if(op == 3) cout &lt;&lt; get_rank_by_key(root, x) - 1 &lt;&lt; endl; else if(op == 4) cout &lt;&lt; get_key_by_rank(root, x + 1) &lt;&lt; endl; else if(op == 5) cout &lt;&lt; get_prev(root, x) &lt;&lt; endl; else if(op == 6) cout &lt;&lt; get_next(root, x) &lt;&lt; endl; } return 0; } 2.12.2 Splay(伸展树) /* m 次操作，每次操作选定一个子序列 [l,r]，并将该子序列中的所有数字进行翻转 */ int n, m; struct Node { int s[2], p, v; int size, flag; void init(int _v, int _p) { v = _v, p = _p; size = 1; } }tr[N]; int root, idx; void pushup(int x) { tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1; } void pushdown(int x) { if (tr[x].flag) { swap(tr[x].s[0], tr[x].s[1]); tr[tr[x].s[0]].flag ^= 1; tr[tr[x].s[1]].flag ^= 1; tr[x].flag = 0; } } void rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = tr[y].s[1] == x; // k=0表示x是y的左儿子；k=1表示x是y的右儿子 tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; pushup(y), pushup(x); } void splay(int x, int k) { while (tr[x].p != k) { int y = tr[x].p, z = tr[y].p; if (z != k) if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x); else rotate(y); rotate(x); } if (!k) root = x; } void insert(int v) { int u = root, p = 0; while (u) p = u, u = tr[u].s[v &gt; tr[u].v]; u = ++ idx; if (p) tr[p].s[v &gt; tr[p].v] = u; tr[u].init(v, p); splay(u, 0); } int get_k(int k) { int u = root; while (true) { pushdown(u); if (tr[tr[u].s[0]].size &gt;= k) u = tr[u].s[0]; else if (tr[tr[u].s[0]].size + 1 == k) return u; else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1]; } return -1; } void output(int u) { pushdown(u); if (tr[u].s[0]) output(tr[u].s[0]); if (tr[u].v &gt;= 1 &amp;&amp; tr[u].v &lt;= n) printf(&quot;%d &quot;, tr[u].v); if (tr[u].s[1]) output(tr[u].s[1]); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt;= n + 1; i ++ ) insert(i); while (m -- ) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); l = get_k(l), r = get_k(r + 2); splay(l, 0), splay(r, l); tr[tr[r].s[0]].flag ^= 1; } output(root); return 0; } 2.13 AC自动机 /给定n个单词，长度为m的文章，求有多少个单词在文章中出现了 int n; int tr[N * S][26], cnt[N * S], idx; char str[M]; int q[N * S], ne[N * S]; void insert() { int p = 0; for (int i = 0; str[i]; i ++ ) { int t = str[i] - 'a'; if (!tr[p][t]) tr[p][t] = ++ idx; p = tr[p][t]; } cnt[p] ++ ; } void build() { int hh = 0, tt = -1; for (int i = 0; i &lt; 26; i ++ ) if (tr[0][i]) q[ ++ tt] = tr[0][i]; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = 0; i &lt; 26; i ++ ) { int p = tr[t][i]; if (!p) tr[t][i] = tr[ne[t]][i]; else { ne[p] = tr[ne[t]][i]; q[ ++ tt] = p; } } } } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T -- ) { memset(tr, 0, sizeof tr); memset(cnt, 0, sizeof cnt); memset(ne, 0, sizeof ne); idx = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) { scanf(&quot;%s&quot;, str); insert(); } build(); scanf(&quot;%s&quot;, str); int res = 0; for (int i = 0, j = 0; str[i]; i ++ ) { int t = str[i] - 'a'; j = tr[j][t]; int p = j; while (p) { res += cnt[p]; cnt[p] = 0; p = ne[p]; } } printf(&quot;%d\\n&quot;, res); } return 0; } 2.14 分块与莫队 2.14.1 分块解决区间修改，区间查询 LL a[N], sum[N], add[N]; int L[N], R[N]; int pos[N]; int n, m, t; void modify(int l, int r, LL d) { int p = pos[l], q = pos[r]; if(p == q) { for(int i = l; i &lt;= r; i ++) a[i] += d; sum[p] += d * (r - l + 1); } else { for(int i = p + 1; i &lt;= q - 1; i ++) add[i] += d; for(int i = l; i &lt;= R[p]; i ++) a[i] += d; sum[p] += d * (R[p] - l + 1); for(int i = L[q]; i &lt;= r; i ++) a[i] += d; sum[q] += d * (r - L[q] + 1); } } LL query(int l, int r) { int p = pos[l], q = pos[r]; LL ans = 0; if(p == q) { for(int i = l; i &lt;= r; i ++) ans += a[i]; ans += add[p] * (r - l + 1); } else { for(int i = p + 1; i &lt;= q - 1; i ++) ans += sum[i] + add[i] * (R[i] - L[i] + 1); for(int i = l; i &lt;= R[p]; i ++) ans += a[i]; ans += add[p] * (R[p] - l + 1); for(int i = L[q]; i &lt;= r; i ++) ans += a[i]; ans += add[q] * (r - L[q] + 1); } return ans; } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; //分块 t = sqrt(n); for(int i = 1; i &lt;= t; i ++) { L[i] = (i - 1) * sqrt(n) + 1; R[i] = i * sqrt(n); } if(R[t] &lt; n) { t ++; L[t] = R[t - 1] + 1; R[t] = n; } for(int i = 1; i &lt;= t; i ++) { for(int j = L[i]; j &lt;= R[i]; j ++) { pos[j] = i; sum[i] += a[j]; } } while(m --) { char op[3]; int l, r, d; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if(op[0] == 'C') { cin &gt;&gt; d; modify(l, r, d); } else cout &lt;&lt; query(l, r) &lt;&lt; endl; } return 0; } 2.14.2 分块-块状链表 //待补充 2.14.3 基础莫队 //求一段区间内有多少个不同的数 int n, m, len; int w[N], ans[M]; struct Query{ int id, l, r; }q[M]; int cnt[S]; int get(int x) //求块的编号 { return x / len; } bool cmp(const Query&amp; a, const Query&amp; b) { int i = get(a.l), j = get(b.l); if(i != j) return i &lt; j; return a.r &lt; b.r; } void add(int x, int&amp; res) { if(!cnt[x]) res ++; cnt[x] ++; } void del(int x, int &amp; res) { cnt[x] --; if(!cnt[x]) res --; } int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; w[i]; cin &gt;&gt; m; len = max(1, (int)sqrt((double)n * n / m)); for(int i = 0; i &lt; m; i ++) { int l, r; cin &gt;&gt; l &gt;&gt; r; q[i] = {i, l, r}; } sort(q, q + m, cmp); for(int k = 0, i = 0, j = 1, res = 0; k &lt; m; k ++) //处理所有询问 { int id = q[k].id, l = q[k].l, r = q[k].r; //区间的编号，区间左右端点 while(i &lt; r) add(w[ ++ i], res); //当前区间加一个数 while(i &gt; r) del(w[i --], res); while(j &lt; l) del(w[j ++], res); while(j &gt; l) add(w[-- j], res); ans[id] = res; } for(int i = 0; i &lt; m; i ++) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0; } 2.15 点分治 //求树上边权长度不超过K的路径有多少条 int n, m; int h[N], e[M], w[M], ne[M], idx; bool st[N]; //表示点是否被删掉 int p[N], q[N]; void add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx ++; } int get_size(int u, int fa) //求子树大小 { if(st[u]) return 0; int res = 1; for(int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if(j != fa) res += get_size(j, u); } return res; } int get_wc(int u, int fa, int tot, int&amp; wc) //求树的重心 { if(st[u]) return 0; int sum = 1, ms = 0; for(int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if(j == fa) continue; int t = get_wc(j, u, tot, wc); ms = max(ms, t); sum += t; } ms = max(ms, tot - sum); if(ms &lt;= tot / 2) wc = u; return sum; } void get_dist(int u, int fa, int dist, int&amp; qt) { if(st[u]) return ; q[qt ++] = dist; for(int i = h[u]; ~i; i = ne[i]) if(e[i] != fa) get_dist(e[i], u, dist + w[i], qt); } int get(int a[], int k) { sort(a, a + k); int res = 0; for(int i = k - 1, j = -1; i &gt;= 0; i --) { while(j + 1 &lt; i &amp;&amp; a[j + 1] + a[i] &lt;= m) j ++; j = min(j, i - 1); res += j + 1; } return res; } int calc(int u) { if(st[u]) return 0; int res = 0; get_wc(u, -1, get_size(u, -1), u); st[u] = true; int pt = 0; for(int i = h[u]; ~i; i = ne[i]) { int j = e[i], qt = 0; get_dist(j, -1, w[i], qt); res -= get(q, qt); for(int k = 0; k &lt; qt; k ++) { if(q[k] &lt;= m) res ++; p[pt ++] = q[k]; } } res += get(p, pt); for(int i = h[u]; ~i; i = ne[i]) { res += calc(e[i]); } return res; } int main() { while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n, m) { memset(st, 0, sizeof st); idx = 0; memset(h, -1, sizeof h); for(int i = 0; i &lt; n - 1; i ++) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); add(b, a, c); } cout &lt;&lt; calc(0) &lt;&lt; endl; } return 0; } 2.16 树套树(线段树套平衡树) /* 树套树用于维护一个长度为n的数列，支持以下操作 1. `1 l r x`，查询整数 x 在区间 [l,r] 内的排名。 2. `2 l r k`，查询区间 [l,r] 内排名为 k 的值。 3. `3 pos x`，将 pos 位置的数修改为 x。 4. `4 l r x`，查询整数 x 在区间 [l,r] 内的前驱(前驱定义为小于 x，且最大的数)。 5. `5 l r x`，查询整数 x 在区间 [l,r] 内的后继(后继定义为大于 x，且最小的数)。的数)。 */ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 2000010, INF = 1e9; int n, m; struct Node { int s[2], p, v; int size; void init(int _v, int _p) { v = _v, p = _p; size = 1; } }tr[N]; int L[N], R[N], T[N], idx; int w[N]; void pushup(int x) { tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1; } void rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = tr[y].s[1] == x; tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; pushup(y), pushup(x); } void splay(int&amp; root, int x, int k) { while (tr[x].p != k) { int y = tr[x].p, z = tr[y].p; if (z != k) if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x); else rotate(y); rotate(x); } if (!k) root = x; } void insert(int&amp; root, int v) { int u = root, p = 0; while (u) p = u, u = tr[u].s[v &gt; tr[u].v]; u = ++ idx; if (p) tr[p].s[v &gt; tr[p].v] = u; tr[u].init(v, p); splay(root, u, 0); } int get_k(int root, int v) { int u = root, res = 0; while (u) { if (tr[u].v &lt; v) res += tr[tr[u].s[0]].size + 1, u = tr[u].s[1]; else u = tr[u].s[0]; } return res; } void update(int&amp; root, int x, int y) { int u = root; while (u) { if (tr[u].v == x) break; if (tr[u].v &lt; x) u = tr[u].s[1]; else u = tr[u].s[0]; } splay(root, u, 0); int l = tr[u].s[0], r = tr[u].s[1]; while (tr[l].s[1]) l = tr[l].s[1]; while (tr[r].s[0]) r = tr[r].s[0]; splay(root, l, 0), splay(root, r, l); tr[r].s[0] = 0; pushup(r), pushup(l); insert(root, y); } void build(int u, int l, int r) { L[u] = l, R[u] = r; insert(T[u], -INF), insert(T[u], INF); for (int i = l; i &lt;= r; i ++ ) insert(T[u], w[i]); if (l == r) return; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); } int query(int u, int a, int b, int x) { if (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) return get_k(T[u], x) - 1; int mid = L[u] + R[u] &gt;&gt; 1, res = 0; if (a &lt;= mid) res += query(u &lt;&lt; 1, a, b, x); if (b &gt; mid) res += query(u &lt;&lt; 1 | 1, a, b, x); return res; } void change(int u, int p, int x) { update(T[u], w[p], x); if (L[u] == R[u]) return; int mid = L[u] + R[u] &gt;&gt; 1; if (p &lt;= mid) change(u &lt;&lt; 1, p, x); else change(u &lt;&lt; 1 | 1, p, x); } int get_pre(int root, int v) { int u = root, res = -INF; while (u) { if (tr[u].v &lt; v) res = max(res, tr[u].v), u = tr[u].s[1]; else u = tr[u].s[0]; } return res; } int get_suc(int root, int v) { int u = root, res = INF; while (u) { if (tr[u].v &gt; v) res = min(res, tr[u].v), u = tr[u].s[0]; else u = tr[u].s[1]; } return res; } int query_pre(int u, int a, int b, int x) { if (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) return get_pre(T[u], x); int mid = L[u] + R[u] &gt;&gt; 1, res = -INF; if (a &lt;= mid) res = max(res, query_pre(u &lt;&lt; 1, a, b, x)); if (b &gt; mid) res = max(res, query_pre(u &lt;&lt; 1 | 1, a, b, x)); return res; } int query_suc(int u, int a, int b, int x) { if (L[u] &gt;= a &amp;&amp; R[u] &lt;= b) return get_suc(T[u], x); int mid = L[u] + R[u] &gt;&gt; 1, res = INF; if (a &lt;= mid) res = min(res, query_suc(u &lt;&lt; 1, a, b, x)); if (b &gt; mid) res = min(res, query_suc(u &lt;&lt; 1 | 1, a, b, x)); return res; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); build(1, 1, n); while (m -- ) { int op, a, b, x; scanf(&quot;%d&quot;, &amp;op); if (op == 1) { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x); printf(&quot;%d\\n&quot;, query(1, a, b, x) + 1); } else if (op == 2) { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x); int l = 0, r = 1e8; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (query(1, a, b, mid) + 1 &lt;= x) l = mid; else r = mid - 1; } printf(&quot;%d\\n&quot;, r); } else if (op == 3) { scanf(&quot;%d%d&quot;, &amp;a, &amp;x); change(1, a, x); w[a] = x; } else if (op == 4) { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x); printf(&quot;%d\\n&quot;, query_pre(1, a, b, x)); } else { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;x); printf(&quot;%d\\n&quot;, query_suc(1, a, b, x)); } } return 0; } 树套树动态维护区间第k大数 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 50010, P = N * 17 * 17, M = N * 4; int n, m; struct Tree { int l, r, sum, add; }tr[P]; int L[M], R[M], T[M], idx; struct Query { int op, a, b, c; }q[N]; vector&lt;int&gt; nums; int get(int x) { return lower_bound(nums.begin(), nums.end(), x) - nums.begin(); } void build(int u, int l, int r) { L[u] = l, R[u] = r, T[u] = ++ idx; if (l == r) return; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); } int intersection(int a, int b, int c, int d) { return min(b, d) - max(a, c) + 1; } void update(int u, int l, int r, int pl, int pr) { tr[u].sum += intersection(l, r, pl, pr); if (l &gt;= pl &amp;&amp; r &lt;= pr) { tr[u].add ++ ; return; } int mid = l + r &gt;&gt; 1; if (pl &lt;= mid) { if (!tr[u].l) tr[u].l = ++ idx; update(tr[u].l, l, mid, pl, pr); } if (pr &gt; mid) { if (!tr[u].r) tr[u].r = ++ idx; update(tr[u].r, mid + 1, r, pl, pr); } } void change(int u, int a, int b, int c) { update(T[u], 1, n, a, b); if (L[u] == R[u]) return; int mid = L[u] + R[u] &gt;&gt; 1; if (c &lt;= mid) change(u &lt;&lt; 1, a, b, c); else change(u &lt;&lt; 1 | 1, a, b, c); } int get_sum(int u, int l, int r, int pl, int pr, int add) { if (l &gt;= pl &amp;&amp; r &lt;= pr) return tr[u].sum + (r - l + 1) * add; int mid = l + r &gt;&gt; 1, res = 0; add += tr[u].add; if (pl &lt;= mid) { if (tr[u].l) res += get_sum(tr[u].l, l, mid, pl, pr, add); else res += intersection(l, mid, pl, pr) * add; } if (pr &gt; mid) { if (tr[u].r) res += get_sum(tr[u].r, mid + 1, r, pl, pr, add); else res += intersection(mid + 1, r, pl, pr) * add; } return res; } int query(int u, int a, int b, int c) { if (L[u] == R[u]) return R[u]; int mid = L[u] + R[u] &gt;&gt; 1; int k = get_sum(T[u &lt;&lt; 1 | 1], 1, n, a, b, 0); if (k &gt;= c) return query(u &lt;&lt; 1 | 1, a, b, c); return query(u &lt;&lt; 1, a, b, c - k); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; i ++ ) { scanf(&quot;%d%d%d%d&quot;, &amp;q[i].op, &amp;q[i].a, &amp;q[i].b, &amp;q[i].c); if (q[i].op == 1) nums.push_back(q[i].c); } sort(nums.begin(), nums.end()); nums.erase(unique(nums.begin(), nums.end()), nums.end()); build(1, 0, nums.size() - 1); for (int i = 0; i &lt; m; i ++ ) { int op = q[i].op, a = q[i].a, b = q[i].b, c = q[i].c; if (op == 1) change(1, a, b, get(c)); else printf(&quot;%d\\n&quot;, nums[query(1, a, b, c)]); } return 0; } 2.17 树链剖分(树上差分plus) /* 维护一棵树，支持以下操作： - `1 u v k`，修改路径上节点权值，将节点 u 和节点 v 之间路径上的所有节点（包括这两个节点）的权值增加 k。 - `2 u k`，修改子树上节点权值，将以节点 u 为根的子树上的所有节点的权值增加 k。 - `3 u v`，询问路径，询问节点 u 和节点 v 之间路径上的所有节点（包括这两个节点）的权值和。 - `4 u`，询问子树，询问以节点 u 为根的子树上的所有节点的权值和。 */ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 100010, M = N * 2; int n, m; int w[N], h[N], e[M], ne[M], idx; int id[N], nw[N], cnt; int dep[N], sz[N], top[N], fa[N], son[N]; struct Tree { int l, r; LL add, sum; }tr[N * 4]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void dfs1(int u, int father, int depth) { dep[u] = depth, fa[u] = father, sz[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; dfs1(j, u, depth + 1); sz[u] += sz[j]; if (sz[son[u]] &lt; sz[j]) son[u] = j; } } void dfs2(int u, int t) { id[u] = ++ cnt, nw[cnt] = w[u], top[u] = t; if (!son[u]) return; dfs2(son[u], t); for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa[u] || j == son[u]) continue; dfs2(j, j); } } void pushup(int u) { tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum; } void pushdown(int u) { auto &amp;root = tr[u], &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1]; if (root.add) { left.add += root.add, left.sum += root.add * (left.r - left.l + 1); right.add += root.add, right.sum += root.add * (right.r - right.l + 1); root.add = 0; } } void build(int u, int l, int r) { tr[u] = {l, r, 0, nw[r]}; if (l == r) return; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } void update(int u, int l, int r, int k) { if (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) { tr[u].add += k; tr[u].sum += k * (tr[u].r - tr[u].l + 1); return; } pushdown(u); int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (l &lt;= mid) update(u &lt;&lt; 1, l, r, k); if (r &gt; mid) update(u &lt;&lt; 1 | 1, l, r, k); pushup(u); } LL query(int u, int l, int r) { if (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) return tr[u].sum; pushdown(u); int mid = tr[u].l + tr[u].r &gt;&gt; 1; LL res = 0; if (l &lt;= mid) res += query(u &lt;&lt; 1, l, r); if (r &gt; mid) res += query(u &lt;&lt; 1 | 1, l, r); return res; } void update_path(int u, int v, int k) { while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); update(1, id[top[u]], id[u], k); u = fa[top[u]]; } if (dep[u] &lt; dep[v]) swap(u, v); update(1, id[v], id[u], k); } LL query_path(int u, int v) { LL res = 0; while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); res += query(1, id[top[u]], id[u]); u = fa[top[u]]; } if (dep[u] &lt; dep[v]) swap(u, v); res += query(1, id[v], id[u]); return res; } void update_tree(int u, int k) { update(1, id[u], id[u] + sz[u] - 1, k); } LL query_tree(int u) { return query(1, id[u], id[u] + sz[u] - 1); } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); memset(h, -1, sizeof h); for (int i = 0; i &lt; n - 1; i ++ ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b), add(b, a); } dfs1(1, -1, 1); dfs2(1, 1); build(1, 1, n); scanf(&quot;%d&quot;, &amp;m); while (m -- ) { int t, u, v, k; scanf(&quot;%d%d&quot;, &amp;t, &amp;u); if (t == 1) { scanf(&quot;%d%d&quot;, &amp;v, &amp;k); update_path(u, v, k); } else if (t == 2) { scanf(&quot;%d&quot;, &amp;k); update_tree(u, k); } else if (t == 3) { scanf(&quot;%d&quot;, &amp;v); printf(&quot;%lld\\n&quot;, query_path(u, v)); } else printf(&quot;%lld\\n&quot;, query_tree(u)); } return 0; } 2.18 动态树 /* 维护一棵树，支持以下操作： - `0 x y`，表示询问点 x 到点 y 之间的路径上的所有点（包括两端点）的权值的异或和。保证 x 和 y 之间存在连通路径。 - `1 x y`，表示在点 x 和点 y 之间增加一条边 (x,y)。注意：**如果两点已经处于连通状态，则无视该操作**。 - `2 x y`，表示删除边 (x,y)。注意：**如果该边不存在，则无视该操作**。 - `3 x w`，表示将点 x 的权值修改为 w。 */ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n, m; struct Node { int s[2], p, v; int sum, rev; }tr[N]; int stk[N]; void pushrev(int x) { swap(tr[x].s[0], tr[x].s[1]); tr[x].rev ^= 1; } void pushup(int x) { tr[x].sum = tr[tr[x].s[0]].sum ^ tr[x].v ^ tr[tr[x].s[1]].sum; } void pushdown(int x) { if (tr[x].rev) { pushrev(tr[x].s[0]), pushrev(tr[x].s[1]); tr[x].rev = 0; } } bool isroot(int x) { return tr[tr[x].p].s[0] != x &amp;&amp; tr[tr[x].p].s[1] != x; } void rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = tr[y].s[1] == x; if (!isroot(y)) tr[z].s[tr[z].s[1] == y] = x; tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; pushup(y), pushup(x); } void splay(int x) { int top = 0, r = x; stk[ ++ top] = r; while (!isroot(r)) stk[ ++ top] = r = tr[r].p; while (top) pushdown(stk[top -- ]); while (!isroot(x)) { int y = tr[x].p, z = tr[y].p; if (!isroot(y)) if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x); else rotate(y); rotate(x); } } void access(int x) // 建立一条从根到x的路径，同时将x变成splay的根节点 { int z = x; for (int y = 0; x; y = x, x = tr[x].p) { splay(x); tr[x].s[1] = y, pushup(x); } splay(z); } void makeroot(int x) // 将x变成原树的根节点 { access(x); pushrev(x); } int findroot(int x) // 找到x所在原树的根节点, 再将原树的根节点旋转到splay的根节点 { access(x); while (tr[x].s[0]) pushdown(x), x = tr[x].s[0]; splay(x); return x; } void split(int x, int y) // 给x和y之间的路径建立一个splay，其根节点是y { makeroot(x); access(y); } void link(int x, int y) // 如果x和y不连通，则加入一条x和y之间的边 { makeroot(x); if (findroot(y) != x) tr[x].p = y; } void cut(int x, int y) // 如果x和y之间存在边，则删除该边 { makeroot(x); if (findroot(y) == x &amp;&amp; tr[y].p == x &amp;&amp; !tr[y].s[0]) { tr[x].s[1] = tr[y].p = 0; pushup(x); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;tr[i].v); while (m -- ) { int t, x, y; scanf(&quot;%d%d%d&quot;, &amp;t, &amp;x, &amp;y); if (t == 0) { split(x, y); printf(&quot;%d\\n&quot;, tr[y].sum); } else if (t == 1) link(x, y); else if (t == 2) cut(x, y); else { splay(x); tr[x].v = y; pushup(x); } } return 0; } 2.19 Dancing Links(DLX) 2.19.1 精确覆盖问题 给定一个01矩阵A，找到一个行的集合，使得这些行中，每一列有且仅有一个数字1 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 5510; int n, m; int l[N], r[N], u[N], d[N], s[N], row[N], col[N], idx; int ans[N], top; void init() { for (int i = 0; i &lt;= m; i ++ ) { l[i] = i - 1, r[i] = i + 1; u[i] = d[i] = i; } l[0] = m, r[m] = 0; idx = m + 1; } void add(int&amp; hh, int&amp; tt, int x, int y) { row[idx] = x, col[idx] = y, s[y] ++ ; u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx; r[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh; tt = idx ++ ; } void remove(int p) { r[l[p]] = r[p], l[r[p]] = l[p]; for (int i = d[p]; i != p; i = d[i]) for (int j = r[i]; j != i; j = r[j]) { s[col[j]] -- ; u[d[j]] = u[j], d[u[j]] = d[j]; } } void resume(int p) { for (int i = u[p]; i != p; i = u[i]) for (int j = l[i]; j != i; j = l[j]) { u[d[j]] = j, d[u[j]] = j; s[col[j]] ++ ; } r[l[p]] = p, l[r[p]] = p; } bool dfs() { if (!r[0]) return true; int p = r[0]; for (int i = r[0]; i; i = r[i]) if (s[i] &lt; s[p]) p = i; remove(p); for (int i = d[p]; i != p; i = d[i]) { ans[ ++ top] = row[i]; for (int j = r[i]; j != i; j = r[j]) remove(col[j]); if (dfs()) return true; for (int j = l[i]; j != i; j = l[j]) resume(col[j]); top -- ; } resume(p); return false; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); init(); for (int i = 1; i &lt;= n; i ++ ) { int hh = idx, tt = idx; for (int j = 1; j &lt;= m; j ++ ) { int x; scanf(&quot;%d&quot;, &amp;x); if (x) add(hh, tt, i, j); } } if (dfs()) { for (int i = 1; i &lt;= top; i ++ ) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;); } else puts(&quot;No Solution!&quot;); return 0; } 填写16*16的数独 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 20000; int m = 16 * 16 * 4; int u[N], d[N], l[N], r[N], s[N], col[N], row[N], idx; int ans[N], top; struct Op { int x, y; char z; }op[N]; char g[20][20]; void init() { for (int i = 0; i &lt;= m; i ++ ) { l[i] = i - 1, r[i] = i + 1; s[i] = 0; d[i] = u[i] = i; } l[0] = m, r[m] = 0; idx = m + 1; } void add(int&amp; hh, int&amp; tt, int x, int y) { row[idx] = x, col[idx] = y, s[y] ++ ; u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx; r[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh; tt = idx ++ ; } void remove(int p) { r[l[p]] = r[p], l[r[p]] = l[p]; for (int i = d[p]; i != p; i = d[i]) for (int j = r[i]; j != i; j = r[j]) { s[col[j]] -- ; u[d[j]] = u[j], d[u[j]] = d[j]; } } void resume(int p) { for (int i = u[p]; i != p; i = u[i]) for (int j = l[i]; j != i; j = l[j]) { u[d[j]] = j, d[u[j]] = j; s[col[j]] ++ ; } r[l[p]] = p, l[r[p]] = p; } bool dfs() { if (!r[0]) return true; int p = r[0]; for (int i = r[0]; i; i = r[i]) if (s[i] &lt; s[p]) p = i; remove(p); for (int i = d[p]; i != p; i = d[i]) { ans[ ++ top] = row[i]; for (int j = r[i]; j != i; j = r[j]) remove(col[j]); if (dfs()) return true; for (int j = l[i]; j != i; j = l[j]) resume(col[j]); top -- ; } resume(p); return false; } int main() { while (~scanf(&quot;%s&quot;, g[0])) { for (int i = 1; i &lt; 16; i ++ ) scanf(&quot;%s&quot;, g[i]); init(); for (int i = 0, n = 1; i &lt; 16; i ++ ) for (int j = 0; j &lt; 16; j ++ ) { int a = 0, b = 15; if (g[i][j] != '-') a = b = g[i][j] - 'A'; for (int k = a; k &lt;= b; k ++, n ++ ) { int hh = idx, tt = idx; op[n] = {i, j, k + 'A'}; add(hh, tt, n, i * 16 + j + 1); add(hh, tt, n, 256 + i * 16 + k + 1); add(hh, tt, n, 256 * 2 + j * 16 + k + 1); add(hh, tt, n, 256 * 3 + (i / 4 * 4 + j / 4) * 16 + k + 1); } } dfs(); for (int i = 1; i &lt;= top; i ++ ) { auto t = op[ans[i]]; g[t.x][t.y] = t.z; } for (int i = 0; i &lt; 16; i ++ ) puts(g[i]); puts(&quot;&quot;); } return 0; } 2.19.2 重复覆盖问题 给定一个01矩阵A，找到一个行的集合，使得这些行中，每一列都包含数字1，且集合中包含的行数尽可能少。 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 10010; int n, m; int l[N], r[N], u[N], d[N], col[N], row[N], s[N], idx; int ans[N]; bool st[110]; void init() { for (int i = 0; i &lt;= m; i ++ ) { l[i] = i - 1, r[i] = i + 1; col[i] = u[i] = d[i] = i; s[i] = 0; } l[0] = m, r[m] = 0; idx = m + 1; } void add(int&amp; hh, int&amp; tt, int x, int y) { row[idx] = x, col[idx] = y, s[y] ++ ; u[idx] = y, d[idx] = d[y], u[d[y]] = idx, d[y] = idx; r[hh] = l[tt] = idx, r[idx] = tt, l[idx] = hh; tt = idx ++ ; } int h() { int cnt = 0; memset(st, 0, sizeof st); for (int i = r[0]; i; i = r[i]) { if (st[col[i]]) continue; cnt ++ ; st[col[i]] = true; for (int j = d[i]; j != i; j = d[j]) for (int k = r[j]; k != j; k = r[k]) st[col[k]] = true; } return cnt; } void remove(int p) { for (int i = d[p]; i != p; i = d[i]) { r[l[i]] = r[i]; l[r[i]] = l[i]; } } void resume(int p) { for (int i = u[p]; i != p; i = u[i]) { r[l[i]] = i; l[r[i]] = i; } } bool dfs(int k, int depth) { if (k + h() &gt; depth) return false; if (!r[0]) return true; int p = r[0]; for (int i = r[0]; i; i = r[i]) if (s[p] &gt; s[i]) p = i; for (int i = d[p]; i != p; i = d[i]) { ans[k] = row[i]; remove(i); for (int j = r[i]; j != i; j = r[j]) remove(j); if (dfs(k + 1, depth)) return true; for (int j = l[i]; j != i; j = l[j]) resume(j); resume(i); } return false; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); init(); for (int i = 1; i &lt;= n; i ++ ) { int hh = idx, tt = idx; for (int j = 1; j &lt;= m; j ++ ) { int x; scanf(&quot;%d&quot;, &amp;x); if (x) add(hh, tt, i, j); } } int depth = 0; while (!dfs(0, depth)) depth ++ ; printf(&quot;%d\\n&quot;, depth); for (int i = 0; i &lt; depth; i ++ ) printf(&quot;%d &quot;, ans[i]); return 0; } 2.20 左偏树 /* 维护一个小根堆，支持以下操作： 1. `1 a`，在集合中插入一个新堆，堆中只包含一个数 a。 2. `2 x y`，将第 x 个插入的数和第 y 个插入的数所在的小根堆合并。数据保证两个数均未被删除。若两数已在同一堆中，则忽略此操作。 3. `3 x`，输出第 x 个插入的数所在小根堆的最小值。数据保证该数未被删除。 4. `4 x`，删除第 x 个插入的数所在小根堆的最小值（若最小值不唯一，则优先删除先插入的数）。数据保证该数未被删除。 */ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 200010; int n; int v[N], dist[N], l[N], r[N], idx; int p[N]; bool cmp(int x, int y) { if (v[x] != v[y]) return v[x] &lt; v[y]; return x &lt; y; } int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int merge(int x, int y) { if (!x || !y) return x + y; if (cmp(y, x)) swap(x, y); r[x] = merge(r[x], y); if (dist[r[x]] &gt; dist[l[x]]) swap(l[x], r[x]); dist[x] = dist[r[x]] + 1; return x; } int main() { scanf(&quot;%d&quot;, &amp;n); v[0] = 2e9; while (n -- ) { int t, x, y; scanf(&quot;%d%d&quot;, &amp;t, &amp;x); if (t == 1) { v[ ++ idx] = x; dist[idx] = 1; p[idx] = idx; } else if (t == 2) { scanf(&quot;%d&quot;, &amp;y); x = find(x), y = find(y); if (x != y) { if (cmp(y, x)) swap(x, y); p[y] = x; merge(x, y); } } else if (t == 3) { printf(&quot;%d\\n&quot;, v[find(x)]); } else { x = find(x); if (cmp(r[x], l[x])) swap(l[x], r[x]); p[x] = l[x], p[l[x]] = l[x]; merge(l[x], r[x]); } } return 0; } 给定一个整数序列a，求一个递增序列b，使得aia_{i}ai​和bib_{i}bi​的各项之差的绝对值之和最小 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 1000010; int n; int v[N], dist[N], l[N], r[N]; struct Segment { int end, root, size; }stk[N]; int ans[N]; int merge(int x, int y) { if (!x || !y) return x + y; if (v[x] &lt; v[y]) swap(x, y); r[x] = merge(r[x], y); if (dist[r[x]] &gt; dist[l[x]]) swap(r[x], l[x]); dist[x] = dist[r[x]] + 1; return x; } int pop(int x) { return merge(l[x], r[x]); } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) { scanf(&quot;%d&quot;, &amp;v[i]); v[i] -= i; } int tt = 0; for (int i = 1; i &lt;= n; i ++ ) { auto cur = Segment({i, i, 1}); dist[i] = 1; while (tt &amp;&amp; v[cur.root] &lt; v[stk[tt].root]) { cur.root = merge(cur.root, stk[tt].root); if (cur.size % 2 &amp;&amp; stk[tt].size % 2) cur.root = pop(cur.root); cur.size += stk[tt].size; tt -- ; } stk[ ++ tt] = cur; } for (int i = 1, j = 1; i &lt;= tt; i ++ ) { while (j &lt;= stk[i].end) ans[j ++ ] = v[stk[i].root]; } LL res = 0; for (int i = 1; i &lt;= n; i ++ ) res += abs(v[i] - ans[i]); printf(&quot;%lld\\n&quot;, res); for (int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, ans[i] + i); return 0; } 2.21 后缀数组 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1000010; int n, m; char s[N]; int sa[N], x[N], y[N], c[N], rk[N], height[N]; void get_sa() { for (int i = 1; i &lt;= n; i ++ ) c[x[i] = s[i]] ++ ; for (int i = 2; i &lt;= m; i ++ ) c[i] += c[i - 1]; for (int i = n; i; i -- ) sa[c[x[i]] -- ] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) { int num = 0; for (int i = n - k + 1; i &lt;= n; i ++ ) y[ ++ num] = i; for (int i = 1; i &lt;= n; i ++ ) if (sa[i] &gt; k) y[ ++ num] = sa[i] - k; for (int i = 1; i &lt;= m; i ++ ) c[i] = 0; for (int i = 1; i &lt;= n; i ++ ) c[x[i]] ++ ; for (int i = 2; i &lt;= m; i ++ ) c[i] += c[i - 1]; for (int i = n; i; i -- ) sa[c[x[y[i]]] -- ] = y[i], y[i] = 0; swap(x, y); x[sa[1]] = 1, num = 1; for (int i = 2; i &lt;= n; i ++ ) x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++ num; if (num == n) break; m = num; } } void get_height() { for (int i = 1; i &lt;= n; i ++ ) rk[sa[i]] = i; for (int i = 1, k = 0; i &lt;= n; i ++ ) { if (rk[i] == 1) continue; if (k) k -- ; int j = sa[rk[i] - 1]; while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) k ++ ; height[rk[i]] = k; } } int main() { scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1), m = 122; get_sa(); get_height(); for (int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, sa[i]); puts(&quot;&quot;); for (int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, height[i]); puts(&quot;&quot;); return 0; } 2.22 后缀自动机 给定一个长度为n的小写字母字符串S，对于所有S的出现次数不为1的子串，设value的值为子串出现的次数×子串的长度，求value的最大值 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 2000010; int tot = 1, last = 1; struct Node { int len, fa; int ch[26]; }node[N]; char str[N]; LL f[N], ans; int h[N], e[N], ne[N], idx; void extend(int c) { int p = last, np = last = ++ tot; f[tot] = 1; node[np].len = node[p].len + 1; for (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np; if (!p) node[np].fa = 1; else { int q = node[p].ch[c]; if (node[q].len == node[p].len + 1) node[np].fa = q; else { int nq = ++ tot; node[nq] = node[q], node[nq].len = node[p].len + 1; node[q].fa = node[np].fa = nq; for (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq; } } } void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void dfs(int u) { for (int i = h[u]; ~i; i = ne[i]) { dfs(e[i]); f[u] += f[e[i]]; } if (f[u] &gt; 1) ans = max(ans, f[u] * node[u].len); } int main() { scanf(&quot;%s&quot;, str); for (int i = 0; str[i]; i ++ ) extend(str[i] - 'a'); memset(h, -1, sizeof h); for (int i = 2; i &lt;= tot; i ++ ) add(node[i].fa, i); dfs(1); printf(&quot;%lld\\n&quot;, ans); return 0; } 后缀自动机求最长公共子串 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 20010; int n; int tot = 1, last = 1; char str[N]; struct Node { int len, fa; int ch[26]; }node[N]; int ans[N], now[N]; int h[N], e[N], ne[N], idx; void extend(int c) { int p = last, np = last = ++ tot; node[np].len = node[p].len + 1; for (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np; if (!p) node[np].fa = 1; else { int q = node[p].ch[c]; if (node[q].len == node[p].len + 1) node[np].fa = q; else { int nq = ++ tot; node[nq] = node[q], node[nq].len = node[p].len + 1; node[q].fa = node[np].fa = nq; for (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq; } } } void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void dfs(int u) { for (int i = h[u]; ~i; i = ne[i]) { dfs(e[i]); now[u] = max(now[u], now[e[i]]); } } int main() { scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, str); for (int i = 0; str[i]; i ++ ) extend(str[i] - 'a'); for (int i = 1; i &lt;= tot; i ++ ) ans[i] = node[i].len; memset(h, -1, sizeof h); for (int i = 2; i &lt;= tot; i ++ ) add(node[i].fa, i); for (int i = 0; i &lt; n - 1; i ++ ) { scanf(&quot;%s&quot;, str); memset(now, 0, sizeof now); int p = 1, t = 0; for (int j = 0; str[j]; j ++ ) { int c = str[j] - 'a'; while (p &gt; 1 &amp;&amp; !node[p].ch[c]) p = node[p].fa, t = node[p].len; if (node[p].ch[c]) p = node[p].ch[c], t ++ ; now[p] = max(now[p], t); } dfs(1); for (int j = 1; j &lt;= tot; j ++ ) ans[j] = min(ans[j], now[j]); } int res = 0; for (int i = 1; i &lt;= tot; i ++ ) res = max(res, ans[i]); printf(&quot;%d\\n&quot;, res); return 0; } 2.23 点分树 //待补充 2.24 CDQ分治 //待补充 CDQ分治求动态逆序对 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 100010; int n, m; struct Data { int a, t, res; }q[N], w[N]; int tr[N], pos[N]; LL ans[N]; int lowbit(int x) { return x &amp; -x; } void add(int x, int v) { for (int i = x; i &lt; N; i += lowbit(i)) tr[i] += v; } int query(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; } void merge_sort(int l, int r) { if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(l, mid), merge_sort(mid + 1, r); int i = mid, j = r; while (i &gt;= l &amp;&amp; j &gt; mid) if (q[i].a &gt; q[j].a) add(q[i].t, 1), i -- ; else q[j].res += query(q[j].t - 1), j -- ; while (j &gt; mid) q[j].res += query(q[j].t - 1), j -- ; for (int k = i + 1; k &lt;= mid; k ++ ) add(q[k].t, -1); j = l, i = mid + 1; while (j &lt;= mid &amp;&amp; i &lt;= r) if (q[i].a &lt; q[j].a) add(q[i].t, 1), i ++ ; else q[j].res += query(q[j].t - 1), j ++ ; while (j &lt;= mid) q[j].res += query(q[j].t - 1), j ++ ; for (int k = mid + 1; k &lt; i; k ++ ) add(q[k].t, -1); i = l, j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i].a &lt;= q[j].a) w[k ++ ] = q[i ++ ]; else w[k ++ ] = q[j ++ ]; while (i &lt;= mid) w[k ++ ] = q[i ++ ]; while (j &lt;= r) w[k ++ ] = q[j ++ ]; for (i = l, j = 0; j &lt; k; i ++, j ++ ) q[i] = w[j]; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) { scanf(&quot;%d&quot;, &amp;q[i].a); pos[q[i].a] = i; } for (int i = 0, j = n; i &lt; m; i ++ ) { int a; scanf(&quot;%d&quot;, &amp;a); q[pos[a]].t = j -- ; pos[a] = -1; } for (int i = 1, j = n - m; i &lt;= n; i ++ ) if (pos[i] != -1) q[pos[i]].t = j -- ; merge_sort(0, n - 1); for (int i = 0; i &lt; n; i ++ ) ans[q[i].t] = q[i].res; for (int i = 2; i &lt;= n; i ++ ) ans[i] += ans[i - 1]; for (int i = 0, j = n; i &lt; m; i ++, j -- ) printf(&quot;%lld\\n&quot;, ans[j]); return 0; } 2.25 笛卡尔树 //求区间最值 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e6 + 10; int a[N]; int l[N], r[N]; int n; int ans[N], tot; void dfs(int u) { ans[u] = ++ tot; if(l[u]) dfs(l[u]); if(r[u]) dfs(r[u]); } void build() { stack&lt;int&gt; st; int root = 0; for(int i = 1; i &lt;= n; i ++) { int last = 0; while(!st.empty() &amp;&amp; a[st.top()] &gt; a[i]) { last = st.top(); st.pop(); } if(!st.empty()) r[st.top()] = i; else root = i; l[i] = last; st.push(i); } dfs(root); } int main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; build(); for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } 3. 数学 3.1 分解质因数 #include&lt;iostream&gt; using namespace std; void device(int a) { for(int i = 2; i &lt;= a / i; i ++) { if(a % i == 0) //如果该语句成立，那么i一定是质数 int s = 0; while(a % i == 0) { a /= i; s ++; } printf(&quot;%d %d\\n&quot;, i, s); } } if(a &gt; 1) cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt;endl; cout &lt;&lt; endl; } int main() { int n; cin &gt;&gt; n; while (n -- ) { int a; cin &gt;&gt; a; device(a); } return 0; } 3.2 筛质数 #include&lt;iostream&gt; using namespace std; const int N = 1e6 + 10; int prime[N],cnt; int st[N]; void getprime(int n) { for(int i = 2; i &lt;= n; i ++) { if(!st[i]) prime[cnt ++] = i; //如果i是一个质数，那么就把i加入到质数表里 for(int j = 0; prime[j] &lt;= n / i; j ++) //枚举质数表中小于n/i的质因子 { st[prime[j] * i] = true; //将所有最小质因子为prime[j]的合数筛掉 if(i % prime[j] == 0) break; //如果i%prime[j]成立，那么prime[j]是i的最小质因子，并且也是prime[j] * i的最小质因子 //如果不成立，那么prime[j]也是prime[j] * i的最小质因子 } } } int main() { int n; cin &gt;&gt; n; getprime(n); cout &lt;&lt; cnt ; return 0; } 3.3 试除法求约数 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; void ddd(int a) { vector&lt;int&gt; res; for(int i = 1; i &lt;= a / i; i ++) { if(a % i == 0) { res.push_back(i); if(i != a / i) res.push_back(a / i); } } sort(res.begin(), res.end()); for(auto t : res) cout &lt;&lt; t &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } int main() { int n; cin &gt;&gt; n; while(n --) { int a; cin &gt;&gt; a; ddd(a); } return 0; } 3.4 求n个数乘积的约数个数 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;unordered_map&gt; typedef long long LL; using namespace std; const int mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while(n --) { int x; cin &gt;&gt; x; for(int i = 2; i &lt;= x / i; i ++) { while(x % i == 0) { x /= i; primes[i] ++; } } if(x &gt; 1) primes[x] ++; } LL res = 1; for(auto prime : primes) res = res * (prime.second + 1) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0; } 3.5 求n个数乘积的约数之和 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;unordered_map&gt; typedef long long LL; using namespace std; const int mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while(n --) { int x; cin &gt;&gt; x; for(int i = 2; i &lt;= x / i; i ++) { while(x % i == 0) { x /= i; primes[i] ++; } } if(x &gt; 1) primes[x] ++; } LL res = 1; for(auto prime : primes) { int p = prime.first, a = prime.second; LL t = 1; while(a --) t = (t * p + 1) % mod; res = res * t % mod; } cout &lt;&lt; res &lt;&lt; endl; return 0; } 3.6 线性筛求欧拉函数 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 1e6 + 10; int primes[N], cnt; int phi[N]; bool st[N]; LL get_eulers(int n) { phi[1] = 1; for(int i = 2; i &lt;= n; i ++) { if(!st[i]) { primes[cnt ++] = i; phi[i] = i - 1; } for(int j = 0; primes[j] * i &lt;= n; j ++) { st[primes[j] * i] = true; if(i % primes[j] == 0) { phi[primes[j] * i] = primes[j] * phi[i]; break; } phi[primes[j] * i] = phi[i] * (primes[j] - 1); } } LL res = 0; for(int i = 1; i &lt;= n; i ++) res += phi[i]; return res; } int main() { int n; cin &gt;&gt; n; cout &lt;&lt; get_eulers(n) &lt;&lt; endl; return 0; } 3.7 快速幂 int qmi(int a, int b, int p) { int res = 1 % p; for(; b; b &gt;&gt;= 1) { if(b &amp; 1) res = (long long)res * a % p; a = (long long)a * a % p; } return res; } 3.8 扩展欧几里得算法(EXGCD) 给定 n 对正整数 aia_iai​,bib_ibi​，对于每对数，求出一组 xixixi , yiy_iyi​，使其满足 aia_iai​×xix_ixi​+bib_ibi​×yiy_iyi​=gcd(aia_iai​,bib_ibi​)。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int exgcd(int a, int b, int &amp;x, int &amp;y) { if(!b) { x = 1, y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } int main() { int n; cin &gt;&gt; n; while(n --) { int a, b, x, y; cin &gt;&gt; a &gt;&gt; b; exgcd(a, b, x, y); cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; } return 0; } 求解线性同余方程组 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; typedef long long LL; using namespace std; int exgcd(int a, int b, int &amp;x, int &amp;y) { if(!b) { x = 1, y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; } int main() { int n; cin &gt;&gt; n; while(n --) { int a, b, m; cin &gt;&gt; a &gt;&gt; b &gt;&gt; m; int x, y; int d = exgcd(a, m, x ,y); if(b % d) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; else cout &lt;&lt; (LL)x * (b / d) % m &lt;&lt; endl; } return 0; } 3.9 高斯消元求解线性方程组 #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 110; const double eps = 1e-6; int n; double a[N][N]; int gauss() { int c, r; for(c = 0, r = 0; c &lt; n; c ++) { int t = r; for(int i = r; i &lt; n; i ++) if(fabs(a[i][c] &gt; fabs(a[t][c]))) t = i; if(fabs(a[t][c]) &lt; eps) continue; for(int i = c; i &lt;= n; i ++) swap(a[t][i], a[r][i]); for(int i = n; i &gt;= c; i --) a[r][i] /= a[r][c]; for(int i = r + 1; i &lt; n; i ++) if(fabs(a[i][c]) &gt; eps) for(int j = n; j &gt;= c; j --) a[i][j] -= a[r][j] * a[i][c]; r ++; } if(r &lt; n) { for(int i = r; i &lt; n; i ++) if(fabs(a[i][n]) &gt; eps) return 2; return 1; } for(int i = n - 1; i &gt;= 0; i --) for(int j = i + 1; j &lt; n; j ++) a[i][n] -= a[i][j] * a[j][n]; return 0; } int main() { cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) for(int j = 0; j &lt; n + 1; j ++) cin &gt;&gt; a[i][j]; int t = gauss(); if(t == 0) { for(int i = 0; i &lt; n; i ++) { if (fabs(a[i][n]) &lt; eps) a[i][n] = 0; printf(&quot;%.2lf\\n&quot;, a[i][n]); } } else if(t == 1) cout &lt;&lt; &quot;Infinite group solutions&quot; &lt;&lt; endl; else puts(&quot;No solution&quot;); return 0; } 3.10 组合数大全 3.10.1 求C(a, b)，其中1 ≤ b ≤ a ≤ 2000 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 2010, mod = 1e9 + 7; int c[N][N]; void init() { for(int i = 0; i &lt; N; i ++) for(int j = 0; j &lt;= i; j ++) if(!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; } int main() { init(); int n; cin &gt;&gt; n; while(n --) { int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; c[a][b] &lt;&lt; endl; } return 0; } 3.10.2 求C(a, b)，其中1 ≤ b ≤ a ≤ 100000 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 100010, mod = 1e9 + 7; int fact[N], infact[N]; int qmi(int a, int k, int p) { int res = 1; for(; k; k &gt;&gt;= 1) { if(k &amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; } return res; } int main() { fact[0] = infact[0] = 1; for(int i = 1; i &lt; N; i ++) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; } int n; cin &gt;&gt; n; while(n --) { int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (LL)fact[a] * infact[b] % mod * infact[a - b] % mod &lt;&lt; endl; } } 3.10.3 求C(a, b) mod p，其中 1≤b≤a≤10181 ≤ b ≤ a ≤ 10^{18}1≤b≤a≤1018，且p为质数 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long LL; int p; int qmi(int a, int k) { int res = 1; for(; k; k &gt;&gt;= 1) { if(k &amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; } return res; } int C(LL a, LL b) { int res = 1; for(int i = 1, j = a; i &lt;= b; i ++, j --) { res = (LL)res * j % p; res = (LL)res * qmi(i ,p - 2) % p; } return res; } LL lucas(LL a, LL b) { if(a &lt; p &amp; b &lt; p) return C(a, b); return C(a % p, b % p) * lucas(a / p, b / p) % p; } int main() { int n; cin &gt;&gt; n; while(n --) { LL a, b; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; cout &lt;&lt; lucas(a, b) &lt;&lt; endl; } return 0; } 3.10.4 求C(a, b)，其中1 ≤ b ≤ a ≤ 5000 (高精度不取模) #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; const int N = 5010; int primes[N], cnt; bool st[N]; int sum[N]; void init(int n) { for(int i = 2; i &lt;= n; i ++) { if(!st[i]) primes[cnt ++] = i; for(int j = 0; primes[j] * i &lt;= n; j ++) { st[primes[j] * i] = true; if(i % primes[j] == 0) break; } } } int get(int n, int p) //*n的阶乘里包含的p的个数 { int res = 0; while(n) { res += n / p; n /= p; } return res; } vector&lt;int&gt; mul(vector&lt;int&gt; a, int b) { vector&lt;int&gt; c; int t = 0; for(int i = 0; i &lt; a.size(); i ++) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while(t) { c.push_back(t % 10); t /= 10; } return c; } int main() { int a, b; cin &gt;&gt; a &gt;&gt; b; init(a); for(int i = 0; i &lt; cnt; i ++) { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector&lt;int&gt; res; res.push_back(1); for(int i = 0; i &lt; cnt; i ++) for(int j = 0; j &lt; sum[i]; j ++) res = mul(res, primes[i]); for(int i = res.size() - 1; i &gt;= 0; i --) cout &lt;&lt; res[i] ; cout &lt;&lt; endl; return 0; } 3.10.5 卡特兰数 给定01序列，求任意前缀序列中0的个数不少于1的个数的序列有多少个 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; typedef long long LL; using namespace std; const int mod = 1e9 + 7; int qmi(int a, int k, int p) { int res = 1; for(; k; k &gt;&gt;= 1) { if(k &amp; 1) res = (LL)res * a % p; a= (LL)a * a % p; } return res; } int main() { int n; cin &gt;&gt; n; int a = 2 * n, b = n; int res = 1; for(int i = a; i &gt; a - b; i --) res = (LL)res * i % mod; for(int i = 1; i &lt;= b; i ++) res = (LL)res * qmi(i, mod - 2, mod) % mod; res = (LL)res * qmi(n + 1, mod - 2, mod) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0; } 3.11 容斥原理 给定n和m个不同的质数p，求1-n中能被p中至少一个数整除的整数有多少个 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 20; typedef long long LL; int n, m; int p[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i ++) cin &gt;&gt; p[i]; int res = 0; for(int i = 1; i &lt; 1 &lt;&lt; m; i ++) { int t = 1, cnt = 0; for(int j = 0; j &lt; m; j ++) if(i &gt;&gt; j &amp; 1) { cnt ++; if((LL)t * p[j] &gt; n) { t = -1; break; } t *= p[j]; } if(t != -1) { if(cnt % 2) res += n / t; else res -= n / t; } } cout &lt;&lt; res &lt;&lt; endl; return 0; } n个盒子放aia_iai​枝花，同一个盒子内的花的颜色相同，不同盒子内的画的颜色不同，选出M枝花共有多少种方案 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 20, mod = 1e9 + 7; int A[N]; int down = 1; int qmi(int a, int b, int k) { int res = 1; for(; b; b &gt;&gt;= 1) { if(b &amp; 1) res = (long long)res * a % k; a = (long long)a * a % k; } return res; } int C(int a, int b) { if(a &lt; b) return 0; int up = 1; for(int i = a; i &gt; a - b; i --) up = i % mod * up % mod; return (up * down) % mod; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, m; int res = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++) cin &gt;&gt; A[i]; for(int j = 1; j &lt;= n - 1; j ++) down = j * down % mod; down = qmi(down, mod - 2, mod); for(int i = 0; i &lt; 1 &lt;&lt; n; i ++) { int a = m + n - 1, b = n - 1; int p = 1; for(int j = 0; j &lt; n; j ++) if(i &gt;&gt; j &amp; 1) { p *= -1; a -= A[j] + 1; } res = (res + C(a, b) * p) % mod; } cout &lt;&lt; (res + mod) % mod &lt;&lt; endl; return 0; } 3.12 博弈论 3.12.1 NIM博弈 给定 n 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。 问如果两人都采用最优策略，先手是否必胜。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n; int res = 0; cin &gt;&gt; n; while(n --) { int x; cin &gt;&gt; x; res ^= x; } if(res) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; } 3.12.2 台阶-NIM游戏 有一个 n 级台阶的楼梯，每级台阶上都有若干个石子，其中第 i 级台阶上有 ai 个石子(i≥1)。 两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。 已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。 问如果两人都采用最优策略，先手是否必胜。 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int main() { int n; scanf(&quot;%d&quot;, &amp;n); int res = 0; for (int i = 1; i &lt;= n; i ++ ) { int x; scanf(&quot;%d&quot;, &amp;x); if (i &amp; 1) res ^= x; } if (res) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0; } 3.12.3 集合-NIM游戏 给定 n 堆石子以及一个由 k 个不同正整数构成的数字集合 S。 现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合 S，最后无法进行操作的人视为失败。 问如果两人都采用最优策略，先手是否必胜。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;unordered_set&gt; using namespace std; const int N = 110, M = 10010; int n, m; int s[N], f[M]; int sg(int x) { if(f[x] != -1) return f[x]; unordered_set&lt;int&gt; S; for(int i = 0; i &lt; m; i ++) { int sum = s[i]; if(x &gt;= sum) S.insert(sg(x - sum)); } for(int i = 0; ; i ++) { if(!S.count(i)) return f[x] = i; } } int main() { cin &gt;&gt; m; for(int i = 0; i &lt; m; i ++) cin &gt;&gt; s[i]; cin &gt;&gt; n; memset(f, -1, sizeof f); int res = 0; for(int i = 0; i &lt; n; i ++) { int x; cin &gt;&gt; x; res ^= sg(x); } if(res) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0; } 3.12.4 拆分-NIM游戏 给定 n 堆石子，两位玩家轮流操作，每次操作可以取走其中的一堆石子，然后放入两堆规模更小的石子（新堆规模可以为 0，且两个新堆的石子总数可以大于取走的那堆石子数），最后无法进行操作的人视为失败。 问如果两人都采用最优策略，先手是否必胜。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;unordered_set&gt; using namespace std; const int N = 110; int n; int f[N]; int sg(int x) { if (f[x] != -1) return f[x]; unordered_set&lt;int&gt; S; for (int i = 0; i &lt; x; i ++ ) for (int j = 0; j &lt;= i; j ++ ) S.insert(sg(i) ^ sg(j)); for (int i = 0;; i ++ ) if (!S.count(i)) return f[x] = i; } int main() { cin &gt;&gt; n; memset(f, -1, sizeof f); int res = 0; while (n -- ) { int x; cin &gt;&gt; x; res ^= sg(x); } if (res) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0; } 3.13 矩阵乘法 求斐波那契数列的前n项和 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 3; typedef long long LL; int n, m; void mul(int c[], int a[], int b[][N]) { int temp[N] = {0}; for(int i = 0; i &lt; N; i ++) for(int j = 0; j &lt; N; j ++) temp[i] = (temp[i] + (LL)a[j] * b[j][i]) % m; memcpy(c, temp, sizeof temp); } void mul(int c[][N], int a[][N], int b[][N]) { int temp[N][N] = {0}; for(int i = 0; i &lt; N; i ++) for(int j = 0; j &lt; N; j ++) for(int k = 0; k &lt; N; k ++) temp[i][j] = (temp[i][j] + (LL)a[i][k] * b[k][j]) % m; memcpy(c, temp, sizeof temp); } int main() { cin &gt;&gt; n &gt;&gt; m; int f1[N] = {1, 1, 1}; int a[N][N] = { {0, 1, 0}, {1, 1, 1}, {0, 0, 1} }; n --; for(; n; n &gt;&gt;= 1) { if(n &amp; 1) mul(f1, f1, a); mul(a, a, a); } cout &lt;&lt; f1[2] &lt;&lt; endl; return 0; } 用 T(n)=(F1+2F2+3F3+…+nFn)modm 表示 Fibonacci 数列前 n 项变形后的和 mod m 的值，求出 T(n) 的值。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 4; int n, m; void mul(int c[][N], int a[][N], int b[][N]) //*c = a * b { static int t[N][N]; memset(t, 0, sizeof t); for(int i = 0; i &lt; N; i ++) for(int j = 0; j &lt; N; j ++) for(int k = 0; k &lt; N; k ++) t[i][j] = (t[i][j] + (LL)a[i][k] * b[k][j]) % m; memcpy(c, t, sizeof t); } int main() { cin &gt;&gt; n &gt;&gt; m; int f1[N][N] = {1, 1, 1, 0}; int a[N][N] = { {0, 1, 0, 0}, {1, 1, 1, 0}, {0, 0, 1, 1}, {0, 0, 0, 1}, }; int k = n - 1; for(; k; k &gt;&gt;= 1) { if(k &amp; 1) mul(f1, f1, a); mul(a, a, a); } cout &lt;&lt; (((LL)n * f1[0][2] - f1[0][3]) % m + m) % m &lt;&lt; endl; return 0; } 3.14 莫比乌斯函数与莫比乌斯反演与积性函数 //待补充 4. 动态规划 数字三角形模型 4.1 一条路径点权和最大(摘花生) #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110; int n, m; int w[N][N]; int f[N][N]; int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T -- ) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) scanf(&quot;%d&quot;, &amp;w[i][j]); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j]; printf(&quot;%d\\n&quot;, f[n][m]); } return 0; } 4.2 一条路径点权和最小 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110, INF = 1e9; int n; int w[N][N]; int f[N][N]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) scanf(&quot;%d&quot;, &amp;w[i][j]); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (i == 1 &amp;&amp; j == 1) f[i][j] = w[i][j]; // 特判左上角 else { f[i][j] = INF; if (i &gt; 1) f[i][j] = min(f[i][j], f[i - 1][j] + w[i][j]);// 只有不在第一行的时候，才可以从上面过来 if (j &gt; 1) f[i][j] = min(f[i][j], f[i][j - 1] + w[i][j]);// 只有不在第一列的时候，才可以从左边过来 } printf(&quot;%d\\n&quot;, f[n][n]); return 0; } 4.3 两条路径点权和最大 该类问题满足：左上走到右下走两次，格点数被取过第二次就不会再取(坐标和相加相等即被走了两次) // 两条路径都是：左上到右下 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 15; int n; int w[N][N]; int f[N * 2][N][N]; int main() { scanf(&quot;%d&quot;, &amp;n); int a, b, c; while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c) w[a][b] = c; for (int k = 2; k &lt;= n + n; k ++ ) for (int i1 = 1; i1 &lt;= n; i1 ++ ) for (int i2 = 1; i2 &lt;= n; i2 ++ ) { int j1 = k - i1, j2 = k - i2; if (j1 &gt;= 1 &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= 1 &amp;&amp; j2 &lt;= n) { int t = w[i1][j1]; if (i1 != i2) t += w[i2][j2]; int &amp;x = f[k][i1][i2]; x = max(x, f[k - 1][i1 - 1][i2 - 1] + t); x = max(x, f[k - 1][i1 - 1][i2] + t); x = max(x, f[k - 1][i1][i2 - 1] + t); x = max(x, f[k - 1][i1][i2] + t); } } printf(&quot;%d\\n&quot;, f[n + n][n][n]); return 0; } // 先左上到右下，再右下到左上 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10; int n, m; int g[55][55], f[110][55][55]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= n;i ++) for(int j = 1;j &lt;= m;j ++) cin &gt;&gt; g[i][j]; for(int k = 2; k &lt;= n + m;k ++) { for(int i1 = max(1, k - m);i1 &lt;= min(k - 1, n);i1 ++) { for(int i2 = max(1, k - m);i2 &lt;= min(k - 1, n);i2 ++) { int j1 = k - i1, j2 = k - i2; int t = g[i1][j1]; if(i1 != i2) t += g[i2][j2]; int &amp;x = f[k][i1][i2]; x = max(x, f[k - 1][i1 - 1][i2 - 1] + t); x = max(x, f[k - 1][i1 - 1][i2] + t); x = max(x, f[k - 1][i1][i2 - 1] + t); x = max(x, f[k - 1][i1][i2] + t); } } } cout &lt;&lt; f[n + m][n][n] &lt;&lt; endl; return 0; } 最长上升子序列模型（LIS） 4.4 基本转换模型 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const int N = 1e5 + 10; int n, q[N], a[N]; int ask(int s,int t) { q[0] = -2e9; int len = 0; for(int i = s;i &lt; t;i ++) { int l = 0, r = len; while(l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if(q[mid] &lt; a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); q[r + 1] = a[i]; } return len; } int main() { int n; cin &gt;&gt; n; for(int i = 0;i &lt; n;i ++) cin &gt;&gt; a[i]; cout &lt;&lt; ask(0, n) &lt;&lt; endl; // 左闭右开 return 0; } 4.5上下模型 先上升再下降，一旦下降就不再上升，中间高两边矮的最长子序列 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e3 + 10; int f[N][2], n, a[N]; int main () { cin &gt;&gt; n; for(int i = 0;i &lt; n;i ++ ) cin &gt;&gt; a[i]; for(int i = 0;i &lt; n;i ++) { f[i][1] = f[i][0] = 1; for(int k = 0;k &lt; i;k ++) { if(a[i] &gt; a[k]) f[i][0] = max(f[i][0], f[k][0] + 1); if(a[i] &lt; a[k]) f[i][1] = max(f[i][1], max(f[k][0], f[k][1]) + 1); } } int res = 0; for(int i = 0;i &lt; n;i ++) res = max(res, max(f[i][1], f[i][0])); cout &lt;&lt; res &lt;&lt; endl; return 0; } 4.6 最大上升子序列和 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1010; int a[N], n, f[N]; int main () { cin &gt;&gt; n; for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i]; for(int i = 1;i &lt;= n;i ++) { f[i] = a[i]; for(int k = 1;k &lt; i;k ++) { if(a[k] &lt; a[i]) f[i] = max(f[i], f[k] + a[i]); } } int res = 0; for(int i = 1;i &lt;= n;i ++) res = max(res, f[i]); cout &lt;&lt; res &lt;&lt; endl; return 0; } 4.7 Dilworth定理（最少下降子序列数等于最长上升子序列长度） 最长公共子序列 4.8 最长公共上升子序列（LICS和LCS） #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 3010; int n, f[N][N], a[N], b[N]; int main () { cin &gt;&gt; n; for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i]; for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; b[i]; for(int i = 1;i &lt;= n;i ++) { int res = 0; if(b[1] &lt; a[i]) res = f[i - 1][1]; for(int j = 1;j &lt;= n;j ++) { if(a[i] == b[j]) f[i][j] = res + 1; else f[i][j] = f[i - 1][j]; if(b[j] &lt; a[i]) res = max(res, f[i - 1][j]); } } int ans = 0; for(int i = 1;i &lt;= n;i ++) ans = max(ans, f[n][i]); cout &lt;&lt; ans &lt;&lt; endl; return 0; } 4.9 最长公共子序列 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); scanf(&quot;%s%s&quot;, a + 1, b + 1); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } printf(&quot;%d\\n&quot;, f[n][m]); return 0; } 4.10 最短编辑距离 A到B最少操作次数 操作： 删除–将字符串 A 中的某个字符删除。 插入–在字符串 A 的某个位置插入某个字符。 替换–将字符串 A 中的某个字符替换为另一个字符。 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n,m; char a[1010],b[1010]; int f[1010][1010]; int main() { scanf(&quot;%d%s&quot;,&amp;n, a + 1); scanf(&quot;%d%s&quot;,&amp;m, b + 1); for(int i = 0;i &lt;= m;i ++) f[0][i] = i; for(int i = 0;i &lt;= n;i ++) f[i][0] = i; for(int i = 1;i &lt;= n;i ++) { for(int j = 1;j &lt;= m;j ++) { f[i][j] = min(f[i][j - 1], f[i - 1][j]) + 1; if(a[i] != b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); else f[i][j] = min(f[i][j], f[i - 1][j - 1]); } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; } 背包 4.11 01背包问题 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int M = 20010; int n, m; int f[M]; int main() { cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) { int v; cin &gt;&gt; v; for (int j = m; j &gt;= v; j -- ) f[j] = max(f[j], f[j - v] + v); } cout &lt;&lt; m - f[m] &lt;&lt; endl; return 0; } 01背包求方案数 //数字组合方案，非最优最大价值方案数 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 10010; int n, m; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; f[0] = 1; for (int i = 0; i &lt; n; i ++ ) { int v; cin &gt;&gt; v; for (int j = m; j &gt;= v; j -- ) f[j] += f[j - v]; } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 4.12 完全背包问题 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i ++ ) for (int j = v[i]; j &lt;= m; j ++ ) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 完全背包求方案数 //数字组合方案，非最优最大价值方案数 #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; typedef long long LL; const LL mod=2147483648LL;//默认数字为int类型，因此数字后要加LL int n; long long f[4005]; int main() { scanf(&quot;%d&quot;,&amp;n); f[0]=1; for(int i = 1;i &lt; n;i ++) for(int j = i;j &lt;= n;j ++) f[j] = (f[j] + f[j - i]) % mod; printf(&quot;%d&quot;,f[n]); } 4.13 多重背包问题 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 1e5+10; int n, m; struct node { int v, w; }; vector&lt;node&gt; nodes; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= n;i ++) { int v, w ,s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for(int k = 1;k &lt;= s;k &lt;&lt;= 1) nodes.push_back({v*k, w*k}), s -= k; if(s) nodes.push_back({v*s, w*s}); } for(auto t : nodes) { for(int j = m;j &gt;= t.v;j -- ) { f[j] = max(f[j], f[j - t.v] + t.w); } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 单调队列优化 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n, m; int f[N], g[N], q[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) { int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; memcpy(g, f, sizeof f); for (int j = 0; j &lt; v; j ++ ) { int hh = 0, tt = -1; for (int k = j; k &lt;= m; k += v) { if (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh ++ ; while (hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt -- ; q[ ++ tt] = k; f[k] = g[q[hh]] + (k - q[hh]) / v * w; } } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 4.14 混合背包问题 #include &lt;iostream&gt; using namespace std; const int N = 1010; int n, m; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) { int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; if (!s) { for (int j = v; j &lt;= m; j ++ ) f[j] = max(f[j], f[j - v] + w); } else { if (s == -1) s = 1; for (int k = 1; k &lt;= s; k *= 2) { for (int j = m; j &gt;= k * v; j -- ) f[j] = max(f[j], f[j - k * v] + k * w); s -= k; } if (s) { for (int j = m; j &gt;= s * v; j -- ) f[j] = max(f[j], f[j - s * v] + s * w); } } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 4.15 二维费用的背包问题 #include &lt;iostream&gt; using namespace std; const int N = 110; int n, V, M; int f[N][N]; int main() { cin &gt;&gt; n &gt;&gt; V &gt;&gt; M; for (int i = 0; i &lt; n; i ++ ) { int v, m, w; cin &gt;&gt; v &gt;&gt; m &gt;&gt; w; for (int j = V; j &gt;= v; j -- ) for (int k = M; k &gt;= m; k -- ) f[j][k] = max(f[j][k], f[j - v][k - m] + w); } cout &lt;&lt; f[V][M] &lt;&lt; endl; return 0; } 4.16 分组背包问题 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110; int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) { cin &gt;&gt; s[i]; for (int j = 0; j &lt; s[i]; j ++ ) cin &gt;&gt; v[i][j] &gt;&gt; w[i][j]; } for (int i = 1; i &lt;= n; i ++ ) for (int j = m; j &gt;= 0; j -- ) for (int k = 0; k &lt; s[i]; k ++ ) if (v[i][k] &lt;= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 4.17 有依赖的背包问题 物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110; int n, m; int v[N], w[N]; int h[N], e[N], ne[N], idx; int f[N][N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void dfs(int u) { for (int i = h[u]; ~i; i = ne[i]) // 循环物品组 { int son = e[i]; dfs(e[i]); // 分组背包 for (int j = m - v[u]; j &gt;= 0; j -- ) // 循环体积 for (int k = 0; k &lt;= j; k ++ ) // 循环决策 f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]); } // 将物品u加进去 for (int i = m; i &gt;= v[u]; i -- ) f[u][i] = f[u][i - v[u]] + w[u]; for (int i = 0; i &lt; v[u]; i ++ ) f[u][i] = 0; } int main() { cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); int root; for (int i = 1; i &lt;= n; i ++ ) { int p; cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p; if (p == -1) root = i; else add(p, i); } dfs(root); cout &lt;&lt; f[root][m] &lt;&lt; endl; return 0; } /* 5 7 2 3 -1 2 2 1 3 5 1 4 7 2 3 6 2 11 */ 4.18 最优最大价值方案数 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; const int N = 1010, mod = 1e9 + 7; int n, m; int f[N], g[N]; int main() { cin &gt;&gt; n &gt;&gt; m; memset(f, -0x3f, sizeof f); f[0] = 0; g[0] = 1; for (int i = 0; i &lt; n; i ++ ) { int v, w; cin &gt;&gt; v &gt;&gt; w; for (int j = m; j &gt;= v; j -- ) { int maxv = max(f[j], f[j - v] + w); int s = 0; if (f[j] == maxv) s = g[j]; if (f[j - v] + w == maxv) s = (s + g[j - v]) % mod; f[j] = maxv, g[j] = s; } } int res = 0; for (int i = 1; i &lt;= m; i ++ ) if (f[i] &gt; f[res]) res = i; int sum = 0; for (int i = 0; i &lt;= m; i ++ ) if (f[i] == f[res]) sum = (sum + g[i]) % mod; cout &lt;&lt; sum &lt;&lt; endl; return 0; } 4.19 背包问题求具体方案 #include &lt;iostream&gt; using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N][N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = n; i &gt;= 1; i -- ) for (int j = 0; j &lt;= m; j ++ ) { f[i][j] = f[i + 1][j]; if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]); } int j = m; for (int i = 1; i &lt;= n; i ++ ) if (j &gt;= v[i] &amp;&amp; f[i][j] == f[i + 1][j - v[i]] + w[i]) { cout &lt;&lt; i &lt;&lt; ' '; j -= v[i]; } return 0; } 状态机模型 大盗阿福 阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？ #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n; int w[N], f[N][2]; int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T -- ) { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); for (int i = 1; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][1]); f[i][1] = f[i - 1][0] + w[i]; } printf(&quot;%d\\n&quot;, max(f[n][0], f[n][1])); } return 0; } /* 2 3 1 8 2 4 10 7 6 14 8 24 */ 股票买卖 IV 给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i天的价格。设计一个算法来计算你所能获取的最大利润，你最多可以完成 k笔交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。一次买入卖出合为一笔交易。 // 输出一个整数，表示最大利润。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010, M = 110, INF = 0x3f3f3f3f; int n, m; int w[N]; int f[N][M][2]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); memset(f, -0x3f, sizeof f); for (int i = 0; i &lt;= n; i ++ ) f[i][0][0] = 0; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + w[i]); f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - w[i]); } int res = 0; for (int i = 0; i &lt;= m; i ++ ) res = max(res, f[n][i][0]); printf(&quot;%d\\n&quot;, res); return 0; } 股票买卖 V 给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 // 算出最大利润 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010, INF = 0x3f3f3f3f; int n; int w[N]; int f[N][3]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); f[0][0] = f[0][1] = -INF, f[0][2] = 0; for (int i = 1; i &lt;= n; i ++ ) { f[i][0] = max(f[i - 1][0], f[i - 1][2] - w[i]); f[i][1] = f[i - 1][0] + w[i]; f[i][2] = max(f[i - 1][2], f[i - 1][1]); } printf(&quot;%d\\n&quot;, max(f[n][1], f[n][2])); return 0; } 设计密码 你现在需要设计一个密码 S，S需要满足： S 的长度是 N； S 只包含小写英文字母； S 不包含子串 T； 例如：abc 和 abcde 是 abcde 的子串，abd 不是 abcde的子串。 请问共有多少种不同的密码满足要求？ 由于答案会非常大，请输出答案模 109+7的余数。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 55, mod = 1e9 + 7; int n, m; char str[N]; int nxt[N]; int f[N][N]; int main() { cin &gt;&gt; n &gt;&gt; str + 1; m = strlen(str + 1); for (int i = 2, j = 0; i &lt;= m; i ++ ) { while (j &amp;&amp; str[i] != str[j + 1]) j = nxt[j]; if (str[i] == str[j + 1]) j ++ ; nxt[i] = j; } f[0][0] = 1; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) for (char k = 'a'; k &lt;= 'z'; k ++ ) { int u = j; while (u &amp;&amp; k != str[u + 1]) u = nxt[u]; if (k == str[u + 1]) u ++ ; if (u &lt; m) f[i + 1][u] = (f[i + 1][u] + f[i][j]) % mod; } int res = 0; for (int i = 0; i &lt; m; i ++ ) res = (res + f[n][i]) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0; } 修复DNA 生物学家终于发明了修复DNA的技术，能够将包含各种遗传疾病的DNA片段进行修复。为了简单起见，DNA看作是一个由’A’, ‘G’ , ‘C’ , ‘T’构成的字符串。修复技术就是通过改变字符串中的一些字符，从而消除字符串中包含的致病片段。需注意，被修复的DNA片段中，仍然只能包含字符’A’, ‘G’ , ‘C’ , ‘T’。 请你帮助生物学家修复给定的DNA片段，并且修复过程中改变的字符数量要尽可能的少。 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1010; int n, m; int tr[N][4], dar[N], idx; int q[N], ne[N]; char str[N]; int f[N][N]; int get(char c) { if (c == 'A') return 0; if (c == 'T') return 1; if (c == 'G') return 2; return 3; } void insert() { int p = 0; for (int i = 0; str[i]; i ++ ) { int t = get(str[i]); if (tr[p][t] == 0) tr[p][t] = ++ idx; p = tr[p][t]; } dar[p] = 1; } void build() { int hh = 0, tt = -1; for (int i = 0; i &lt; 4; i ++ ) if (tr[0][i]) q[ ++ tt] = tr[0][i]; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = 0; i &lt; 4; i ++ ) { int p = tr[t][i]; if (!p) tr[t][i] = tr[ne[t]][i]; else { ne[p] = tr[ne[t]][i]; q[ ++ tt] = p; dar[p] |= dar[ne[p]]; } } } } int main() { int T = 1; while (scanf(&quot;%d&quot;, &amp;n), n) { memset(tr, 0, sizeof tr); memset(dar, 0, sizeof dar); memset(ne, 0, sizeof ne); idx = 0; for (int i = 0; i &lt; n; i ++ ) { scanf(&quot;%s&quot;, str); insert(); } build(); scanf(&quot;%s&quot;, str + 1); m = strlen(str + 1); memset(f, 0x3f, sizeof f); f[0][0] = 0; for (int i = 0; i &lt; m; i ++ ) for (int j = 0; j &lt;= idx; j ++ ) for (int k = 0; k &lt; 4; k ++ ) { int t = get(str[i + 1]) != k; int p = tr[j][k]; if (!dar[p]) f[i + 1][p] = min(f[i + 1][p], f[i][j] + t); } int res = 0x3f3f3f3f; for (int i = 0; i &lt;= idx; i ++ ) res = min(res, f[m][i]); if (res == 0x3f3f3f3f) res = -1; printf(&quot;Case %d: %d\\n&quot;, T ++, res); } return 0; } /* 2 AAA AAG AAAG 2 A TG TGAATG 4 A G C T AGT 0 Case 1: 1 Case 2: 4 Case 3: -1 */ 状态压缩DP 小国王 // 在 n×n 的棋盘上放 k 个国王，国王可攻击相邻的 8 个格子，求使它们无法互相攻击的方案总数。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long LL; const int N = 12, M = 1 &lt;&lt; 10, K = 110; int n, m; vector&lt;int&gt; state; int cnt[M]; vector&lt;int&gt; head[M]; LL f[N][K][M]; bool check(int state) { for (int i = 0; i &lt; n; i ++ ) if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; i + 1 &amp; 1)) return false; return true; } int count(int state) { int res = 0; for (int i = 0; i &lt; n; i ++ ) res += state &gt;&gt; i &amp; 1; return res; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ) if (check(i)) { state.push_back(i); cnt[i] = count(i); } for (int i = 0; i &lt; state.size(); i ++ ) for (int j = 0; j &lt; state.size(); j ++ ) { int a = state[i], b = state[j]; if ((a &amp; b) == 0 &amp;&amp; check(a | b)) head[i].push_back(j); } f[0][0][0] = 1; for (int i = 1; i &lt;= n + 1; i ++ ) for (int j = 0; j &lt;= m; j ++ ) for (int a = 0; a &lt; state.size(); a ++ ) for (int b : head[a]) { int c = cnt[state[a]]; if (j &gt;= c) f[i][j][a] += f[i - 1][j - c][b]; } cout &lt;&lt; f[n + 1][m][0] &lt;&lt; endl; return 0; } /* 3 2 16 */ 玉米田 农夫约翰的土地由 M×N 个小方格组成，现在他要在土地里种植玉米。非常遗憾，部分土地是不育的，无法种植。 而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。 现在给定土地的大小，请你求出共有多少种种植方法。土地上什么都不种也算一种方法。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 14, M = 1 &lt;&lt; 12, mod = 1e8; int n, m; int w[N]; vector&lt;int&gt; state; vector&lt;int&gt; head[M]; int f[N][M]; bool check(int state) { for (int i = 0; i + 1 &lt; m; i ++ ) if ((state &gt;&gt; i &amp; 1) &amp;&amp; (state &gt;&gt; i + 1 &amp; 1)) return false; return true; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) for (int j = 0; j &lt; m; j ++ ) { int t; cin &gt;&gt; t; w[i] += !t * (1 &lt;&lt; j); } for (int i = 0; i &lt; 1 &lt;&lt; m; i ++ ) if (check(i)) state.push_back(i); for (int i = 0; i &lt; state.size(); i ++ ) for (int j = 0; j &lt; state.size(); j ++ ) { int a = state[i], b = state[j]; if (!(a &amp; b)) head[i].push_back(j); } f[0][0] = 1; for (int i = 1; i &lt;= n + 1; i ++ ) for (int j = 0; j &lt; state.size(); j ++ ) if (!(state[j] &amp; w[i])) for (int k : head[j]) f[i][j] = (f[i][j] + f[i - 1][k]) % mod; cout &lt;&lt; f[n + 1][0] &lt;&lt; endl; return 0; } /* 2 3 1 1 1 0 1 0 9 */ 区间DP 环形石子合并 求： 选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。 选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 410, INF = 0x3f3f3f3f; int n; int w[N], s[N]; int f[N][N], g[N][N]; int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) { cin &gt;&gt; w[i]; w[i + n] = w[i]; } for (int i = 1; i &lt;= n * 2; i ++ ) s[i] = s[i - 1] + w[i]; memset(f, 0x3f, sizeof f); memset(g, -0x3f, sizeof g); for (int len = 1; len &lt;= n; len ++ ) for (int l = 1; l + len - 1 &lt;= n * 2; l ++ ) { int r = l + len - 1; if (l == r) f[l][r] = g[l][r] = 0; else { for (int k = l; k &lt; r; k ++ ) { f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); g[l][r] = max(g[l][r], g[l][k] + g[k + 1][r] + s[r] - s[l - 1]); } } } int minv = INF, maxv = -INF; for (int i = 1; i &lt;= n; i ++ ) { minv = min(minv, f[i][i + n - 1]); maxv = max(maxv, g[i][i + n - 1]); } cout &lt;&lt; minv &lt;&lt; endl &lt;&lt; maxv &lt;&lt; endl; return 0; } 加分二叉树 设一个 n 个节点的二叉树 tree 的中序遍历为（1,2,3,…,n），其中数字 1,2,3,…,n 为节点编号。 每个节点都有一个分数（均为正整数），记第 i 个节点的分数为 di，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下： subtree的左子树的加分 × subtree的右子树的加分 ＋ subtree的根的分数 若某个子树为空，规定其加分为 1。 叶子的加分就是叶节点本身的分数，不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树 tree。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 30; int n; int w[N]; int f[N][N], g[N][N]; void dfs(int l, int r) { if (l &gt; r) return; int k = g[l][r]; cout &lt;&lt; k &lt;&lt; ' '; dfs(l, k - 1); dfs(k + 1, r); } int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; w[i]; for (int len = 1; len &lt;= n; len ++ ) for (int l = 1; l + len - 1 &lt;= n; l ++ ) { int r = l + len - 1; if (len == 1) f[l][r] = w[l], g[l][r] = l; else { for (int k = l; k &lt;= r; k ++ ) { int left = k == l ? 1 : f[l][k - 1]; int right = k == r ? 1 : f[k + 1][r]; int score = left * right + w[k]; if (f[l][r] &lt; score) { f[l][r] = score; g[l][r] = k; } } } } cout &lt;&lt; f[1][n] &lt;&lt; endl; dfs(1, n); return 0; } 凸多边形的划分 给定一个具有 N 个顶点的凸多边形，将顶点从 1 至 N 标号，每个顶点的权值都是一个正整数。 将这个凸多边形划分成 N−2 个互不相交的三角形，对于每个三角形，其三个顶点的权值相乘都可得到一个权值乘积，试求所有三角形的顶点权值乘积之和至少为多少。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 55, M = 35, INF = 1e9; int n; int w[N]; LL f[N][N][M]; void add(LL a[], LL b[]) { static LL c[M]; memset(c, 0, sizeof c); for (int i = 0, t = 0; i &lt; M; i ++ ) { t += a[i] + b[i]; c[i] = t % 10; t /= 10; } memcpy(a, c, sizeof c); } void mul(LL a[], LL b) { static LL c[M]; memset(c, 0, sizeof c); LL t = 0; for (int i = 0; i &lt; M; i ++ ) { t += a[i] * b; c[i] = t % 10; t /= 10; } memcpy(a, c, sizeof c); } int cmp(LL a[], LL b[]) { for (int i = M - 1; i &gt;= 0; i -- ) if (a[i] &gt; b[i]) return 1; else if (a[i] &lt; b[i]) return -1; return 0; } void print(LL a[]) { int k = M - 1; while (k &amp;&amp; !a[k]) k -- ; while (k &gt;= 0) cout &lt;&lt; a[k -- ]; cout &lt;&lt; endl; } int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; w[i]; LL temp[M]; for (int len = 3; len &lt;= n; len ++ ) for (int l = 1; l + len - 1 &lt;= n; l ++ ) { int r = l + len - 1; f[l][r][M - 1] = 1; for (int k = l + 1; k &lt; r; k ++ ) { memset(temp, 0, sizeof temp); temp[0] = w[l]; mul(temp, w[k]); mul(temp, w[r]); add(temp, f[l][k]); add(temp, f[k][r]); if (cmp(f[l][r], temp) &gt; 0) memcpy(f[l][r], temp, sizeof temp); } } print(f[1][n]); return 0; } 数位DP 数字游戏 科协里最近很流行数字游戏。 某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。 现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 15; int f[N][N]; // f[i, j]表示一共有i位，且最高位填j的数的个数 void init() { for (int i = 0; i &lt;= 9; i ++ ) f[1][i] = 1; for (int i = 2; i &lt; N; i ++ ) for (int j = 0; j &lt;= 9; j ++ ) for (int k = j; k &lt;= 9; k ++ ) f[i][j] += f[i - 1][k]; } int dp(int n) { if (!n) return 1; vector&lt;int&gt; nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0; int last = 0; for (int i = nums.size() - 1; i &gt;= 0; i -- ) { int x = nums[i]; for (int j = last; j &lt; x; j ++ ) res += f[i + 1][j]; if (x &lt; last) break; last = x; if (!i) res ++ ; } return res; } int main() { init(); int l, r; while (cin &gt;&gt; l &gt;&gt; r) cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl; return 0; } /* 1 9 1 19 9 18 */ 数字游戏 II 由于科协里最近真的很流行数字游戏。 某人又命名了一种取模数，这种数字必须满足各位数字之和 mod N 为 0。 现在大家又要玩游戏了，指定一个整数闭区间 [a.b]，问这个区间内有多少个取模数。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 11, M = 110; int P; int f[N][10][M]; int mod(int x, int y) { return (x % y + y) % y; } void init() { memset(f, 0, sizeof f); for (int i = 0; i &lt;= 9; i ++ ) f[1][i][i % P] ++ ; for (int i = 2; i &lt; N; i ++ ) for (int j = 0; j &lt;= 9; j ++ ) for (int k = 0; k &lt; P; k ++ ) for (int x = 0; x &lt;= 9; x ++ ) f[i][j][k] += f[i - 1][x][mod(k - j, P)]; } int dp(int n) { if (!n) return 1; vector&lt;int&gt; nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0; int last = 0; for (int i = nums.size() - 1; i &gt;= 0; i -- ) { int x = nums[i]; for (int j = 0; j &lt; x; j ++ ) res += f[i + 1][j][mod(-last, P)]; last += x; if (!i &amp;&amp; last % P == 0) res ++ ; } return res; } int main() { int l, r; while (cin &gt;&gt; l &gt;&gt; r &gt;&gt; P) { init(); cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl; } return 0; } /* 1 19 9 2 */ 不要62 不吉利的数字为所有含有 4 或 62 的号码。例如：62315,73418,88914 都属于不吉利号码。但是，61152 虽然含有 6 和 2，但不是 连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照号区间 [n,m]，推断出交管局今后又要实际上给多少辆新的士车上牌照了。 /* 每组数据包含一个整数对 n 和 m。 当输入一行为“0 0”时，表示输入结束。 */ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 35; int f[N][10]; void init() { for (int i = 0; i &lt;= 9; i ++ ) if (i != 4) f[1][i] = 1; for (int i = 1; i &lt; N; i ++ ) for (int j = 0; j &lt;= 9; j ++ ) { if (j == 4) continue; for (int k = 0; k &lt;= 9; k ++ ) { if (k == 4 || j == 6 &amp;&amp; k == 2) continue; f[i][j] += f[i - 1][k]; } } } int dp(int n) { if (!n) return 1; vector&lt;int&gt; nums; while (n) nums.push_back(n % 10), n /= 10; int res = 0; int last = 0; for (int i = nums.size() - 1; i &gt;= 0; i -- ) { int x = nums[i]; for (int j = 0; j &lt; x; j ++ ) { if (j == 4 || last == 6 &amp;&amp; j == 2) continue; res += f[i + 1][j]; } if (x == 4 || last == 6 &amp;&amp; x == 2) break; last = x; if (!i) res ++ ; } return res; } int main() { init(); int l, r; while (cin &gt;&gt; l &gt;&gt; r, l || r) { cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl; } return 0; } /* 1 100 0 0 80 */ 斜率优化DP 任务安排3 有 N 个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。 机器会把这 N 个任务分成若干批，每一批包含连续的若干个任务。 从时刻 0 开始，任务被分批加工，执行第 i 个任务所需的时间是 Ti。 另外，在每批任务开始前，机器需要 S 的启动时间，故执行一批任务所需的时间是启动时间 S 加上每个任务所需时间之和。 一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。 也就是说，同一批任务将在同一时刻完成。 每个任务的费用是它的完成时刻乘以一个费用系数 Ci。 请为机器规划一个分组方案，使得总费用最小。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 300010; int n, s; LL t[N], c[N]; LL f[N]; int q[N]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;s); for (int i = 1; i &lt;= n; i ++ ) { scanf(&quot;%lld%lld&quot;, &amp;t[i], &amp;c[i]); t[i] += t[i - 1]; c[i] += c[i - 1]; } int hh = 0, tt = 0; q[0] = 0; for (int i = 1; i &lt;= n; i ++ ) { int l = hh, r = tt; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (f[q[mid + 1]] - f[q[mid]] &gt; (t[i] + s) * (c[q[mid + 1]] - c[q[mid]])) r = mid; else l = mid + 1; } int j = q[r]; f[i] = f[j] - (t[i] + s) * c[j] + t[i] * c[i] + s * c[n]; while (hh &lt; tt &amp;&amp; (double)(f[q[tt]] - f[q[tt - 1]]) * (c[i] - c[q[tt - 1]]) &gt;= (double)(f[i] - f[q[tt - 1]]) * (c[q[tt]] - c[q[tt - 1]])) tt -- ; q[ ++ tt] = i; } printf(&quot;%lld\\n&quot;, f[n]); return 0; } /* 5 1 1 3 3 2 4 3 2 3 1 4 153 */ 5. 搜索 5.1 BFS求连通块(FLood Fill) #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #define x first #define y second using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 1010, M = N * N; int n, m; char g[N][N]; PII q[M]; bool st[N][N]; void bfs(int sx, int sy) { int hh = 0, tt = 0; q[0] = {sx, sy}; st[sx][sy] = true; while (hh &lt;= tt) { PII t = q[hh ++ ]; for (int i = t.x - 1; i &lt;= t.x + 1; i ++ ) for (int j = t.y - 1; j &lt;= t.y + 1; j ++ ) { if (i == t.x &amp;&amp; j == t.y) continue; if (i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= m) continue; if (g[i][j] == '.' || st[i][j]) continue; q[ ++ tt] = {i, j}; st[i][j] = true; } } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%s&quot;, g[i]); int cnt = 0; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) if (g[i][j] == 'W' &amp;&amp; !st[i][j]) { bfs(i, j); cnt ++ ; } printf(&quot;%d\\n&quot;, cnt); return 0; } 5.2 矩阵最短路模型 经典迷宫问题，左上到右下找到一条最短路径(并输出) #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #define x first #define y second using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 1010, M = N * N; int n; int g[N][N]; PII q[M]; PII pre[N][N]; void bfs(int sx, int sy) { int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int hh = 0, tt = 0; q[0] = {sx, sy}; memset(pre, -1, sizeof pre); pre[sx][sy] = {0, 0}; while (hh &lt;= tt) { PII t = q[hh ++ ]; for (int i = 0; i &lt; 4; i ++ ) { int a = t.x + dx[i], b = t.y + dy[i]; if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n) continue; if (g[a][b]) continue; if (pre[a][b].x != -1) continue; q[ ++ tt] = {a, b}; pre[a][b] = t; } } } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) scanf(&quot;%d&quot;, &amp;g[i][j]); bfs(n - 1, n - 1); PII end(0, 0); while (true) { printf(&quot;%d %d\\n&quot;, end.x, end.y); if (end.x == n - 1 &amp;&amp; end.y == n - 1) break; end = pre[end.x][end.y]; } return 0; } 象棋马走日，象走田最短路径等只需要稍微修改一下dx，dy数组 5.3 双向BFS 字符串变换 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;unordered_map&gt; using namespace std; const int N = 6; int n; string A, B; string a[N], b[N]; int extend(queue&lt;string&gt;&amp; q, unordered_map&lt;string, int&gt;&amp;da, unordered_map&lt;string, int&gt;&amp; db, string a[N], string b[N]) { int d = da[q.front()]; while (q.size() &amp;&amp; da[q.front()] == d) { auto t = q.front(); q.pop(); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; t.size(); j ++ ) if (t.substr(j, a[i].size()) == a[i]) { string r = t.substr(0, j) + b[i] + t.substr(j + a[i].size()); if (db.count(r)) return da[t] + db[r] + 1; if (da.count(r)) continue; da[r] = da[t] + 1; q.push(r); } } return 11; } int bfs() { if (A == B) return 0; queue&lt;string&gt; qa, qb; unordered_map&lt;string, int&gt; da, db; qa.push(A), qb.push(B); da[A] = db[B] = 0; int step = 0; while (qa.size() &amp;&amp; qb.size()) { int t; if (qa.size() &lt; qb.size()) t = extend(qa, da, db, a, b); else t = extend(qb, db, da, b, a); if (t &lt;= 10) return t; if ( ++ step == 10) return -1; } return -1; } int main() { cin &gt;&gt; A &gt;&gt; B; while (cin &gt;&gt; a[n] &gt;&gt; b[n]) n ++ ; int t = bfs(); if (t == -1) puts(&quot;NO ANSWER!&quot;); else cout &lt;&lt; t &lt;&lt; endl; return 0; } 5.4 双端队列广搜 边权只有01的图适用 // 电路维修 /* 联通的边权为0，不连通的边权为0 */ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;deque&gt; #define x first #define y second using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 510, M = N * N; int n, m; char g[N][N]; int dist[N][N]; bool st[N][N]; int bfs() { memset(dist, 0x3f, sizeof dist); memset(st, 0, sizeof st); dist[0][0] = 0; deque&lt;PII&gt; q; q.push_back({0, 0}); char cs[] = &quot;\\\\/\\\\/&quot;; int dx[4] = {-1, -1, 1, 1}, dy[4] = {-1, 1, 1, -1}; int ix[4] = {-1, -1, 0, 0}, iy[4] = {-1, 0, 0, -1}; while (q.size()) { PII t = q.front(); q.pop_front(); if (st[t.x][t.y]) continue; st[t.x][t.y] = true; for (int i = 0; i &lt; 4; i ++ ) { int a = t.x + dx[i], b = t.y + dy[i]; if (a &lt; 0 || a &gt; n || b &lt; 0 || b &gt; m) continue; int ca = t.x + ix[i], cb = t.y + iy[i]; int d = dist[t.x][t.y] + (g[ca][cb] != cs[i]); if (d &lt; dist[a][b]) { dist[a][b] = d; if (g[ca][cb] != cs[i]) q.push_back({a, b}); // 如果边权为1则放到队尾 else q.push_front({a, b}); // 如果边权为0则放到对头 } } } return dist[n][m]; } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T -- ) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%s&quot;, g[i]); int t = bfs(); if (t == 0x3f3f3f3f) puts(&quot;NO SOLUTION&quot;); else printf(&quot;%d\\n&quot;, t); } return 0; } 5.5 A* 第K短路 // 给定一张 N 个点（编号 1,2…N），M 条边的有向图，求从起点 S 到终点 T 的第 K 短路的长度，路径允许重复经过点或边。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #define x first #define y second using namespace std; typedef pair&lt;int, int&gt; PII; typedef pair&lt;int, PII&gt; PIII; const int N = 1010, M = 200010; int n, m, S, T, K; int h[N], rh[N], e[M], w[M], ne[M], idx; int dist[N], cnt[N]; bool st[N]; void add(int h[], int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } void dijkstra() { priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, T}); memset(dist, 0x3f, sizeof dist); dist[T] = 0; while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.y; if (st[ver]) continue; st[ver] = true; for (int i = rh[ver]; ~i; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]) { dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } } int astar() { priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt;&gt; heap; heap.push({dist[S], {0, S}}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.y.y, distance = t.y.x; cnt[ver] ++ ; if (cnt[T] == K) return distance; for (int i = h[ver]; ~i; i = ne[i]) { int j = e[i]; if (cnt[j] &lt; K) heap.push({distance + w[i] + dist[j], {distance + w[i], j}}); } } return -1; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); memset(rh, -1, sizeof rh); for (int i = 0; i &lt; m; i ++ ) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); add(h, a, b, c); add(rh, b, a, c); } scanf(&quot;%d%d%d&quot;, &amp;S, &amp;T, &amp;K); if (S == T) K ++ ; dijkstra(); printf(&quot;%d\\n&quot;, astar()); return 0; } 5.6 双向DFS 达达帮翰翰给女生送礼物，翰翰一共准备了 N 个礼物，其中第 i 个礼物的重量是 G[i]。 达达的力气很大，他一次可以搬动重量之和不超过 W 的任意多个物品。 达达希望一次搬掉尽量重的一些物品，请你告诉达达在他的力气范围内一次性能搬动的最大重量是多少。 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef long long LL; const int N = 1 &lt;&lt; 24; int n, m, k; int g[50], weights[N]; int cnt = 0; int ans; void dfs(int u, int s) { if (u == k) { weights[cnt ++ ] = s; return; } if ((LL)s + g[u] &lt;= m) dfs(u + 1, s + g[u]); dfs(u + 1, s); } void dfs2(int u, int s) { if (u == n) { int l = 0, r = cnt - 1; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (weights[mid] + (LL)s &lt;= m) l = mid; else r = mid - 1; } if (weights[l] + (LL)s &lt;= m) ans = max(ans, weights[l] + s); return; } if ((LL)s + g[u] &lt;= m) dfs2(u + 1, s + g[u]); dfs2(u + 1, s); } int main() { cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; g[i]; sort(g, g + n); reverse(g, g + n); k = n / 2; // 防止 n = 1时，出现死循环 dfs(0, 0); sort(weights, weights + cnt); int t = 1; for (int i = 1; i &lt; cnt; i ++ ) if (weights[i] != weights[i - 1]) weights[t ++ ] = weights[i]; cnt = t; dfs2(k, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0; } /* 20 5 7 5 4 18 1 19 */ 5.7 IDA* 排书 给定 n 本书，编号为 1∼n。 在初始状态下，书是任意排列的。 在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。 我们的目标状态是把书按照 1∼n 的顺序依次排列。 求最少需要多少次操作。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 15; int n; int q[N]; int w[5][N]; int f() { int cnt = 0; for (int i = 0; i + 1 &lt; n; i ++ ) if (q[i + 1] != q[i] + 1) cnt ++ ; return (cnt + 2) / 3; } bool check() { for (int i = 0; i + 1 &lt; n; i ++ ) if (q[i + 1] != q[i] + 1) return false; return true; } bool dfs(int depth, int max_depth) { if (depth + f() &gt; max_depth) return false; if (check()) return true; for (int len = 1; len &lt;= n; len ++ ) for (int l = 0; l + len - 1 &lt; n; l ++ ) { int r = l + len - 1; for (int k = r + 1; k &lt; n; k ++ ) { memcpy(w[depth], q, sizeof q); int x, y; for (x = r + 1, y = l; x &lt;= k; x ++, y ++ ) q[y] = w[depth][x]; for (x = l; x &lt;= r; x ++, y ++ ) q[y] = w[depth][x]; if (dfs(depth + 1, max_depth)) return true; memcpy(q, w[depth], sizeof q); } } return false; } int main() { int T; cin &gt;&gt; T; while (T -- ) { cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; q[i]; int depth = 0; while (depth &lt; 5 &amp;&amp; !dfs(0, depth)) depth ++ ; if (depth &gt;= 5) puts(&quot;5 or more&quot;); else cout &lt;&lt; depth &lt;&lt; endl; } return 0; } 6. 图论 6.1 存边 邻接矩阵 邻接表 // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a-&gt;b void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 初始化 idx = 0; memset(h, -1, sizeof h); 6.2 树与图的遍历 时间复杂度 O(n+m)，n 表示点数，m 表示边数 深度优先遍历 int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } 宽度优先遍历 queue&lt;int&gt; q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } } 6.3 拓扑排序 时间复杂度 O(n+m)，n 表示点数，m 表示边数 bool topsort() { int hh = 0, tt = -1; // d[i] 存储点i的入度 for (int i = 1; i &lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; } 6.4 图论最短路模型(DJ, SPFA…) 堆优化的Dijkstra 时间复杂度 O(mlogn), n 表示点数，m 表示边数 typedef pair&lt;int, int&gt; PII; int n; // 点的数量 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储所有点到1号点的距离 bool st[N]; // 存储每个点的最短距离是否已确定 // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } Bellman-Ford算法 时间复杂度 O(nm), n 表示点数，m 表示边数 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e4 + 10; struct Edge { int a, b, w; }edge[N]; int n, m, k; int dist[N], backup[N]; void bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for(int i = 1;i &lt;= k;i ++) { memcpy(backup, dist, sizeof dist); for(int j = 0;j &lt;= m;j ++) { int a = edge[j].a,b = edge[j].b,w = edge[j].w; dist[b] = min(dist[b], backup[a] + w); } } if(dist[n] &gt; 0x3f3f3f3f / 2) printf(&quot;impossible\\n&quot;); else printf(&quot;%d\\n&quot;, dist[n]); } int main() { scanf(&quot;%d%d%d&quot;,&amp;n, &amp;m, &amp;k); for(int i = 1;i &lt;= m;i ++) { Edge &amp;x = edge[i]; scanf(&quot;%d%d%d&quot;,&amp;x.a, &amp;x.b, &amp;x.w); } bellman_ford(); return 0; } SPFA算法 时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数, m 表示边数 int n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int&gt; q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } spfa判断图中是否存在负环 时间复杂度是 O(nm), n 表示点数，m 表示边数 int n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N], cnt[N]; // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数 bool st[N]; // 存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] &gt;= n) return true; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } floyd算法 时间复杂度是 O(n3), n 表示点数 初始化： for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF; // 算法结束后，d[a][b]表示a到b的最短距离 void floyd() { for (int k = 1; k &lt;= n; k ++ ) for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } 6.5 最小生成树 朴素版prim算法 时间复杂度是 O(n^2+m), n 表示点数，m 表示边数 int n; // n表示点数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i ++ ) { int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } Kruskal算法 时间复杂度是 O(mlogm), n 表示点数，m 表示边数 int n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 struct Edge // 存储边 { int a, b, w; bool operator&lt; (const Edge &amp;W)const { return w &lt; W.w; } }edges[M]; int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i &lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // 如果两个连通块不连通，则将这两个连通块合并 { p[a] = b; res += w; cnt ++ ; } } if (cnt &lt; n - 1) return INF; return res; } 6.6 染色法判别二分图 时间复杂度是 O(n+m), n 表示点数，m 表示边数 int n; // n表示点数 int h[N], e[M], ne[M], idx; // 邻接表存储图 int color[N]; // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色 // 参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i &lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } 6.7 二分图的最大匹配（匈牙利算法） 时间复杂度是 O(nm), n 表示点数，m 表示边数 int n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数 int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边 int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过 bool find(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i &lt;= n1; i ++ ) { memset(st, false, sizeof st); if (find(i)) res ++ ; } 6.8 树的直径 树上最长的路径 树形DP求树的直径 void dp(int x) { st[x] = 1; for(int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if(st[j]) continue; dp(j); ans = max(ans, d[x] + d[j] + w[i]); d[x] = max(d[x], d[j] + w[i]); } } 两次BFS求出树的直径（边权非负） （1）从任意一个节点出发，跑一遍BFS，找到最远的p （2）再从p出发，跑一遍BFS，找到距离p最远的q p, q即为两个端点。 6.9 欧拉回路与欧拉路径 存在欧拉回路与欧拉路径的充要条件： 无向图 存在欧拉路径的充要条件 : 度数为奇数的点只能有0或2个 存在欧拉回路的充要条件 : 度数为奇数的点只能有0个 有向图 存在欧拉路径的充要条件 : 要么所有点的出度均==入度； 要么除了两个点之外，其余所有点的出度==入度 剩余的两个点:一个满足出度-入度==1(起点) 一个满足入度-出度==1(终点) 存在欧拉回路的充要条件 : 所有点的出度均等于入度 6.10 最近公共祖先（LCA） 祖孙询问 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 40010, M = N * 2; int n, m; int h[N], e[M], ne[M], idx; int depth[N], fa[N][16]; int q[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void bfs(int root) { memset(depth, 0x3f, sizeof depth); depth[0] = 0, depth[root] = 1; int hh = 0, tt = 0; q[0] = root; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if (depth[j] &gt; depth[t] + 1) { depth[j] = depth[t] + 1; q[ ++ tt] = j; fa[j][0] = t; for (int k = 1; k &lt;= 15; k ++ ) fa[j][k] = fa[fa[j][k - 1]][k - 1]; } } } } int lca(int a, int b) { if (depth[a] &lt; depth[b]) swap(a, b); for (int k = 15; k &gt;= 0; k -- ) if (depth[fa[a][k]] &gt;= depth[b]) a = fa[a][k]; if (a == b) return a; for (int k = 15; k &gt;= 0; k -- ) if (fa[a][k] != fa[b][k]) { a = fa[a][k]; b = fa[b][k]; } return fa[a][0]; } int main() { scanf(&quot;%d&quot;, &amp;n); int root = 0; memset(h, -1, sizeof h); for (int i = 0; i &lt; n; i ++ ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (b == -1) root = a; else add(a, b), add(b, a); } bfs(root); scanf(&quot;%d&quot;, &amp;m); while (m -- ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); int p = lca(a, b); if (p == a) puts(&quot;1&quot;); else if (p == b) puts(&quot;2&quot;); else puts(&quot;0&quot;); } return 0; } 次小生成树 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; const int N = 100010, M = 300010, INF = 0x3f3f3f3f; int n, m; struct Edge { int a, b, w; bool used; bool operator&lt; (const Edge &amp;t) const { return w &lt; t.w; } }edge[M]; int p[N]; int h[N], e[M], w[M], ne[M], idx; int depth[N], fa[N][17], d1[N][17], d2[N][17]; int q[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } LL kruskal() { for (int i = 1; i &lt;= n; i ++ ) p[i] = i; sort(edge, edge + m); LL res = 0; for (int i = 0; i &lt; m; i ++ ) { int a = find(edge[i].a), b = find(edge[i].b), w = edge[i].w; if (a != b) { p[a] = b; res += w; edge[i].used = true; } } return res; } void build() { memset(h, -1, sizeof h); for (int i = 0; i &lt; m; i ++ ) if (edge[i].used) { int a = edge[i].a, b = edge[i].b, w = edge[i].w; add(a, b, w), add(b, a, w); } } void bfs() { memset(depth, 0x3f, sizeof depth); depth[0] = 0, depth[1] = 1; q[0] = 1; int hh = 0, tt = 0; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if (depth[j] &gt; depth[t] + 1) { depth[j] = depth[t] + 1; q[ ++ tt] = j; fa[j][0] = t; d1[j][0] = w[i], d2[j][0] = -INF; for (int k = 1; k &lt;= 16; k ++ ) { int anc = fa[j][k - 1]; fa[j][k] = fa[anc][k - 1]; int distance[4] = {d1[j][k - 1], d2[j][k - 1], d1[anc][k - 1], d2[anc][k - 1]}; d1[j][k] = d2[j][k] = -INF; for (int u = 0; u &lt; 4; u ++ ) { int d = distance[u]; if (d &gt; d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d; else if (d != d1[j][k] &amp;&amp; d &gt; d2[j][k]) d2[j][k] = d; } } } } } } int lca(int a, int b, int w) { static int distance[N * 2]; int cnt = 0; if (depth[a] &lt; depth[b]) swap(a, b); for (int k = 16; k &gt;= 0; k -- ) if (depth[fa[a][k]] &gt;= depth[b]) { distance[cnt ++ ] = d1[a][k]; distance[cnt ++ ] = d2[a][k]; a = fa[a][k]; } if (a != b) { for (int k = 16; k &gt;= 0; k -- ) if (fa[a][k] != fa[b][k]) { distance[cnt ++ ] = d1[a][k]; distance[cnt ++ ] = d2[a][k]; distance[cnt ++ ] = d1[b][k]; distance[cnt ++ ] = d2[b][k]; a = fa[a][k], b = fa[b][k]; } distance[cnt ++ ] = d1[a][0]; distance[cnt ++ ] = d1[b][0]; } int dist1 = -INF, dist2 = -INF; for (int i = 0; i &lt; cnt; i ++ ) { int d = distance[i]; if (d &gt; dist1) dist2 = dist1, dist1 = d; else if (d != dist1 &amp;&amp; d &gt; dist2) dist2 = d; } if (w &gt; dist1) return w - dist1; if (w &gt; dist2) return w - dist2; return INF; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; i ++ ) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); edge[i] = {a, b, c}; } LL sum = kruskal(); build(); bfs(); LL res = 1e18; for (int i = 0; i &lt; m; i ++ ) if (!edge[i].used) { int a = edge[i].a, b = edge[i].b, w = edge[i].w; res = min(res, sum + lca(a, b, w)); } printf(&quot;%lld\\n&quot;, res); return 0; } 6.11 树上两点距离 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 10010, M = N * 2; int n, m; int h[N], e[M], w[M], ne[M], idx; int dist[N]; int p[N]; int res[M]; int st[N]; vector&lt;PII&gt; query[N]; // first存查询的另外一个点，second存查询编号 void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } void dfs(int u, int fa) { for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == fa) continue; dist[j] = dist[u] + w[i]; dfs(j, u); } } int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } void tarjan(int u) { st[u] = 1; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (!st[j]) { tarjan(j); p[j] = u; } } for (auto item : query[u]) { int y = item.first, id = item.second; if (st[y] == 2) { int anc = find(y); res[id] = dist[u] + dist[y] - dist[anc] * 2; } } st[u] = 2; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); for (int i = 0; i &lt; n - 1; i ++ ) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); add(a, b, c), add(b, a, c); } for (int i = 0; i &lt; m; i ++ ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (a != b) { query[a].push_back({b, i}); query[b].push_back({a, i}); } } for (int i = 1; i &lt;= n; i ++ ) p[i] = i; dfs(1, -1); tarjan(1); for (int i = 0; i &lt; m; i ++ ) printf(&quot;%d\\n&quot;, res[i]); return 0; } 6.12 有向图的强联通分量 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 10010, M = 50010; int n, m; int h[N], e[M], ne[M], idx; int dfn[N], low[N], timestamp; int stk[N], top; bool in_stk[N]; int id[N], scc_cnt, Size[N]; int dout[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void tarjan(int u) { dfn[u] = low[u] = ++ timestamp; stk[ ++ top] = u, in_stk[u] = true; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!dfn[j]) { tarjan(j); low[u] = min(low[u], low[j]); } else if (in_stk[j]) low[u] = min(low[u], dfn[j]); } if (dfn[u] == low[u]) { ++ scc_cnt; int y; do { y = stk[top -- ]; in_stk[y] = false; id[y] = scc_cnt; Size[scc_cnt] ++ ; } while (y != u); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); while (m -- ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b); } for (int i = 1; i &lt;= n; i ++ ) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; i ++ ) for (int j = h[i]; ~j; j = ne[j]) { int k = e[j]; int a = id[i], b = id[k]; if (a != b) dout[a] ++ ; } int zeros = 0, sum = 0; for (int i = 1; i &lt;= scc_cnt; i ++ ) if (!dout[i]) { zeros ++ ; sum += Size[i]; if (zeros &gt; 1) { sum = 0; break; } } printf(&quot;%d\\n&quot;, sum); return 0; } 6.13 无向图的双联通分量 冗余路径 为了从 FF 个草场中的一个走到另一个，奶牛们有时不得不路过一些她们讨厌的可怕的树。 奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择。 每对草场之间已经有至少一条路径。 给出所有 RR 条双向路的描述，每条路连接了两个不同的草场，请计算最少的新建道路的数量，路径由若干道路首尾相连而成。 两条路径相互分离，是指两条路径没有一条重合的道路。 但是，两条分离的路径上可以有一些相同的草场。 对于同一对草场之间，可能已经有两条不同的道路，你也可以在它们之间再建一条道路，作为另一条不同的道路。 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 5010, M = 20010; int n, m; int h[N], e[M], ne[M], idx; int dfn[N], low[N], timestamp; int stk[N], top; int id[N], dcc_cnt; bool is_bridge[M]; int d[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void tarjan(int u, int from) { dfn[u] = low[u] = ++ timestamp; stk[ ++ top] = u; for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (!dfn[j]) { tarjan(j, i); low[u] = min(low[u], low[j]); if (dfn[u] &lt; low[j]) is_bridge[i] = is_bridge[i ^ 1] = true; } else if (i != (from ^ 1)) low[u] = min(low[u], dfn[j]); } if (dfn[u] == low[u]) { ++ dcc_cnt; int y; do { y = stk[top -- ]; id[y] = dcc_cnt; } while (y != u); } } int main() { cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); while (m -- ) { int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b), add(b, a); } tarjan(1, -1); for (int i = 0; i &lt; idx; i ++ ) if (is_bridge[i]) d[id[e[i]]] ++ ; int cnt = 0; for (int i = 1; i &lt;= dcc_cnt; i ++ ) if (d[i] == 1) cnt ++ ; printf(&quot;%d\\n&quot;, (cnt + 1) / 2); return 0; }","categories":[],"tags":[],"keywords":[]},{"title":"线段树","slug":"线段树","date":"2022-10-18T03:08:52.000Z","updated":"2022-10-18T03:10:18.143Z","comments":true,"path":"2022/10/18/线段树/","link":"","permalink":"https://memsetray.github.io/2022/10/18/线段树/","excerpt":"","text":"线段树 1.单点修改，区间查询线段树 #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10; struct info { int minv, cnt_min; }; struct Node { info val; }tr[N * 4]; int n, q; int a[N]; info operator + (const info &amp;l, const info &amp;r) { info a; a.minv = min(l.minv, r.minv); if(l.minv == r.minv) a.cnt_min = l.cnt_min + r.cnt_min; else if(l.minv &lt; r.minv) a.cnt_min = l.cnt_min; else a.cnt_min = r.cnt_min; return a; } void pushup(int u) { tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val; } void build(int u, int l, int r) { if(l == r) tr[u].val = {a[l], 1}; else { int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void change(int u, int l, int r, int pos, int val) { if(l == r) tr[u].val = {val, 1}; else { int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) change(u &lt;&lt; 1, l, mid, pos, val); else change(u &lt;&lt; 1 | 1, mid + 1, r, pos, val); pushup(u); } } info query(int u, int l, int r, int ql, int qr) { if(l == ql &amp;&amp; r == qr) return tr[u].val; int mid = l + r &gt;&gt; 1; if(qr &lt;= mid) return query(u &lt;&lt; 1, l, mid, ql, qr); else if(ql &gt; mid) return query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr); else { return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 1, n); while(q --) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if(a == 1) { change(1, 1, n, b, c); } else { auto a = query(1, 1, n, b, c); printf(&quot;%d %d\\n&quot;, a.minv, a.cnt_min); } } } 2.维护复杂信息的线段树（最大子段和） #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int N = 2e5 + 10; struct info { ll mss, mpre, msuf, s; info () {} info (int a):mss(a), mpre(a), msuf(a), s(a) {} }; struct Node { info val; }tr[N * 4]; int n, q; int a[N]; info operator + (const info &amp;l, const info &amp;r) { info a; a.mss = max(max(l.mss, r.mss), l.msuf + r.mpre); a.mpre = max(l.mpre, l.s + r.mpre); a.msuf = max(r.msuf, r.s + l.msuf); a.s = l.s + r.s; return a; } void pushup(int u) { tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val; } void build(int u, int l, int r) { if(l == r) tr[u].val = info(a[l]); else { int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void change(int u, int l, int r, int pos, int val) { if(l == r) tr[u].val = info(val); else { int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) change(u &lt;&lt; 1, l, mid, pos, val); else change(u &lt;&lt; 1 | 1, mid + 1, r, pos, val); pushup(u); } } info query(int u, int l, int r, int ql, int qr) { if(l == ql &amp;&amp; r == qr) return tr[u].val; int mid = l + r &gt;&gt; 1; if(qr &lt;= mid) return query(u &lt;&lt; 1, l, mid, ql, qr); else if(ql &gt; mid) return query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr); else { return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 1, n); while(q --) { ll a, b, c; scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c); if(a == 1) { change(1, 1, n, b, c); } else { auto a = query(1, 1, n, b, c); printf(&quot;%lld\\n&quot;, a.mss); } } } 3.区间修改，区间查询线段树 #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10; typedef long long ll; ll n, q; ll a[N]; struct info { ll maxv; }; struct tag { ll add; }; info operator + (const info &amp;l, const info &amp;r) { return {max(l.maxv, r.maxv)}; } info operator + (const info &amp;v, const tag &amp;t) { return {v.maxv + t.add}; } tag operator + (const tag &amp;t1, const tag &amp;t2) { return {t1.add + t2.add}; } struct node { tag t; info val; }tr[N * 4]; void pushup(int u) { tr[u].val = tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val; } void settag(int u, tag t) { tr[u].val = tr[u].val + t; tr[u].t = tr[u].t + t; } void pushdown(int u) { if(tr[u].t.add != 0) { settag(u &lt;&lt; 1, tr[u].t); settag(u &lt;&lt; 1 | 1, tr[u].t); tr[u].t.add = 0; } } void build(int u, int l, int r) { if(l == r) tr[u].val = {a[l]}; else { ll mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int l, int r, int ql, int qr, tag t) { if(l == ql &amp;&amp; r == qr) { settag(u, t); return ; } ll mid = l + r &gt;&gt; 1; pushdown(u); if(qr &lt;= mid) modify(u &lt;&lt; 1, l, mid, ql, qr, t); else if(ql &gt; mid) modify(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr, t); else { modify(u &lt;&lt; 1, l, mid, ql, mid, t); modify(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr, t); } pushup(u); } info query(int u, int l, int r, int ql, int qr) { if(l == ql &amp;&amp; r == qr) return tr[u].val; ll mid = l + r &gt;&gt; 1; pushdown(u); if(qr &lt;= mid) query(u &lt;&lt; 1, l, mid, ql, qr); else if(ql &gt; mid) query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr); else { return query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 1, n); while(q --) { int op; scanf(&quot;%d&quot;, &amp;op); if(op == 1) { int l, r, d; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d); modify(1, 1, n, l, r, (tag){d}); } else { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); auto a = query(1, 1, n, l, r); printf(&quot;%lld\\n&quot;, a.maxv); } } return 0; } 区间修改，区间查询线段树（复杂标记） #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5 + 10, mod = 1e9 + 7; typedef long long ll; ll n, q; ll a[N]; struct tag { ll mul, add; }; tag operator + (const tag &amp;t1, const tag &amp;t2) { return {t1.mul * t2.mul % mod, (t1.add * t2.mul + t2.add) % mod}; } struct node { tag t; ll val; int siz; }tr[N * 4]; void pushup(int u) { tr[u].val = (tr[u &lt;&lt; 1].val + tr[u &lt;&lt; 1 | 1].val) % mod; } void settag(int u, tag t) { tr[u].val = (tr[u].val * t.mul + tr[u].siz * t.add) % mod; tr[u].t = tr[u].t + t; } void pushdown(int u) { if(tr[u].t.mul != 1 || tr[u].t.add != 0) { settag(u &lt;&lt; 1, tr[u].t); settag(u &lt;&lt; 1 | 1, tr[u].t); tr[u].t.add = 0; tr[u].t.mul = 1; } } void build(int u, int l, int r) { tr[u].t = {1, 0}; tr[u].siz = r - l + 1; if(l == r) tr[u].val = {a[l]}; else { ll mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); } } void modify(int u, int l, int r, int ql, int qr, tag t) { if(l == ql &amp;&amp; r == qr) { settag(u, t); return ; } ll mid = l + r &gt;&gt; 1; pushdown(u); if(qr &lt;= mid) modify(u &lt;&lt; 1, l, mid, ql, qr, t); else if(ql &gt; mid) modify(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr, t); else { modify(u &lt;&lt; 1, l, mid, ql, mid, t); modify(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr, t); } pushup(u); } ll query(int u, int l, int r, int ql, int qr) { if(l == ql &amp;&amp; r == qr) return tr[u].val; ll mid = l + r &gt;&gt; 1; pushdown(u); if(qr &lt;= mid) query(u &lt;&lt; 1, l, mid, ql, qr); else if(ql &gt; mid) query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr); else { return (query(u &lt;&lt; 1, l, mid, ql, mid) + query(u &lt;&lt; 1 | 1, mid + 1, r, mid + 1, qr)) % mod; } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 1, n); while(q --) { int op; scanf(&quot;%d&quot;, &amp;op); if(op &lt;= 3) { int l, r, d; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;d); if(op == 1) modify(1, 1, n, l, r, (tag){1, d}); if(op == 2) modify(1, 1, n, l, r, (tag){d, 0}); if(op == 3) modify(1, 1, n, l, r, (tag){0, d}); } else { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); ll res = query(1, 1, n, l, r); printf(&quot;%lld\\n&quot;, res); } } return 0; } 4. 线段树上二分 5. 扫描线与权值线段树","categories":[],"tags":[],"keywords":[]},{"title":"AtCoderBeginnerContest046题解","slug":"AtCoderBeginnerContest046题解","date":"2022-10-15T14:12:03.000Z","updated":"2022-10-15T14:13:42.735Z","comments":true,"path":"2022/10/15/AtCoderBeginnerContest046题解/","link":"","permalink":"https://memsetray.github.io/2022/10/15/AtCoderBeginnerContest046题解/","excerpt":"","text":"AtCoder Beginner Contest 046 题解 A - AtCoDeer and Paint Cans 给定三个数，求这三个数中有多少个数是重复的。 开一个桶统计即可。 AC 代码 #include&lt;bits/stdc++.h&gt; using namespace std; map&lt;int, int&gt; m; int main() { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; m[a] ++, m[b] ++, m[c] ++; int t = max(max(m[a], m[b]), m[c]); if(t == 1) cout &lt;&lt; 3 &lt;&lt; endl; else if(t == 2) cout &lt;&lt; 2 &lt;&lt; endl; else if(t == 3) cout &lt;&lt; 1 &lt;&lt; endl; return 0; } B - Painting Balls with AtCoDeer 有nnn个球，现在需要用kkk种颜色给每个球染色，要求相邻两个球的颜色不能相同，求可行的方案数。 第一次可以使用全部kkk个颜色，之后每次都不能使用上一次的颜色，因此只能使用k−1k - 1k−1种颜色，根据乘法原理，将其累乘起来即可。 AC 代码 #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; signed main() { int n, k; cin &gt;&gt; n &gt;&gt; k; int res = 0; for(int i = 1; i &lt;= n; i ++) { if(i == 1) res += k; else { res *= (k - 1); } } cout &lt;&lt; res &lt;&lt; endl; return 0; } C - AtCoDeer and Election Report 给定nnn和nnn对正整数Ti,AiT_i,A_iTi​,Ai​，已知正整数数列ti,ait_i,a_iti​,ai​满足一下条件： ti≤ti+1,ai≤ai+1t_i \\leq t_{i + 1}, a_i \\leq a_{i + 1}ti​≤ti+1​,ai​≤ai+1​ ti/ai=Ti/Ait_i / a_i = T_i / A_iti​/ai​=Ti​/Ai​ 求tn+ant_n + a_ntn​+an​的最小值。 AC 代码 #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 1010; int a[N], t[N]; int ceill(int u, int v) { return (u - 1) / v + 1; } signed main() { int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; t[i] &gt;&gt; a[i]; } int u = t[1], v = a[1]; for(int i = 2; i &lt;= n; i ++) { u = t[i] * ceill(u, t[i]); v = a[i] * ceill(v, a[i]); if(u / t[i] &lt; v / a[i]) u = v / a[i] * t[i]; else v = u / t[i] * a[i]; } cout &lt;&lt; u + v &lt;&lt; endl; return 0; } AtCoDeer and Rock-Paper 你和对手都只有两种出拳方式：石头(g)(g)(g)和布(p)(p)(p)，布可以战胜石头，赢了得一分，输了扣一分，平局得000分，现在给你对手的出拳方式，设你到第iii次出拳共出了xix_ixi​次石头，yiy_iyi​次布，在对于任意位置iii满足xi≥yix_i \\geq y_ixi​≥yi​的条件下，输出你能得到的最大分数。 贪心，首先在满足条件的情况下，出拳或布的先后顺序对答案没有影响，因此我们可以直接按每一位考虑，我们统计之前出拳和出布的次数，然后对于当前对手的出法，我们考虑： 如果对手此时出拳：如果我们此时可以出布，那么我们就出布，否则出拳 如果对手此时出布，如果我们此时可以出布，那么我们就出布，否则出拳。 模拟一下即可。 AC 代码 #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 1e5 + 10; string s; int main() { cin &gt;&gt; s; int cnt_g = 0, cnt_p = 0; int res = 0; for(int i = 0; i &lt; s.size(); i ++) { if(s[i] == 'g') { if(cnt_p &lt; cnt_g) { res ++; cnt_p ++; } else cnt_g ++; } else if(s[i] == 'p') { if(cnt_p &lt; cnt_g) { cnt_p ++; } else { res --; cnt_g ++; } } } cout &lt;&lt; res &lt;&lt; endl; return 0; }","categories":[],"tags":[],"keywords":[]},{"title":"树形DP笔记","slug":"树形DP笔记","date":"2022-10-14T18:31:45.000Z","updated":"2022-10-15T11:15:43.252Z","comments":true,"path":"2022/10/15/树形DP笔记/","link":"","permalink":"https://memsetray.github.io/2022/10/15/树形DP笔记/","excerpt":"","text":"树形DP笔记 1. 树形背包 给定一个nnn个点的有根树，其中111号点为根节点，每个点有一个权值aia_iai​，权值可能为负数。 你需要回答qqq个询问，在uuu的子树中，选择一个大小恰好为mmm的包含uuu点的连通块，最大的权值和。保证mmm不会超过uuu的子树大小。 数据范围： 1≤n≤20001 \\leq n \\leq 20001≤n≤2000 −105≤ai≤105-10^5 \\leq a_i \\leq 10^5−105≤ai​≤105 1≤m≤n1 \\leq m \\leq n1≤m≤n 1≤q≤1051 \\leq q \\leq 10^51≤q≤105 考虑DP，设dp[i][j]dp[i][j]dp[i][j]表示从以iii为根的子树里选jjj个点且包含iii点，权值的最大值。 很明显的背包问题，我们需要把不同儿子的背包合并，考虑树形DP时如何更新状态 枚举已经遍历过的连通块中选择iii个点，在当前枚举到的子树中选择jjj个点，将它们的和dp[u][i]+dp[v][j]dp[u][i] + dp[v][j]dp[u][i]+dp[v][j]存入temptemptemp数组中，最后用temptemptemp的值整体更新dpdpdp数组的值。 由此可见，每次合并两个背包都需要一个双重循环，表面上时间复杂度为O(n3)O(n^3)O(n3)，然而实际上时间复杂度只有O(n2)O(n^2)O(n2) 假设我们当前合并的两个背包的大小为sizeu和sizevsize_u和size_vsizeu​和sizev​，那么合并这两个背包的复杂度是O(sizeu×sizev)O(size_u × size_v)O(sizeu​×sizev​)的 我们考虑数学含义，可以理解为当两个背包合并时，每对元素都贡献了111的代价，也就是说，当两个子树合并的时候，每对点都贡献了111的贡献。 那么对于任意一对点，它们只会做出一次贡献，被合并一次，所以总的时间复杂度是O(n2)O(n^2)O(n2)。 AC 代码 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2010; int n, m, q; vector&lt;int&gt; son[N]; int a[N]; int dp[N][N]; int sz[N]; int temp[N]; void dfs(int u) { sz[u] = 0; for(auto v : son[u]) { dfs(v); for(int i = 0; i &lt;= sz[u] + sz[v]; i ++) temp[i] = -0x3f3f3f3f; for(int i = 0; i &lt;= sz[u]; i ++) { for(int j = 0; j &lt;= sz[v]; j ++) temp[i + j] = max(temp[i + j], dp[u][i] + dp[v][j]); } for(int i = 0; i &lt;= sz[u] + sz[v]; i ++) dp[u][i] = temp[i]; sz[u] += sz[v]; } sz[u] ++; for(int i = sz[u]; i &gt;= 1; i --) dp[u][i] = dp[u][i - 1] + a[u]; } void solve() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;q); for(int i = 2; i &lt;= n; i ++) { int t; scanf(&quot;%lld&quot;, &amp;t); son[t].push_back(i); } for(int i = 1; i &lt;= n; i ++) scanf(&quot;%lld&quot;, &amp;a[i]); dfs(1); while(q --) { int u, m; scanf(&quot;%lld%lld&quot;, &amp;u, &amp;m); printf(&quot;%lld\\n&quot;, dp[u][m]); } } signed main() { //ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } 变式1： 上述问题的数据范围更改成： 1≤n≤500001 \\leq n \\leq 500001≤n≤50000 1≤m≤1001 \\leq m \\leq 1001≤m≤100 其他条件不变 继续设dp[i][j]dp[i][j]dp[i][j]表示在iii这个子树里面选了jjj个点，并且包含iii点的最大权值和 对于这道题，维度jjj只需要遍历到mmm即可，时间复杂度O(nm)O(nm)O(nm) AC 代码 #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 50010, M = 100, INF = 2e9; vector&lt;int&gt; son[N]; int dp[N][M + 10]; int sz[N]; int n, q; int temp[N]; int w[N]; void dfs(int u) { sz[u] = 0; for(auto v : son[u]) { dfs(v); for(int i = 0; i &lt;= sz[u] + sz[v] &amp;&amp; i &lt;= M; i ++) temp[i] = -INF; for(int i = 0; i &lt;= sz[u] &amp;&amp; i &lt;= M; i ++) { for(int j = 0; j &lt;= sz[v] &amp;&amp; i + j &lt;= M; j ++) temp[i + j] = max(temp[i + j], dp[u][i] + dp[v][j]); } for(int i = 0; i &lt;= sz[u] + sz[v] &amp;&amp; i &lt;= M; i ++) dp[u][i] = temp[i]; sz[u] += sz[v]; } sz[u] ++; for(int i = min(sz[u], M); i &gt;= 1; i --) dp[u][i] = dp[u][i - 1] + w[u]; dp[u][0] = 0; } void solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 2; i &lt;= n; i ++) { int x; scanf(&quot;%d&quot;, &amp;x); son[x].push_back(i); } for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;w[i]); dfs(1); while(q --) { int u, m; scanf(&quot;%d%d&quot;, &amp;u, &amp;m); printf(&quot;%d\\n&quot;, dp[u][m]); } } int main() { //ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } 变式2： 给你一个nnn个点的有根树，其中111号点为根，每个点有一个权值aia_iai​和重量wiw_iwi​。 你需要选择一个重量恰好为kkk的包含根的连通块，且权值和最大。 对所有的k=0,1,2,...,mk = 0,1,2,...,mk=0,1,2,...,m输出答案，不存在则输出000 数据范围： 1≤n≤10001 \\leq n \\leq 10001≤n≤1000 1≤ai≤1051 \\leq a_i \\leq 10^51≤ai​≤105 1≤wi≤1051 \\leq w_i \\leq 10^51≤wi​≤105 1≤m≤100001 \\leq m \\leq 100001≤m≤10000 更加标准的树上01背包问题，如果我们仍然像前两道题一样设计DP状态，那么我们执行合并两个子树背包的操作时，由于每个物品都有重量，所以一个子树可能节点个数很少，但是状态很多（重量可能很大导致第二维很大），因此无法像之前一样保证时间复杂度。 因此要使用特殊的技巧：在DFSDFSDFS序上做DP 求出整棵树的DFSDFSDFS序，设rxr_xrx​表示DFSDFSDFS序中跳过xxx这个子树的下一个位置 eg:(1(2(3)(4))(5(6)(7)))eg:(1(2(3)(4))(5(6)(7)))eg:(1(2(3)(4))(5(6)(7)))，则r2=5,r3=4,r5=8r_2 = 5, r_3 = 4, r_5 = 8r2​=5,r3​=4,r5​=8 我们从后往前做，设dp[i][j]dp[i][j]dp[i][j]表示考虑DFSDFSDFS序中[i,n][i,n][i,n]这一段节点，选的重量和不超过jjj的最大权值和，同时满足不存在一个点选了，但是它的祖先没有被选的情况。 状态转移方程：dp[i][j]=max(dp[ri][j],f[i+1][j−wi]+vi)dp[i][j] = max(dp[r_i][j], f[i + 1][j - w_i] + v_i)dp[i][j]=max(dp[ri​][j],f[i+1][j−wi​]+vi​) 即：如果不选这个节点，那么整个子树都会被跳过，从rir_iri​转移过来，否则考虑下一个节点，时间复杂度O(nm)O(nm)O(nm)。 AC 代码 #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 2010, INF = 2e9; int w[N]; int n, m; int dp[N][N]; vector&lt;int&gt; son[N]; int dfn[N], tot; int a[N]; int l[N], r[N]; int id[N]; void dfs(int u) { l[u] = ++ tot; id[tot] = u; for(auto v : son[u]) { dfs(v); } r[u] = tot; } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 2; i &lt;= n; i ++) { int x; scanf(&quot;%d&quot;, &amp;x); son[x].push_back(i); } for(int i = 1; i &lt;= m; i ++) dp[n + 1][i] = -INF; for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;w[i]); dfs(1); for(int i = n; i &gt;= 1; i --) { int u = id[i]; for(int j = 0; j &lt;= m; j ++) { dp[i][j] = dp[r[u] + 1][j]; if(j &gt;= w[u]) dp[i][j] = max(dp[i][j], dp[i + 1][j - w[u]] + a[u]); } } for(int i = 0; i &lt;= m; i ++) if(dp[1][i] &gt;= 0) printf(&quot;%d\\n&quot;, dp[1][i]); else printf(&quot;0\\n&quot;); } &lt;/details&gt; 2.树上路径 给你一个nnn个点的树。 给你mmm条树上的简单路径，每个路径都有一个权值aia_iai​，要求选择一些路径，使得每个点至多在一条路径上，并且路径的权值和最大。 数据范围： 1≤n≤20001 \\leq n \\leq 20001≤n≤2000 1≤m≤20001 \\leq m \\leq 20001≤m≤2000 1≤ai≤1091 \\leq a_i \\leq 10^91≤ai​≤109 我们考虑在两个点的LCALCALCA处决定这条路径是否选择。 设dp[i]dp[i]dp[i]表示考虑所有在iii为根的子树里的所有路径的最大权值和。 每次转移的时候，对于点iii，考虑所有LCALCALCA为iii点的路径，如果选择这条路径就相当于删除这条路径上所有的点，整个子树被拆成一个森林，将这些点的dpdpdp值加上路径的权值即可，时间复杂度O(nm)O(nm)O(nm)。 AC 代码 #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N = 2010; int n, m; vector&lt;int&gt; son[N]; vector&lt;array&lt;int, 3&gt;&gt; path[N]; int dp[N]; int son_dp[N]; int depth[N]; int f[N]; void dfs(int u) { for(auto v : son[u]) { dfs(v); son_dp[u] += dp[v]; //所有儿子节点的DP值之和 } dp[u] = son_dp[u]; //不选u，DP值就是儿子节点的DP值之和 for(auto p : path[u]) //选u，考虑LCA上的一条路径 { int temp = son_dp[u]; int x = p[0]; while(x != u) { temp += son_dp[x] - dp[x]; x = f[x]; } x = p[1]; while(x != u) { temp += son_dp[x] - dp[x]; x = f[x]; } temp += p[2]; dp[u] = max(dp[u], temp); } } signed main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for(int i = 2; i &lt;= n; i ++) { scanf(&quot;%lld&quot;, &amp;f[i]); son[f[i]].push_back(i); depth[i] = depth[f[i]] + 1; } for(int i = 1; i &lt;= m; i ++) { int u, v, a; scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;a); int x = u, y = v; while(x != y) { if(depth[x] &gt; depth[y]) x = f[x]; else y = f[y]; } path[x].push_back({u, v, a}); } dfs(1); printf(&quot;%lld\\n&quot;, dp[1]); return 0; } 变式1： 给你一个nnn个点的树。 给你mmm条树上的简单路径，每个路径都有权值aia_iai​，保证每条路径都是从一个点到它的祖先 要求选择一些路径，使得每个点至少在一条路径上，并且路径的权值和最小，如果不存在输出−1-1−1 数据范围同上 这道题一个点可能会在多条路径上面，因此我们不能直接记录在哪些路径上。 然而如果有点uuu在很多条路径上面，那么我们实际上只要知道这些路径最多能往上伸多少即可。 设dp[i][j]dp[i][j]dp[i][j]表示考虑iii这个子树里面选择的路径，最多延伸到深度为jjj的位置最小的权值和。 在转移的时候，我们可以枚举每个儿子的路径最多延伸到多少，取深度的minminmin即可。 然而这样做的时间复杂度为O(n3)O(n^3)O(n3)，考虑优化。 我们可以使用前缀最小值来进行优化，时间复杂度O(n2)O(n^2)O(n2)","categories":[],"tags":[],"keywords":[]},{"title":"CodeForces1700-2000难度部分题题解","slug":"Codeforces1700-2000难度部分题题解","date":"2022-09-06T14:36:37.000Z","updated":"2022-10-04T12:32:11.156Z","comments":true,"path":"2022/09/06/Codeforces1700-2000难度部分题题解/","link":"","permalink":"https://memsetray.github.io/2022/09/06/Codeforces1700-2000难度部分题题解/","excerpt":"","text":"Codeforces 1700-2000难度部分题题解 1721D -Maximum AND 题目大意:给出两个长度为nnn的数组a,ba,ba,b，规定f(a,b)f(a,b)f(a,b)表示以下操作： 创建一个长度为nnn的数组，满足ci=ai⊕bic_i=a_i \\oplus b_ici​=ai​⊕bi​ 则 f(a,b)=c1&amp;c2&amp;...&amp;cnf(a,b) = c_1 \\&amp; c_2 \\&amp;...\\&amp;c_nf(a,b)=c1​&amp;c2​&amp;...&amp;cn​ 你可以将bbb数组进行任意的排列，求最大的f(a,b)f(a,b)f(a,b) 数据范围：1≤n≤1051 \\leq n \\leq 10^51≤n≤105 题解：二进制构造题，首先考虑二进制拆位，由于f(a,b)f(a,b)f(a,b)由按位与操作得到，因此某一位为111必然有： ∀ci\\forall c_i∀ci​，该位的二进制为111 又由于ci=ai⊕bic_i=a_i \\oplus b_ici​=ai​⊕bi​，则ai与bia_i 与 b_iai​与bi​必然在该位上满足：000的个数与111的个数相同 由此考虑贪心：从高位向低位枚举，如果满足该位上000与111的个数相同，就选取这一位，但是这种贪心方式是错误的，因为： 2 3 0 2 1 如果按上述方式选取，会发现bbb中一定有一个数被选择了两次，这显然是不合法的 于是进一步考虑一个数能被选取的条件，不妨设答案为resresres 如果存在bbb的排序，∀ai\\forall a_i∀ai​有(ai&amp;res)⊕(bi&amp;res)=res(a_i \\&amp; res) \\oplus (b_i \\&amp; res) = res(ai​&amp;res)⊕(bi​&amp;res)=res（即前iii位中aaa中1的个数与bbb中0的个数相同），则resresres即为答案。 我们考虑每一位，将其异或resresres,并将两个得到的数组排序，如果相同，则该位为111，否则为000 // Problem: D. Maximum AND // Contest: Codeforces - Educational Codeforces Round 134 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1721/D // Memory Limit: 256 MB // Time Limit: 3000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int n; int a[N]; int b[N]; bool check(int x) { vector&lt;int&gt; c, d; for(int i = 1; i &lt;= n; i ++) { c.push_back(a[i] &amp; x); d.push_back((b[i] &amp; x) ^ x); } sort(c.begin(), c.end()); sort(d.begin(), d.end()); return c == d; } void solve() { cin &gt;&gt; n; int res = 0; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; b[i]; for(int i = 30; i &gt;= 0; i --) { if(check(res | (1 &lt;&lt; i))) res |= (1 &lt;&lt; i); } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1718A1/A2 - Burenka and Traditions (easy version)+(hard version) 题目大意：有一个长度为nnn的数组aaa，每一次操作可以选择一段区间[l,r][l,r][l,r]和一个非负整数xxx，花费[(r−l+1)/2][(r - l + 1) / 2][(r−l+1)/2]秒使区间内的数都异或xxx，问最少几秒才能把数组中所有元素变成000 数据范围：1≤n≤50001 \\leq n \\leq 50001≤n≤5000，0≤ai≤50000 \\leq a_i \\leq 50000≤ai​≤5000 题解：我们可以对操作做等价变形，我们可以发现操作其实可以分为两种： 异或一个数，代价为111 异或连续两个数，代价为111 显然，我们至多对每个数进行一次第一种操作，答案至多为nnn，考虑第二种操作对答案的影响，可以发现，如果一段连续的数异或为000，那么就可以连续用第二种操作，每用一次第二种操作，答案就会减少111，因此我们可以维护所有异或和为000的块，这启发我们考虑前缀和。 对原数组求前缀异或和sumsumsum，如果sum(1,l)=sum(1,r)sum(1,l)=sum(1,r)sum(1,l)=sum(1,r)，说明此时可以使用一次第二种操作，答案减少111，我们可以用mapmapmap来维护前缀异或和的值是否出现过，注意特判000的情况即可。 // Problem: A1. Burenka and Traditions (easy version) // Contest: Codeforces - Codeforces Round #814 (Div. 1) // URL: https://codeforces.com/problemset/problem/1718/A1 // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;string&gt; #define int long long using namespace std; void solve() { int n; cin &gt;&gt; n; int res = n; map&lt;int, int&gt; m; m[0] = 1; int seg = 0; for(int i = 1; i &lt;= n; i ++) { int x; cin &gt;&gt; x; seg ^= x; if(m.count(seg)) { res --; m.clear(); m[0] = 1; seg = 0; } else m[seg] = 1; } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1718B - Fibonacci Strings 题目大意：给定一个数列ck{c_k}ck​ 你可以执行若干次操作，对于第iii次操作： 选定一个[1,n][1,n][1,n]范围内的整数did_idi​，当i≥2i \\geq 2i≥2时，必须保证di≠di−1d_i \\neq d_{i - 1}di​​=di−1​。 将cdic_{d_i}cdi​​减去fif_ifi​，其中fif_ifi​是斐波那契数列中第iii项 问：c1c_1c1​至ckc_kck​能否全为0？ 数据范围：1≤k≤1061 \\leq k \\leq 10^61≤k≤106 题解：首先可以观察到，只有当∑i=1kci\\sum_{i = 1}^k c_i∑i=1k​ci​等于斐波那契数列某项的前缀和时，才有可能全为0 之后考虑如何选择最优解 优先考虑插入最小的数到最小的斐波那契数 优先考虑插入最大的数到最大的斐波那契数 显然方案2为最优解，注意特判每次不能选两个相同的下标插入即可 // Problem: B. Fibonacci Strings // Contest: Codeforces - Codeforces Round #814 (Div. 1) // URL: https://codeforces.com/problemset/problem/1718/B // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;queue&gt; #define int long long using namespace std; const int N = 2e5 + 10; typedef pair&lt;int, int&gt; PII; int a[N]; int feb[N]; int sum[N]; int idx = 0; void init() { feb[1] = 1; feb[2] = 1; sum[1] = 1; sum[2] = 2; for(int i = 3; i &lt;= 50; i ++) { feb[i] = feb[i - 1] + feb[i - 2]; sum[i] = sum[i - 1] + feb[i]; } } bool check(int s) { for(int i = 1; i &lt;= 50; i ++) { if(sum[i] == s) { idx = i; return true; } } return false; } void solve() { priority_queue&lt;PII, vector&lt;PII&gt; &gt; heap; idx = 0; int n; cin &gt;&gt; n; int s = 0; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; s += a[i]; heap.push({a[i], i}); } bool flag = 1; if(!check(s)) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return ; } int back = -1; for(int i = idx; i &gt;= 1; i --) { auto t = heap.top(); heap.pop(); if(t.second == back &amp;&amp; heap.size() &amp;&amp; heap.top().first != t.first) flag = 0; else if(t.second == back &amp;&amp; heap.size() &amp;&amp; heap.top().first == t.first) { auto tt = heap.top(); heap.pop(); heap.push(t); t = tt; } else if(t.second == back &amp;&amp; heap.empty()) flag = 0; if(t.first &gt;= feb[i]) { t.first -= feb[i]; heap.push(t); back = t.second; } else { flag = 0; break; } } if(flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; init(); while(T --) { solve(); } return 0; } 1716D - Chip Move 题目大意：给定两个数n,kn,kn,k，问从000开始，第iii步只能走(k+i−1)(k + i - 1)(k+i−1)的倍数，问分别走到x∈[1,n]x \\in [1,n]x∈[1,n]的方案数，对998244353取模。 数据范围：1≤k≤n≤2∗1051 \\leq k \\leq n \\leq 2*10^51≤k≤n≤2∗105 题解：待补充… // Problem: D. Chip Move // Contest: Codeforces - Educational Codeforces Round 133 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1716/D // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10, mod = 998244353; int dp[2][N], res[N]; void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; int sum = k, id = 1; dp[0][0] = 1; for(int i = k; sum &lt;= n; i ++) { id ^= 1; for(int j = i; j &lt;= n; j ++) dp[id][j] = (dp[id][j] + dp[id ^ 1][j - i] + dp[id][j - i]) % mod; dp[id][0] = 0, sum += i; for(int j = 1; j &lt;= n; j ++) { res[j] = (res[j] + dp[id][j]) % mod; dp[id ^ 1][j] = 0; } } for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } 1716C - Robot in a Hallway 题目大意： 题解： // Problem: C. Robot in a Hallway // Contest: Codeforces - Educational Codeforces Round 133 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1716/C // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int a[2][N], f[2][N]; int n; void solve() { cin &gt;&gt; n; for(int i = 0; i &lt;= 1; i ++) for(int j = 1; j &lt;= n; j ++) cin &gt;&gt; a[i][j]; a[0][1] = -1; f[0][n] = a[0][n], f[1][n] = a[1][n]; for(int i = 0; i &lt;= 1; i ++) for(int j = n - 1; j &gt;= 1; j --) f[i][j] = max(f[i][j + 1] - 1, a[i][j]); f[0][n] = max(a[1][n] - 1, a[0][n]); f[1][n] = max(a[0][n] - 1, a[1][n]); for(int i = 0; i &lt;= 1; i ++) for(int j = n - 1; j &gt;= 1; j --) f[i][j] = max(f[i][j + 1] - 1, max(a[i][j], a[i ^ 1][j] - 2 * (n - j) - 1)); int res = f[0][1] + 2 * n, rec = a[1][1] + 1;; for(int i = 2, p = 1; i &lt;= n; i ++, p ^= 1) { res = min(res, rec + (f[p][i] - rec &gt; 0 ? f[p][i] - rec : 0ll) + 2 * (n - i + 1)); rec = max(rec + 1, a[p][i] + 1); rec = max(rec + 1, a[p ^ 1][i] + 1); } res = min(res, rec); cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1700D -River Locks 题目大意： 题解： // Problem: D.River Locks // Contest: Codeforces - Codeforces Round #802 (Div. 2) // URL: https://codeforces.com/problemset/problem/1700/D // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int a[N], s[N]; int n, q; void solve() { cin &gt;&gt; n; double mmax = 0; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; s[i] = s[i - 1] + a[i]; mmax = max(mmax, (double)s[i] / i); } cin &gt;&gt; q; while(q --) { int x; cin &gt;&gt; x; if(mmax - x &gt; 1e-7) { cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; continue; } cout &lt;&lt; (s[n] + x - 1) / x &lt;&lt; endl; } } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } 1695C - Zero Path 题目大意： 题解： // Problem: C. Zero Path // Contest: Codeforces - Codeforces Round #801 (Div. 2) and EPIC Institute of Technology Round // URL: https://codeforces.com/problemset/problem/1695/C // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 1010, INF = 0x3f3f3f3f; int a[N][N]; int pd[N][N]; int dp[N][N]; void solve() { int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) cin &gt;&gt; a[i][j]; if((n + m - 1) &amp; 1) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return ; } int h = (n + m - 1) / 2; dp[1][1] = (a[1][1] == 1); for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + (a[i][j] == 1); for(int i = 2; i &lt;= n; i ++) pd[i][0] = INF; for(int i = 2; i &lt;= m; i ++) pd[0][i] = INF; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) pd[i][j] = min(pd[i - 1][j], pd[i][j - 1]) + (a[i][j] == 1); if(h &gt;= pd[n][m] &amp;&amp; h &lt;= dp[n][m]) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1592C - Bakry and Partitioning 题目大意： 题解： // Problem: C. Bakry and Partitioning // Contest: Codeforces - Codeforces Round #746 (Div. 2) // URL: https://codeforces.com/problemset/problem/1592/C // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10, M = N * 2; int h[N], e[M], ne[M], w[N], idx; int n, k; int dp[N]; bool v[N]; void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } void dfs(int u, int val) { dp[u] = w[u]; for(int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if(v[j]) continue; v[j] = true; dfs(j, val); if(dp[j] != val) dp[u] ^= dp[j]; } } void solve() { cin &gt;&gt; n &gt;&gt; k; memset(v, 0, sizeof v); idx = 0; int sum = 0; for(int i = 1; i &lt;= n; i ++) { h[i] = -1; dp[i] = 0; cin &gt;&gt; w[i]; sum ^= w[i]; } for(int i = 1; i &lt;= n - 1; i ++) { int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); add(b, a); } if(sum == 0) { cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; return; } else if(k == 2) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return; } dfs(1, sum); int cnt = 0; for(int i = 1; i &lt;= n; i ++) cnt += dp[i] == sum; if(cnt &gt;= 2) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1454 - E Number of Simple Paths 题目大意：给定一颗基环树，求基环树中长度大于等于111的不同简单路径的数量 题解: // Problem: E. Number of Simple Paths // Contest: Codeforces - Codeforces Round #686 (Div. 3) // URL: https://codeforces.com/problemset/problem/1454/E // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;queue&gt; #define int long long using namespace std; const int N = 2e5 + 10, M = N * 2; int h[N], e[M], ne[M], idx; int siz[N]; int n; bool v[N]; int d[N]; void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } void topsort() { queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i ++) if(d[i] == 1) q.push(i); while(q.size()) { int t = q.front(); q.pop(); for(int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if(-- d[j] == 1) q.push(j); } } } void dfs(int u, int fa) { siz[u] = 1; for(int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if(j != fa) { dfs(j, u); siz[u] += siz[j]; } } } void solve() { cin &gt;&gt; n; int res = 0, t = 0;; for(int i = 1; i &lt;= n; i ++) { h[i] = -1; v[i] = 0; siz[i] = 0; idx = 0; d[i] = 0; } for(int i = 1; i &lt;= n; i ++) { int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); add(b, a); d[a] ++; d[b] ++; } topsort(); for(int i = 1; i &lt;= n; i ++) if(d[i] &gt; 1) v[i] = true; for(int i = 1; i &lt;= n; i ++) { if(v[i]) { t = 0; for(int j = h[i]; ~j; j = ne[j]) { int p = e[j]; if(!v[p]) { dfs(p, i); t += siz[p]; } } res += t; res += t * (t - 1) / 2; } } cout &lt;&lt; n * (n - 1) - res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1619G - Unusual Minesweeper 题目大意： 题解： // Problem: G. Unusual Minesweeper // Contest: Codeforces - Codeforces Round #762 (Div. 3) // URL: https://codeforces.com/problemset/problem/1619/G // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10, INF = 1e18; typedef pair&lt;int, int&gt; PII; int n, k; pair&lt;pair&lt;int, int&gt;, int&gt; poi[N]; int p[N], t[N]; int res[N]; int x, y, id, l, i, ii, nn; int find(int x) { if(p[x] != x) p[x] = find(p[x]); return p[x]; } void solve() { cin &gt;&gt; n &gt;&gt; k; for(i = 1; i &lt;= n; i ++) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; t[i]; poi[i] = {{x, y}, i}; p[i] = i; } for(ii = 0; ii &lt; 2; ii ++) { sort(poi + 1, poi + 1 + n); for(i = 1; i &lt;= n; i ++) { y = poi[i].first.first; x = poi[i].first.second; id = poi[i].second; if(i &gt; 1 &amp;&amp; y == poi[i - 1].first.first &amp;&amp; x - poi[i - 1].first.second &lt;= k) { l = poi[i - 1].second; t[find(id)] = min(t[find(id)], t[find(l)]); p[find(l)] = find(id); } } for(int i = 1; i &lt;= n; i ++) swap(poi[i].first.first, poi[i].first.second); } nn = 0; for(i = 1; i &lt;= n; i ++) { if(find(i) == i) { nn ++; res[nn] = t[i]; } } sort(res + 1, res + nn + 1, greater&lt;int&gt; ()); res[nn + 1] = -INF; for(i = 1; i &lt;= nn; i ++) if(res[i + 1] &lt;= i - 1) break; cout &lt;&lt; i - 1 &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1728D - Letter Picking 题目大意： 题解： // Problem: D. Letter Picking // Contest: Codeforces - Educational Codeforces Round 135 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1728/D // Memory Limit: 512 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; void solve() { string s; cin &gt;&gt; s; s = '_' + s; int n = s.size() - 1; int i = 1, j = n; while(i &lt; j) { if(s[i] == s[j]) { i ++, j --; } else break; } while(i &lt; j) { if(s[i] == s[i + 1]) i += 2; else if(s[j] == s[j - 1]) j -= 2; else break; } if(i &lt; j) cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Draw&quot; &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1722F - L-shapes 题目大意： 题解：若一个点是L形的一部分，先用BFS四连通找此连通块是否是L形，再找此点的八连通看是否只有两个L形的一部分，若不是，则不合法。 // Problem: F. L-shapes // Contest: Codeforces - Codeforces Round #817 (Div. 4) // URL: https://codeforces.com/problemset/problem/1722/F // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;queue&gt; #define int long long using namespace std; const int N = 110; char g[N][N]; int n, m; bool v[N][N]; int dx4[4] = {1, -1, 0, 0}, dy4[4] = {0, 0, 1, -1}; int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1}, dy8[8] = {-1, 0, 1, 1, -1, -1, 0, 1}; int bfs_4(int sx, int sy) //判断L型 { if(v[sx][sy]) return 3; int cnt = 0; v[sx][sy] = 1; queue&lt;pair&lt;int, int&gt;&gt; q; q.push({sx, sy}); while(q.size()) { int x = q.front().first, y = q.front().second; q.pop(); cnt ++; for(int i = 0; i &lt; 4; i ++) { int zx = x + dx4[i], zy = y + dy4[i]; if(zx &amp;&amp; zy &amp;&amp; zx &lt;= n &amp;&amp; zy &lt;= m &amp;&amp; !v[zx][zy] &amp;&amp; g[zx][zy] == '*' &amp;&amp; abs(zx - sx) &lt;= 1 &amp;&amp; abs(zy - sy) &lt;= 1) { v[zx][zy] = 1; q.push({zx, zy}); } } } return cnt; } int bfs_8(int sx, int sy) { int cnt = 0; for(int i = 0; i &lt; 8; i ++) { int zx = sx + dx8[i], zy = sy + dy8[i]; if(zx &amp;&amp; zy &amp;&amp; zx &lt;= n &amp;&amp; zy &lt;= m &amp;&amp; g[zx][zy] == '*') cnt ++; } return cnt; } void solve() { memset(v, 0, sizeof v); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) cin &gt;&gt; g[i][j]; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) if(g[i][j] == '*') { int cnt4 = bfs_4(i, j); int cnt8 = bfs_8(i, j); if(cnt4 != 3 || cnt8 != 2) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return ; } } cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1647D Madoka and the Best School in Russia 题目大意： 如果nnn是ddd的倍数，则称nnn为“好数” 如果nnn是好数且不能写成任意两个好数之积，则称nnn是美丽数 T组询问，每组询问给定两个正整数x,dx,dx,d，问xxx是否有至少两种方式写为至少一个美丽数之积。如果是，输出“YES”，否则输出“NO” 题解：分类讨论 令$x = d^k \\times s ，其中，其中，其中k &gt; 0, d | s（题中（题中（题中x一定满足是一定满足是一定满足是d$的倍数） 则k−1k - 1k−1个ddd和一个d×sd \\times sd×s即为一种分解方案 考虑k=1k = 1k=1，则显然不合法 此时k&gt;1k &gt; 1k&gt;1 ​ 若sss为合数，则将其分解为两个数，分别乘在两个ddd上，得到第二种方案 此时sss为质数或111，显然只能拆ddd ​ 若ddd为质数，则ddd无法拆，不合法 ​ 若ddd含有与sss不同的质因数，将这个质因子乘ddd，剩下的部分与sss乘在另一个ddd上，得到第二种方案，此时需要3个ddd，即k&gt;2k &gt; 2k&gt;2 ​ 若d=sqd = s^qd=sq且q&gt;1q &gt;1q&gt;1 若q=2q = 2q=2，ddd可以拆成两个sss，然后将三个sss乘在三个ddd上，此时需要4个ddd，即k&gt;3k &gt; 3k&gt;3 若q&gt;2q &gt; 2q&gt;2，则ddd可以拆为sss和sq−1s^{q - 1}sq−1，将s2s^2s2和sq−1s^{q - 1}sq−1乘在一个ddd上，得到第二种方案，此时需要3个ddd，即k&gt;2k &gt; 2k&gt;2 // Problem: D. Madoka and the Best School in Russia // Contest: Codeforces - Codeforces Round #777 (Div. 2) // URL: https://codeforces.com/problemset/problem/1647/D // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; int x, d, k; bool check(int x) { if(x &lt; 4) return 1; if(x % 2 == 0 || x % 3 == 0) return 0; for(int i = 5; i * i &lt;= x; i += 6) if(x % i == 0 || x % (i + 2) == 0) return 0; return 1; } void solve() { cin &gt;&gt; x &gt;&gt; d; for(k = 0; x % d == 0; k ++, x /= d); if(k &lt; 2) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; else if(!check(x)) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else if(check(d)) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; else cout &lt;&lt; (k &gt; (x * x == d) + 2 ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 167B - Wizards and Huge Prize 题目大意： 最开始你有k的容积，有n轮比赛，比赛分为两种(具体种类由输入给出)，一种的奖品是增加ai容积，另一种增加一个物品，只有到最后的容积装得下所有赢得的物品才算合法的方案，问赢得的比赛总场数&gt;=l的合法方案的概率。 题解： 期望DP 将第二种奖品看成容积为−1-1−1，之后考虑DP dp[i][j][k]dp[i][j][k]dp[i][j][k]表示从前iii次比赛中获胜kkk次，容积为kkk时的概率 状态转移方程： 如果第i+1i+1i+1场比赛输掉，则有dp[i+1][j][k]+=dp[i][j][k]∗(1−p[i+1])dp[i+1][j][k] += dp[i][j][k] * (1 - p[i + 1])dp[i+1][j][k]+=dp[i][j][k]∗(1−p[i+1]) 如果第i+1i + 1i+1场比赛获胜，则有dp[i+1][j+1][k+a[i+1]+=dp[i][j][k]∗p[i+1]dp[i+1][j+1][k+a[i+1] += dp[i][j][k] * p[i + 1]dp[i+1][j+1][k+a[i+1]+=dp[i][j][k]∗p[i+1] AC 代码 // Problem: B. Wizards and Huge Prize // Contest: Codeforces - Codeforces Round #114 (Div. 1) // URL: https://codeforces.com/problemset/problem/167/B // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 210; int n, l, k; double dp[N][N][N * 2]; double res; int a[N]; double p[N]; void work() { dp[0][0][k + 200] = 1; //将-1考虑为容积为-1 for(int i = 0; i &lt; n; i ++) { for(int j = 0; j &lt;= i; j ++) { for(int q = 0; q &lt;= 400; q ++) { int t = min(400ll, q + a[i + 1]); dp[i + 1][j][q] += dp[i][j][q] * (1 - p[i + 1]); if(t &gt;= 0) dp[i + 1][j + 1][t] += dp[i][j][q] * p[i + 1]; } } } } void solve() { cin &gt;&gt; n &gt;&gt; l &gt;&gt; k; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; p[i]; p[i] /= 100; } for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; work(); for(int i = l; i &lt;= n; i ++) { for(int j = 200; j &lt;= 400; j ++) res += dp[n][i][j]; } printf(&quot;%.10lf\\n&quot;, res); } signed main() { //ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } CF730 - Bottles 题目大意： 有 nnn 瓶水，第 iii 瓶水的水量为 aia_iai​，容量为 bib_ibi​。将 111 单位水从一个瓶子转移到另一个瓶子所消耗时间为 111 秒，且可以进行无限次转移。求储存所有水所需最小瓶子数 kkk 以及该情况下所用最小时间 ttt。 题解： 01背包 第一问答案显然，考虑第二问 设dp[i][j][k]dp[i][j][k]dp[i][j][k]为前iii个瓶子里取kkk个瓶子，总容积为jjj的最大不倒入杯中的体积 状态转移方程：dp[i][j][k]=max(dp[i−1][j][k],dp[i−1][j−bi][k]+ai)dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - b_i][k] + a_i)dp[i][j][k]=max(dp[i−1][j][k],dp[i−1][j−bi​][k]+ai​) 第一维可以滚掉，答案即为Vsum−max(dp[j][k])V_{sum} - max(dp[j][k])Vsum​−max(dp[j][k]) AC 代码 // Problem: J. Bottles // Contest: Codeforces - 2016-2017 ACM-ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) // URL: https://codeforces.com/problemset/problem/730/J // Memory Limit: 512 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 110; int res, sum1, sum2; int n; int dp[N * N][N]; PII a[N]; int k; bool cmp(PII a, PII b) { return a.second &gt; b.second; } void work() { memset(dp, 128, sizeof dp); dp[0][0] = 0; for(int i = 1; i &lt;= n; i ++) for(int j = sum2; j &gt;= a[i].second; j --) for(int p = 1; p &lt;= k; p ++) dp[j][p] = max(dp[j][p], dp[j - a[i].second][p - 1] + a[i].first); for(int i = sum1; i &lt;= sum2; i ++) res = max(res, dp[i][k]); cout &lt;&lt; sum1 - res &lt;&lt; endl; } void solve() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i].first; sum1 += a[i].first; } for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i].second; } sort(a + 1, a + n + 1, cmp); while(sum2 &lt; sum1) sum2 += a[++ k].second; cout &lt;&lt; k &lt;&lt; &quot; &quot;; work(); } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://memsetray.github.io/categories/题解/"}],"tags":[],"keywords":[{"name":"题解","slug":"题解","permalink":"https://memsetray.github.io/categories/题解/"}]},{"title":"3分钟了解猫宫Hinata的FPS","slug":"3分钟了解猫宫Hinata的FPS","date":"2022-09-06T12:16:05.000Z","updated":"2022-09-06T12:22:54.473Z","comments":true,"path":"2022/09/06/3分钟了解猫宫Hinata的FPS/","link":"","permalink":"https://memsetray.github.io/2022/09/06/3分钟了解猫宫Hinata的FPS/","excerpt":"","text":"猫宫赛高！","categories":[{"name":"随想","slug":"随想","permalink":"https://memsetray.github.io/categories/随想/"}],"tags":[],"keywords":[{"name":"随想","slug":"随想","permalink":"https://memsetray.github.io/categories/随想/"}]},{"title":"随想test","slug":"随想test","date":"2022-09-05T14:54:56.000Z","updated":"2022-09-05T14:57:17.992Z","comments":true,"path":"2022/09/05/随想test/","link":"","permalink":"https://memsetray.github.io/2022/09/05/随想test/","excerpt":"","text":"为什么我FPS玩的这么菜！！！！","categories":[{"name":"随想","slug":"随想","permalink":"https://memsetray.github.io/categories/随想/"}],"tags":[],"keywords":[{"name":"随想","slug":"随想","permalink":"https://memsetray.github.io/categories/随想/"}]},{"title":"CodeForces1500-1600部分题题解","slug":"CodeForces1500-1600部分题题解","date":"2022-09-05T04:02:58.000Z","updated":"2022-09-05T14:53:15.719Z","comments":true,"path":"2022/09/05/CodeForces1500-1600部分题题解/","link":"","permalink":"https://memsetray.github.io/2022/09/05/CodeForces1500-1600部分题题解/","excerpt":"","text":"Codeforces 1500 - 1600难度笔记 1675E- Replace With the Previous, Minimize 给定一个长度为n的字符串，有k次操作，每次操作可以选一个字母，让所有该字母变成字典序的前一个字母，求能够通过k次操作得到的最小字典序。 贪心，维护一个max_idx表示从a到a + max_idx中的字母都可以通过max_idx次操作转化为a 如果当前字母转换为a的操作数 ≤k\\leq k≤k ,则直接更新max_idx 如果当前字母转换为a的操作数&gt;k&gt; k&gt;k，则该字母最多只能进行k−midxk - midxk−midx次操作，设当前字母为sss，则s−(k−midx)s-(k - midx)s−(k−midx) 到sss区间内的字母都可以转化为s−(k−midx)s - (k - midx)s−(k−midx)，因此直接将其转化为s−(k−midx)s - (k - midx)s−(k−midx) // Problem: E. Replace With the Previous, Minimize // Contest: Codeforces - Codeforces Round #787 (Div. 3) // URL: https://codeforces.com/problemset/problem/1675/E // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; string s; cin &gt;&gt; s; int max_idx = 0; for(int i = 0; i &lt; s.size(); i ++) { int t = s[i] - 'a'; if(t &lt;= k) max_idx = max(max_idx, t); else { char min_c = s[i] - k + max_idx; char max_c = s[i]; for(int j = 0; j &lt; s.size(); j ++) { if(min_c &lt;= s[j] &amp;&amp; s[j] &lt;= max_c) s[j] = min_c; } break; } } for(int i = 0; i &lt; s.size(); i ++) { if(s[i] - 'a' &lt;= max_idx) s[i] = 'a'; } cout &lt;&lt; s &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1673C- Palindrome Basis 给定一个数n，问有多少种拼法满足n可以被若干回文数拼成 回文数指正着看和倒着看的值相同的数 1≤n≤400001 \\leq n \\leq 400001≤n≤40000 首先观察到n的值域很小，直觉上告诉我们40000以内的回文数数量不多（事实上只有500个左右），因此我们先将n以内的回文数预处理出来。 剩下的问题就是，如何将n用回文数拼出来，这是一个经典的DP问题 设dp[i][j]表示从前i个回文数中选，拼成的数为j的方案数 于是状态转移方程非常显然： dp[i][j]=dp[i−1][j]+dp[i][j−p[i]]dp[i][j] = dp[i - 1][j] + dp[i][j - p[i]]dp[i][j]=dp[i−1][j]+dp[i][j−p[i]] 其中p[i]表示的是第i个回文数是多少 边界：∑i=1M−1dp[i][0]=1\\sum_{i=1}^{M - 1}dp[i][0] = 1∑i=1M−1​dp[i][0]=1，其中M - 1为回文数的个数 目标：dp[M−1][n]dp[M - 1][n]dp[M−1][n] // Problem: C. Palindrome Basis // Contest: Codeforces - Codeforces Round #785 (Div. 2) // URL: https://codeforces.com/problemset/problem/1673/C // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 4e4 + 10, M = 510, mod = 1e9 + 7; int dp[510][N]; vector&lt;int&gt; p; int reverse_i(int a) { int res = 0; while(a &gt; 0) { res = res * 10 + a % 10; a /= 10; } return res; } void init() { p.push_back(0); for(int i = 1; i &lt; N; i ++) { if(reverse_i(i) == i) p.push_back(i); } } void solve() { for(int i = 1; i &lt; M; i ++) dp[i][0] = 1; for(int i = 1; i &lt; M; i ++) { for(int j = 1; j &lt; N; j ++) { if(p[i] &lt;= j) dp[i][j] = (dp[i - 1][j] + dp[i][j - p[i]]) % mod; else dp[i][j] = dp[i - 1][j]; } } } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; init(); solve(); while(T --) { int n; cin &gt;&gt; n; cout &lt;&lt; dp[M - 1][n] % mod &lt;&lt; endl; } return 0; } 1665C- Tree Infection 给定一个n个节点的数，一开始n个节点都是健康的，每秒可以进行两种操作 选定一个节点，将其感染 如果节点v有一个子节点被感染，那么将传播到另一个子节点 求将所有节点传染所需的最小秒数 通过观察可以发现，任意两个不同的节点，它们的子节点互相独立，我们只关心每个节点有多少个儿子。 于是问题简化为：给定k个数，每个数表示该节点的子节点数量，每秒所有数减少1，并且你可以额外选择一个数使其减少1，求至少需要多少秒使得数组中所有数小于等于0 首先预处理出每个节点的子节点数量，将其从大到小排序并排除所有的0, 此时根据贪心，我们应该从大到小将所有子树先感染一遍，然后再次从大到小排序并排除所有小于等于0的数 之后，我们每次需要将数组中的所有数减1，并额外选择一个数减1，显然每次额外选择都应该选数组中最大的数，我们不断模拟这个过程，并且每次记录最大值最后出现下标last，额外操作就应当选择last对应的数，这样可以保证序列始终为单调递减。 // Problem: C. Tree Infection // Contest: Codeforces - Codeforces Round #781 (Div. 2) // URL: https://codeforces.com/problemset/problem/1665/C // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10, M = N * 2; int n; int res; void calc(vector&lt;int&gt; a) { if(a.empty()) return; int n = a.size(); int last = 0; for(int i = 0; i &lt; n; i ++) { if(a[i] == a[0]) last = i; else break; } -- a[last]; for(int i = 0; i &lt; n; i ++) a[i] --; res ++; while(a.size() &amp;&amp; a.back() &lt;= 0) a.pop_back(); calc(a); } void solve() { cin &gt;&gt; n; vector&lt;int&gt; a(n); for(int i = 1; i &lt; n; i ++) { int x; cin &gt;&gt; x; a[-- x] ++; } a.push_back(1); sort(a.begin(), a.end(), greater&lt;int&gt;()); while(a.size() &amp;&amp; a.back() &lt;= 0) a.pop_back(); n = a.size(); res = 0; for(int i = 0; i &lt; n; i ++) { a[i] = a[i] - (n - i); res ++; } sort(a.begin(), a.end(), greater&lt;int&gt;()); while(a.size() &amp;&amp; a.back() &lt;= 0) a.pop_back(); calc(a); cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1671D- Insert a Progression 给定一个数组a，再给出x个正整数1-x 将这x个数插入到数组a中（可以插入到任何一个位置，包括边界）得到a‘ a’的代价为数组中所有元素差的绝对值之和，求a’的最小代价 这道题最重要的是观察出结论：设原数组最大值为a，最小值为b，一定存在一种插入方式，使得数组a’中插入了大小为[a,b]的所有数，且满足代价不变。 一种比较好理解的方式是：假设原数组a中存在相邻的两个数axa_xax​,aya_yay​,不妨设ax&lt;aya_x &lt; a_yax​&lt;ay​,那么我们可以尝试在这两个数之间插入ay−ax−1a_y - a_x - 1ay​−ax​−1个正整数，而代价不变，因此所有在最值范围内的数都可以起到“桥梁”的作用。 因此我们需要先算出原数组的代价t，然后只需要看最值所覆盖的区间是否完全包含区间[1,x] 如果完全覆盖，则答案为t，否则考虑剩下的数如何放置 容易发现，除了1和x，剩下的所有数都是“桥梁”，对答案没有影响，因此我们只需要枚举1和x出现的位置，取最小值即可。 // Problem: D. Insert a Progression // Contest: Codeforces - Educational Codeforces Round 127 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1671/D // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int a[N]; int n, x; void solve() { cin &gt;&gt; n &gt;&gt; x; memset(a, 0, sizeof a); int res = 0; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; if(i &gt; 1) res += abs(a[i] - a[i - 1]); } int max_num = 0, min_num = 0x3f3f3f3f; for(int i = 1; i &lt;= n; i ++) { if(a[i] &gt; max_num) max_num = a[i]; if(a[i] &lt; min_num) min_num = a[i]; } if(x &gt; max_num) { if(n == 1) { res += x - a[1]; } else { int plus = 0x3f3f3f3f; for(int i = 1; i &lt; n; i ++) { plus = min(plus, x - a[i] + x - a[i + 1] - abs(a[i + 1] - a[i])); } plus = min(plus, min(x - a[n], x - a[1])); res += plus; } } if(min_num != 1) { if(n == 1) { res += a[1] - 1; } else { int plus = 0x3f3f3f3f; for(int i = 1; i &lt; n; i ++) { plus = min(plus, a[i] - 1 + a[i + 1] - 1 - abs(a[i + 1] - a[i])); } plus = min(plus, min(a[n] - 1, a[1] - 1)); res += plus; } } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1659C- Line Empire 你是一个国王，你有n个国家需要占领，起初你的首都在0位置处，现在你有两种操作： 将一个已经被占领的国家视为首都，代价为a∗∣c1−c2∣a *|c_1 - c_2|a∗∣c1​−c2​∣ 占领一个未被占领的国家，前提是这个国家与首都之间的所有国家都被占领，代价为b∗∣c1−c2∣b * |c_1 - c_2|b∗∣c1​−c2​∣ 其中c1,c2c_1,c_2c1​,c2​为两个国家的位置，求占领所有国家所需要的最小代价，最终首都可以在任何地方。 对于每个出现过的位置（包括0）我们都可以预处理出前缀和sum以及两个数组： 以该位置为首都，之后的所有国家都采用直接占领所需要的花费back[i]back[i]back[i] 在该位置之前，通过交替进行占领和替换首都使得该位置成为首都所需要的花费pre[i]pre[i]pre[i] 其中back[i]=(sum[n]−sum[i]−(n−i)∗x[i])∗bback[i] = (sum[n] - sum[i] - (n - i) * x[i]) * bback[i]=(sum[n]−sum[i]−(n−i)∗x[i])∗b pre[i]=x[i]∗(a+b)pre[i] = x[i] * (a + b)pre[i]=x[i]∗(a+b) 枚举所有的位置，答案即为min(pre[i]+back[i])min(pre[i] + back[i])min(pre[i]+back[i]) 为什么交替进行操作的方式一定是最优的：如果我们并没有采用交替的方式进行操作，就一定会连续进行若干次占领操作，之后仍然要通过替换操作使得首都到达目标位置，显然进行了多余的占领操作，代价变大。 // Problem: C. Line Empire // Contest: Codeforces - Codeforces Round #782 (Div. 2) // URL: https://codeforces.com/problemset/problem/1659/C // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int n, a, b; int x[N]; int sum[N]; int back[N]; int pre[N]; void solve() { cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; x[i]; for(int i = 1; i &lt;= n; i ++) { sum[i] = sum[i - 1] + x[i]; } for(int i = 0; i &lt;= n; i ++) { pre[i] = x[i] * (a + b); back[i] = (sum[n] - sum[i] - (n - i) * x[i]) * b; } int res = 1e18; for(int i = 0; i &lt;= n; i ++) { res = min(res, pre[i] + back[i]); } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1658D1- 388535 (Easy Version) 给定一个区间[l,r][l,r][l,r]，已知原数组是[l,r][l,r][l,r]的排列，现在给出原数组异或xxx后的数组，求出任意一个xxx的可能值 Easy Verson数据范围：0=l≤r&lt;2170 = l \\leq r &lt; 2^{17}0=l≤r&lt;217 由于位运算每一位独立，我们考虑每一位按位异或的值。 对于每个二进制位，分别统计当前排列（下标）中1的个数，以及当前数组元素中1的个数，如果不相同，说明当前这一位需要进行一次异或，即xxx的当前位为1，考虑完所有的位就得到了xxx. // Problem: D1. 388535 (Easy Version) // Contest: Codeforces - Codeforces Round #779 (Div. 2) // URL: https://codeforces.com/problemset/problem/1658/D1 // Memory Limit: 256 MB // Time Limit: 1000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = (1 &lt;&lt; 17) + 5; int l, r; int a[N]; void solve() { cin &gt;&gt; l &gt;&gt; r; for(int i = l; i &lt;= r; i ++) cin &gt;&gt; a[i]; int res = 0; for(int j = 0; j &lt;= 17; j ++) { int cnt_idx = 0, cnt_num = 0; for(int i = l; i &lt;= r; i ++) { if(i &amp; (1 &lt;&lt; j)) cnt_idx ++; if(a[i] &amp; (1 &lt;&lt; j)) cnt_num ++; } if(cnt_idx != cnt_num) res += 1 &lt;&lt; j; } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1658D2- 388535 (Hard Version) 给定一个区间[l,r][l,r][l,r]，已知原数组是[l,r][l,r][l,r]的排列，现在给出原数组异或xxx后的数组，求出任意一个xxx的可能值 Easy Verson数据范围：0≤l≤r&lt;2170 \\leq l \\leq r &lt; 2 ^ {17}0≤l≤r&lt;217 通过观察（或许）可以发现：aaa中一定存在一个数aia_iai​，使得ai⊕x=la_i \\oplus x = lai​⊕x=l，于是我们可以确定存在一个aia_iai​使得x=ai⊕lx = a_i\\oplus lx=ai​⊕l 由于aaa中的数互不相同，所以其中的数异或上xxx也互不相同，我们用数组bbb来存储ai⊕la_i \\oplus lai​⊕l的值，然后维护一个01Trie来查找bi⊕aib_i \\oplus a_ibi​⊕ai​的最大值和最小值，这个值bib_ibi​需要满足最大值为lll，最小值为rrr #include&lt;bits/stdc++.h&gt; #define N 1000005 #define int long long using namespace std; int T,l,r,a[N],cnt,trie[N][30],b[N]; void insert(int sum){ int now=0; for(int i=17;i&gt;=0;i--){ bool tmp=(1&lt;&lt;i)&amp;sum; if(!trie[now][tmp])trie[now][tmp]=++cnt; now=trie[now][tmp]; } } int Max(int sum){ int now=0,res=0; for(int i=17;i&gt;=0;i--){ bool tmp=(1&lt;&lt;i)&amp;sum; if(!trie[now][tmp^1])now=trie[now][tmp]; else now=trie[now][tmp^1],res+=(1&lt;&lt;i); } return res; } int Min(int sum){ int now=0,res=0; for(int i=17;i&gt;=0;i--){ bool tmp=(1&lt;&lt;i)&amp;sum; if(!trie[now][tmp])now=trie[now][tmp^1],res+=(1&lt;&lt;i); else now=trie[now][tmp]; } return res; } signed main() { cin&gt;&gt;T; while(T--){ cin&gt;&gt;l&gt;&gt;r; for(int i=0;i&lt;=cnt;i++)trie[i][0]=trie[i][1]=0; cnt=0; for(int i=l;i&lt;=r;i++)cin&gt;&gt;a[i],b[i]=a[i]^l; for(int i=l;i&lt;=r;i++)insert(a[i]); for(int i=l;i&lt;=r;i++){ if(Max(b[i])==r&amp;&amp;Min(b[i])==l){ cout&lt;&lt;b[i]&lt;&lt;endl; break; } } } } 1651C- Fault-tolerant Network 给定两个数组a,ba,ba,b，数组aaa相邻两个元素之间通过线相连，数组bbb同理，现在要将a,ba,ba,b两个数组互相连接，连接的代价为∣a[i]−b[j]∣|a[i]-b[j]|∣a[i]−b[j]∣要求当删除两个数组中任意一个元素时，剩下的所有元素仍然能通过线连通，且代价最小。 通过观察可以发现，想要让两个数组在删除一个任意一个数的情况下保持连通，则两个数组的开头和末尾一定要有线来连接。 假设某一个数组的开头或结尾没有数连接，那么当我们删除这个数的时候，会发现这个数一定是孤立的状态，所以上面结论成立。 进一步观察可以发现，只要保证两个数的开头或结尾处于连接状态，此时两个数组已经可以保证在删除任意数的条件下保持连通，不需要添加额外的边。因此我们只需要分别求这四个点进行连线的最小代价，最后求和即可。 本题还要注意边界问题：四个点互相连线的情况下需要特判最小值。 // Problem: C. Fault-tolerant Network // Contest: Codeforces - Educational Codeforces Round 124 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1651/C // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10, INF = 2e18; int a[N], b[N]; int n; void solve() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; b[i]; int st1 = a[1], ed1 = a[n], st2 = b[1], ed2 = b[n]; int t1, t2, t3, t4; t1 = t2 = t3 = t4 = INF; int idx1, idx2, idx3, idx4; for(int i = 1; i &lt;= n; i ++) { t1 = min(t1, abs(b[i] - st1)); t2 = min(t2, abs(b[i] - ed1)); t3 = min(t3, abs(a[i] - st2)); t4 = min(t4, abs(a[i] - ed2)); } int res = t1 + t2 + t3 + t4; res = min(res, min(abs(st1 - ed2) + abs(st2 - ed1), abs(st1 - st2) + abs(ed1 - ed2))); res = min(res, min(abs(st1 - st2) + t2 + t4, abs(ed1 - ed2) + t1 + t3)); res = min(res, min(abs(st1 - ed2) + t2 + t3, abs(st2 - ed1) + t1 + t4)); cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1646C- Factorials and Powers of Two 定义好数：如果某个数可以被表示为d!d!d!或2d2^d2d，则这个数被称为好数 给定一个数nnn，求nnn最少可以被拆分成多少个好数的和 数据范围：1≤n≤10121 \\leq n \\leq 10^{12}1≤n≤1012 首先任何一个正整数一定可以被拆分成若干个好数的和，因为该数一定可以由二进制表示，且最多拆为二进制中1的个数 然后可以发现，101210^{12}1012以内的阶乘数很少，最多只有15个 于是方法非常显然：枚举阶乘数的所有使用情况的总和，剩下的数用二进制表示，答案取最小值，采用DFS暴搜即可 // Problem: C. Factorials and Powers of Two // Contest: Codeforces - Codeforces Round #774 (Div. 2) // URL: https://codeforces.com/problemset/problem/1646/C // Memory Limit: 256 MB // Time Limit: 3000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 2e5 + 10; int n; int p[50], cnt; bool v[50]; void init() { int t = 1; for(int i = 1; i &lt;= 15; i ++) { t *= i; p[i] = t; } } int dfs(int fac, int val, int idx) { if(val &lt; 0) return 1e18; else if(fac == 16) { int res = 0; while(val &gt; 0) { if(val &amp; 1) res ++; val &gt;&gt;= 1; } return res + idx; } else return min(dfs(fac + 1, val, idx), dfs(fac + 1, val - p[fac], idx + 1)); } void solve() { int n; cin &gt;&gt; n; cout &lt;&lt; dfs(1, n, 0) &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; init(); while(T --) { solve(); } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://memsetray.github.io/categories/题解/"}],"tags":[],"keywords":[{"name":"题解","slug":"题解","permalink":"https://memsetray.github.io/categories/题解/"}]},{"title":"CodeForces2000-2300难度部分题题解","slug":"CodeForces2000-2300难度部分题题解","date":"2022-09-05T00:35:49.000Z","updated":"2022-09-05T14:53:28.406Z","comments":true,"path":"2022/09/05/CodeForces2000-2300难度部分题题解/","link":"","permalink":"https://memsetray.github.io/2022/09/05/CodeForces2000-2300难度部分题题解/","excerpt":"","text":"Codeforces 2000-2300 难度题解 808G-Anthem of Berland 题目描述：给定 sss 串和 ttt 串，其中 sss 串包含小写字母和问号，ttt 串只包含小写字母。 假设共有 kkk 个问号。 你需要给把每个问号变成一个小写字母，共有 26k26^k26k 种可能。 对于每种可能，设 ttt 匹配 sss 的次数为 fif_ifi​，请输出 max⁡(fi)\\max(f_i)max(fi​) 。 数据范围：1≤∣s∣,∣t∣≤105,∣s∣∗∣t∣≤1071 \\leq |s|,|t| \\leq 10^5,|s|*|t| \\leq 10^71≤∣s∣,∣t∣≤105,∣s∣∗∣t∣≤107 题解：KMP自动机：构建一个数组aut[i][c]aut[i][c]aut[i][c]，表示模式串的前i−1i - 1i−1位已经匹配完成，用ccc与tit_iti​匹配后的匹配长度 构造方式：先求出nextnextnext数组 aut[i][c]={aut[next[i−1]+1][c],i=1∣∣ti≠ci+[ti=c],a&lt;1aut[i][c] = \\begin{cases} aut[next[i - 1] + 1][c],&amp;i = 1 || t_i \\neq c \\\\ i + [t_i = c],&amp;a &lt; 1 \\end{cases} aut[i][c]={aut[next[i−1]+1][c],i+[ti​=c],​i=1∣∣ti​​=ca&lt;1​ 首先构建KMP自动机，然后考虑DP 设dp[i][j]dp[i][j]dp[i][j]为当前扫描到sss的第iii位，在KMP自动机上的节点jjj匹配的最大次数 状态转移方程： dp[i][j]=max(dp[i][j],dp[i−1][j]+(j==m))dp[i][j] = max(dp[i][j], dp[i - 1][j] + (j == m))dp[i][j]=max(dp[i][j],dp[i−1][j]+(j==m)) 答案为∑∣t∣1max(dp[∣s∣][i])\\sum^1_{|t|} max(dp[|s|][i])∑∣t∣1​max(dp[∣s∣][i])，时间复杂度O(∣s∣∗∣t∣∗26)O(|s|*|t|*26)O(∣s∣∗∣t∣∗26) // Problem: G. Anthem of Berland // Contest: Codeforces - Educational Codeforces Round 21 // URL: https://codeforces.com/contest/808/problem/G // Memory Limit: 256 MB // Time Limit: 3000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 1e5 + 10; int n, m; int dp[2][N]; int ne[N], aut[N][26]; char s[N], t[N]; void init_ne() { ne[1] = 0; for(int i = 2, j = 0; i &lt;= m; i ++) { while(j &amp;&amp; t[i] != t[j + 1]) j = ne[j]; if(t[i] == t[j + 1]) j ++; ne[i] = j; } } void init_KMPAM() { for(int i = 1; i &lt;= m; i ++) { for(int c = 0; c &lt; 26; c ++) { if(i &gt; 1 &amp;&amp; t[i] != c + 'a') aut[i][c] = aut[ne[i - 1] + 1][c]; else aut[i][c] = i + (t[i] == c + 'a'); } } } void dp_KMP() { memset(dp, 0xcf, sizeof dp); //初始化负无穷 dp[0][1] = 0; for(int i = 1; i &lt;= n; i ++) { if(s[i] == '?') { for(int j = 1; j &lt;= m; j ++) { for(int c = 0; c &lt; 26; c ++) dp[i &amp; 1][aut[j][c]] = max(dp[i &amp; 1][aut[j][c]], dp[(i - 1) &amp; 1][j] + (aut[j][c] == m)); } } else { for(int j = 1; j &lt;= m; j ++) dp[i &amp; 1][aut[j][s[i] - 'a']] = max(dp[i &amp; 1][aut[j][s[i] - 'a']], dp[(i - 1) &amp; 1][j] + (aut[j][s[i] - 'a'] == m)); } for(int j = 1; j &lt;= m; j ++) dp[(i - 1) &amp; 1][j] = -0x3f3f3f3f; } } void solve() { cin &gt;&gt; (s + 1) &gt;&gt; (t + 1); n = strlen(s + 1), m = strlen(t + 1); t[++ m] = '#'; //加特殊字符 init_ne(); init_KMPAM(); dp_KMP(); int mmax = 0; for(int j = 1; j &lt;= m; j ++) mmax = max(mmax, dp[n &amp; 1][j]); cout &lt;&lt; mmax &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } 1721E- Prefix Function Queries 题目大意：给定字符串sss,以及qqq个串tit_iti​，求将sss分别与每个tit_iti​拼接起来后，最靠右的∣ti∣|t_i|∣ti​∣个前缀的border长度，每个询问相互独立 数据范围：∣s∣≤106,q≤105,∣ti∣≤10|s| \\leq 10^6, q \\leq 10^5, |t_i| \\leq 10∣s∣≤106,q≤105,∣ti​∣≤10 题解：对原串sss求KMP自动机，每次询问在线构造s+ts + ts+t中ttt部分的KMP自动机，输出对应的next值即可 // Problem: E. Prefix Function Queries // Contest: Codeforces - Educational Codeforces Round 134 (Rated for Div. 2) // URL: https://codeforces.com/problemset/problem/1721/E // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; using namespace std; const int N = 1e6 + 10; char s[N]; int ne[N], aut[N][27]; int n, m; void init_next() { ne[1] = 0; for(int i = 2, j = 0; i &lt;= n; i ++) { while(j &amp;&amp; s[i] != s[j + 1]) j = ne[j]; if(s[i] == s[j + 1]) j ++; ne[i] = j; } } void init_KMPAM() { for(int i = 0; i &lt; n; i ++) { for(int c = 1; c &lt;= 26; c ++) { aut[i][c] = aut[ne[i]][c]; } aut[i][s[i + 1] - 'a' + 1] = i; } } void solve() { int q; cin &gt;&gt; (s + 1); n = strlen(s + 1); init_next(); init_KMPAM(); cin &gt;&gt; q; while(q --) { cin &gt;&gt; (s + n + 1); m = n + strlen(s + n + 1); for(int i = n + 1, k = ne[n]; i &lt;= m; i ++) { int id = i - 1; k = aut[k][s[i] - 'a' + 1]; if(s[i] == s[k + 1]) k ++; ne[i] = k; cout &lt;&lt; k &lt;&lt; &quot; &quot;; for(int c = 1; c &lt;= 26; c ++) aut[id][c] = aut[ne[id]][c]; aut[id][s[i] - 'a' + 1] = id; } cout &lt;&lt; endl; } } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); solve(); return 0; } 1712D- Empty Graph 题目大意：给定一个长度为nnn的序列aaa 定义一个nnn个点的无向完全图，点lll和点rrr之间的距离为minl≤i≤r{a[i]}\\underset{l\\leq i \\leq r}{min} \\{a[i]\\}l≤i≤rmin​{a[i]} 你可以进行kkk次操作，每次操作可以选定1−n1-n1−n中任意一个数并将aia_iai​赋值为一个[1,109][1,10^9][1,109]的整数，请最大化这个图的直径。 图的直径定义为max1≤u≤v≤nd(u,v)\\underset{1 \\leq u \\leq v \\leq n}{max}d(u,v)1≤u≤v≤nmax​d(u,v)，其中d(u,v)d(u,v)d(u,v)为uuu到vvv的最短路长度。 题解：本题的答案具有最大值最小的性质，考虑二分答案 首先需要发现一个性质：对于两点间的最短路，最多走两条边，要么走两点直接相连的边，要么先走一个最小边走到某个点，再从这个点走到目标点 ，即 d(u,v)=min(e(u,v),2∗mmin)d(u,v) = min(e(u,v),2*mmin) d(u,v)=min(e(u,v),2∗mmin) 其中mminmminmmin为min1≤i≤n{ai}\\underset{1 \\leq i \\leq n}{min} \\{ai\\}1≤i≤nmin​{ai},e(u,v)=minu≤i≤v−1(e(ai,ai+1))e(u,v) = \\underset{u \\leq i \\leq v - 1}{min}(e(a_i,a_{i + 1}))e(u,v)=u≤i≤v−1min​(e(ai​,ai+1​)) 设图的直径为lll，由此可得： \\begin{align} l &amp;= max(min(e(u,v), 2*mmin)) \\\\ &amp;= min(max(e(u,v)), 2*mmin) \\\\ &amp;= min(max(\\underset{1 \\leq i \\leq n - 1}{min}(a_i, a_{i + 1})), 2 * mmin) \\end{align} 至此我们已经知道如何二分答案： 设当前二分的答案为midmidmid，我们需要将所有值小于等于mid2\\frac{mid}{2}2mid​的点赋值为10910^9109，因为这些点走两次之后依然比答案小，我们就一定要修改这些边，同时记录修改的次数 如果被修改次数大于kkk，则显然不合法 如果被修改次数等于kkk，我们需要求出此时的直径lll，如果l&gt;=midl &gt;= midl&gt;=mid，那么midmidmid显然合法 如果被修改次数小于kkk，我们需要分类讨论一下： ​ 如果k&gt;1k &gt;1k&gt;1，说明我们还有更多修改余地，已经不需要修改了，那么一定合法 ​ 如果k=1k = 1k=1，说明不存在小于等于mid2\\frac{mid}{2}2mid​的点，此时我们仅能修改一条边，观察上面的公式，我们需要求出max(min1≤i≤n−1(ai,ai+1))max(\\underset{1 \\leq i \\leq n - 1}{min}(a_i, a_{i + 1}))max(1≤i≤n−1min​(ai​,ai+1​)) ​ 换句话说，我们只需要求出是否存在ai≥mida_i \\geq midai​≥mid，如果存在，我们就要把与他相邻的另一个改成10910^9109即可。 // Problem: D. Empty Graph // Contest: Codeforces - Codeforces Round #813 (Div. 2) // URL: https://codeforces.com/problemset/problem/1712/D // Memory Limit: 256 MB // Time Limit: 1500 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 1e5 + 10; int n, k; bool check(vector&lt;int&gt; a, int mid, int t) { for(int i = 0; i &lt; a.size(); i ++) if(a[i] * 2 &lt; mid) t --, a[i] = 1e9; if(t &lt; 0) return false; if(t == 0) { for(int i = 0; i &lt; a.size() - 1; i ++) if(min(a[i], a[i + 1]) &gt;= mid) return true; } else if(t == 1) return *max_element(a.begin(), a.end()) &gt;= mid; else return true; return false; } void solve() { vector&lt;int&gt; a; cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i ++) { int x; cin &gt;&gt; x; a.push_back(x); } int l = 1, r = 1e9; while(l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if(check(a, mid, k)) l = mid; else r = mid - 1; } cout &lt;&lt; l &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; } 1706E- Qpwoeirut and Vertices 题目大意：给出nnn个点，mmm条边的不带权连通无向图，qqq次询问至少要加完编号前多少的边，才能使得[l,r][l,r][l,r]中的所有点两两连通。 题解：前置知识：Kruskal重构树\\textcolor{pink}{Kruskal重构树}Kruskal重构树 KruskalKruskalKruskal重构树是将一张无向图经过KruskalKruskalKruskal算法得到最小生成树后，再将其重建成一颗二叉树，原图中所有的叶子结点都是原图中的点，其他点具有一个点权www，表示左集合到右集合的边权。 KruskalKruskalKruskal重构树的性质：原图中两点之间所有简单路径上最大边权的最小值=最小生成树上两个点之间的简单路径上的最大值=KruskalKruskalKruskal重构树上两点之间LCA的权值 eg1eg_1eg1​：求节点uuu到节点vvv路径的最大边权，就是求LCA(u,v)LCA(u,v)LCA(u,v)的点权 eg2eg_2eg2​:从点uuu出发，给定一个值ttt，在通过所有边的权值小于等于ttt时，走过了多少个点 =&gt;=&gt;=&gt;从点uuu向上找，找到最后一个小于等于ttt的虚点，子树中的点都可以通过（因为重构树上的点从上往下点权单调不升） 回到这道题，结论显而易见：使得(u,v)(u,v)(u,v)之间两两连通的最小边权为重构树上的v(LCA(u,v))v(LCA(u,v))v(LCA(u,v))，其中vvv为点权。 剩下的问题是处理所有询问，我们可以采用ST表预处理所有询问，或者采用线段树。多个点的LCALCALCA的求法：取出其中dfndfndfn最小和最大的点求LCALCALCA即为答案。 // Problem: E. Qpwoeirut and Vertices // Contest: Codeforces - Codeforces Round #809 (Div. 2) // URL: https://codeforces.com/problemset/problem/1706/E // Memory Limit: 256 MB // Time Limit: 2000 ms // Author:Ray #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define int long long using namespace std; const int N = 1e5 + 10, M = N * 2; struct Edge{ int x, y; }e[M]; struct D{ int l, r, c; int fa[20]; int p; int depth; }d[M]; int n, m, q; int t[N * 4]; void init() { for(int i = 1; i &lt;= n; i ++) { memset(d[i].fa, 0, sizeof d[i].fa); d[i].p = d[i].l = d[i].r = d[i].c = 0; } } int find(int x) { if(d[x].p != x) d[x].p = find(d[x].p); return d[x].p; } void merge_seg(int x, int y, int c) { int px = find(x), py = find(y); if(px == py) return ; else n ++; d[px].p = d[py].p = d[n].p = n; d[px].fa[0] = d[py].fa[0] = n; d[n].l = px, d[n].r = py, d[n].c = c; } void kruskal() { for(int i = 1; i &lt;= n; i ++) d[i].p = i; for(int i = 1; i &lt;= m; i ++) merge_seg(e[i].x, e[i].y, i); } void dfs(int x) { if(x == 0) return ; d[x].depth = d[d[x].fa[0]].depth + 1; for(int i = 1; i &lt;= 18; i ++) d[x].fa[i] = d[d[x].fa[i - 1]].fa[i - 1]; dfs(d[x].l); dfs(d[x].r); } int lca(int x, int y) { if(d[x].depth &lt; d[y].depth) swap(x, y); for(int i = 18; i &gt;= 0; i --) if(d[d[x].fa[i]].depth &gt;= d[y].depth) x = d[x].fa[i]; if(x == y) return y; for(int i = 18; i &gt;= 0; i --) if(d[x].fa[i] != d[y].fa[i]) { x = d[x].fa[i]; y = d[y].fa[i]; } return d[y].fa[0]; } int build(int x, int l ,int r) { int mid = l + r &gt;&gt; 1; if(l == r) t[x] = mid; else t[x] = lca(build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r)); return t[x]; } int query(int x, int l, int r, int a, int b) { int mid = l + r &gt;&gt; 1; if(a == l &amp;&amp; b == r) return t[x]; else { if(b &lt;= mid) return query(x &lt;&lt; 1, l, mid, a, b); if(a &gt; mid) return query(x &lt;&lt; 1 | 1, mid + 1, r, a, b); return lca(query(x &lt;&lt; 1, l, mid, a, mid), query(x &lt;&lt; 1 | 1, mid + 1, r, mid + 1, b)); } } void solve() { init(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; int nn = n; for(int i = 1; i &lt;= m; i ++) cin &gt;&gt; e[i].x &gt;&gt; e[i].y; kruskal(); dfs(n); build(1, 1, nn); for(int i = 1; i &lt;= q; i ++) { int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; d[query(1, 1, nn, l, r)].c &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while(T --) { solve(); } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://memsetray.github.io/categories/题解/"}],"tags":[],"keywords":[{"name":"题解","slug":"题解","permalink":"https://memsetray.github.io/categories/题解/"}]}]}